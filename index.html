<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <title>Flashcards de Inglés Fácil: Aprende Vocabulario Interactivo con Mazos y Audio</title>

    <meta name="description" content="Mejora tu vocabulario en inglés con flashcards interactivas, mazos personalizables y pronunciación de audio. Aprende nuevas palabras, gestiona tus mazos y progreso, y haz crecer tu árbol de conocimiento. ¡Estudia inglés fácil!">

    <meta name="keywords" content="flashcards inglés, aprender inglés, vocabulario inglés, pronunciación inglés, audio inglés, mazos de estudio, inglés fácil, tarjetas de memoria, estudiar inglés, memorizar palabras, app inglés, aplicación para aprender inglés, mejorar inglés">

    <link rel="canonical" href="https://flashcards-inglesfacil.netlify.app/">

    <meta name="robots" content="index, follow">

    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6819141919218513"
     crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Flashcards de Inglés Fácil con Mazos y Audio",
      "description": "Aplicación web interactiva con flashcards, gestión de mazos y pronunciación de audio para aprender y memorizar vocabulario en inglés de forma fácil y divertida, con seguimiento de progreso y elementos de gamificación como un árbol de palabras.",
      "applicationCategory": "EducationalApplication, GameApplication",
      "operatingSystem": "Web",
      "browserRequirements": "Requires HTML5 support, JavaScript enabled, Web Speech API.",
      "url": "https://www.tu-dominio.com/ruta-a-esta-app/", /* ¡REEMPLAZA ESTO! */
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "author": {
        "@type": "Person", /* O "Person" si eres un desarrollador individual */
        "name": "Nemus" /* ¡REEMPLAZA ESTO! */
      },
      "keywords": "flashcards, inglés, aprender inglés, vocabulario, pronunciación, audio, estudiar, memorizar, aplicación educativa, juego educativo, mazos de estudio"
    }
    </script>

    <style>
        :root {
            --duo-green: #4CAF50;
            --duo-green-dark: #388E3C;
            --duo-green-light: #66BB6A;
            --duo-blue: #1cb0f6;
            --duo-blue-dark: #138bc4;
            --duo-red: #ff4b4b;
            --duo-red-dark: #fa2d2d;
            --duo-orange: #ff9600;
            --duo-orange-dark: #e88800;
            --duo-yellow: #ffc800;
            --duo-gray-lightest: #f7f7f7;
            --duo-gray-light: #e5e5e5;
            --duo-gray-medium: #afafaf;
            --duo-gray-dark: #777777;
            --duo-text-dark: #4b4b4b;
            --duo-text-light: #ffffff;
            --duo-correct-bg: #d7ffb8;
            --duo-correct-text: #58a700;
            --duo-incorrect-bg: #ffdfe0;
            --duo-incorrect-text: #ea2b2b;
        }

        html, body {
            margin: 0;
            font-family: 'Nunito', sans-serif;
            background-color: var(--duo-gray-lightest);
            color: var(--duo-text-dark);
        }
        .app-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            height: auto; /* Cambiará en móvil */
            padding: 0.75rem; /* Cambiará en móvil */
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        .app-header {
            margin-bottom: 0.75rem;
            text-align: center;
            width: 100%;
            max-width: 1400px;
        }
        .app-header h1 {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--duo-green);
            margin-bottom: 0.5rem;
        }

        .main-content-area {
            display: flex;
            width: 100%;
            max-width: 1400px;
            flex-grow: 1;
            gap: 1rem;
            overflow: visible; /* Cambiará en móvil */
        }

        .column-title {
            font-size: 1.4rem;
            font-weight: 800;
            color: var(--duo-text-dark);
            text-align: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--duo-gray-light);
        }

        .sidebar {
            background-color: var(--duo-text-light);
            padding: 1.1rem;
            border-radius: 1rem;
            border: 1px solid var(--duo-gray-light);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }
        .sidebar-section .section-title {
            font-size: 1.0rem;
            font-weight: 700;
            margin-bottom: 0.6rem;
            text-align: center;
            color: var(--duo-text-dark);
        }
        .sidebar-section .button-group .btn {
            font-size: 0.8rem;
            padding: 0.6rem 1rem;
            width: auto;
        }
        .sidebar .stats-grid {
            grid-template-columns: repeat(auto-fit, minmax(75px, 1fr));
            gap: 0.4rem;
            margin-bottom: 0;
        }
        .sidebar .stat-item h3 { font-size: 0.65rem; }
        .sidebar .stat-item p { font-size: 1rem; }

        .content-wrapper-main {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 1rem;
            overflow: visible;
        }

        .study-panel, .tree-panel {
            background-color: var(--duo-text-light);
            padding: 1.1rem;
            border-radius: 1rem;
            border: 1px solid var(--duo-gray-light);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            overflow-y: visible;
        }

        #flashcard-section { margin-bottom: 0.75rem; }
        .flashcard {
            background-color: var(--duo-text-light);
            border: 2px solid var(--duo-gray-light);
            padding: 1.1rem;
            border-radius: 0.75rem;
            margin-bottom: 0.75rem;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.03);
        }
        .question-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        #question-text {
            font-size: 1.15rem;
            font-weight: 700;
            color: var(--duo-text-dark);
        }
        #speaker-icon-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--duo-blue);
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }
        #speaker-icon-button:hover {
            color: var(--duo-blue-dark);
        }
        #speaker-icon-button:disabled {
            color: var(--duo-gray-medium);
            cursor: not-allowed;
        }


        .input-field {
            padding: 0.6rem 0.9rem;
            border: 2px solid var(--duo-gray-light);
            border-radius: 0.75rem;
            width: 100%;
            max-width: 280px;
            margin: 0.375rem auto;
            box-sizing: border-box;
            font-size: 0.9rem;
            color: var(--duo-text-dark);
            transition: border-color 0.2s ease;
        }
        .input-field:focus {
            border-color: var(--duo-blue);
            outline: none;
            box-shadow: 0 0 0 3px rgba(28, 176, 246, 0.2);
        }
        .feedback {
            margin-top: 0.375rem;
            font-weight: 700;
            min-height: 20px;
            font-size: 0.85rem;
            margin-bottom: 0.6rem;
            padding: 0.4rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        .feedback.correct {
            background-color: var(--duo-correct-bg);
            color: var(--duo-correct-text);
            border: 1px solid var(--duo-correct-text);
        }
        .feedback.incorrect {
            background-color: var(--duo-incorrect-bg);
            color: var(--duo-incorrect-text);
            border: 1px solid var(--duo-incorrect-text);
        }
         .feedback.info {
            background-color: #e0f2fe;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .btn {
            padding: 0.65rem 1.1rem;
            border-radius: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.15s ease;
            cursor: pointer;
            border: none;
            border-bottom: 3px solid rgba(0,0,0,0.2);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 90px;
            font-size: 0.85rem;
            color: var(--duo-text-light);
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .btn:active:not(:disabled) {
            transform: translateY(0px);
            border-bottom-width: 1px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .btn-primary { background-color: var(--duo-green); border-bottom-color: var(--duo-green-dark); }
        .btn-primary:hover:not(:disabled) { background-color: var(--duo-green-light); }
        .btn-secondary { background-color: var(--duo-blue); border-bottom-color: var(--duo-blue-dark); }
        .btn-secondary:hover:not(:disabled) { background-color: #4acaff; }
        .btn-tertiary { background-color: var(--duo-orange); border-bottom-color: var(--duo-orange-dark); }
        .btn-tertiary:hover:not(:disabled) { background-color: #ffae40; }
        .btn-danger { background-color: var(--duo-red); border-bottom-color: var(--duo-red-dark); }
        .btn-danger:hover:not(:disabled) { background-color: #ff6a6a; }
        .btn-learned { background-color: var(--duo-yellow); border-bottom-color: #e6b400; color: var(--duo-text-dark); }
        .btn-learned:hover:not(:disabled) { background-color: #ffd433; }
        .btn-disabled, .btn:disabled {
            background-color: var(--duo-gray-light) !important;
            border-bottom-color: var(--duo-gray-medium) !important;
            color: var(--duo-gray-dark) !important;
            cursor: not-allowed !important;
            transform: none !important;
            box-shadow: 0 2px 3px rgba(0,0,0,0.05) !important;
        }
        .btn-disabled:hover, .btn:disabled:hover { background-color: var(--duo-gray-light) !important; }


        .option-btn {
            background-color: var(--duo-text-light);
            color: var(--duo-text-dark);
            border: 2px solid var(--duo-gray-light);
            padding: 0.75rem;
            text-align: left;
            text-transform: none;
            font-size: 0.95rem;
            font-weight: 600;
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .option-btn:hover:not(:disabled) {
            border-color: var(--duo-blue);
            background-color: #f0f8ff;
            transform: translateY(-1px);
        }
        .option-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            background-color: var(--duo-gray-lightest);
        }
        .option-btn.selected-correct {
            background-color: var(--duo-correct-bg) !important;
            color: var(--duo-correct-text) !important;
            border-color: var(--duo-correct-text) !important;
            font-weight: 700;
        }
        .option-btn.selected-incorrect {
            background-color: var(--duo-incorrect-bg) !important;
            color: var(--duo-incorrect-text) !important;
            border-color: var(--duo-incorrect-text) !important;
            font-weight: 700;
        }
        .option-btn.actual-correct {
            background-color: var(--duo-correct-bg) !important;
            color: var(--duo-correct-text) !important;
            border: 2px dashed var(--duo-correct-text) !important;
        }

        .stats-grid {
            display: grid;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .stat-item {
            background-color: var(--duo-gray-lightest);
            padding: 0.6rem;
            border-radius: 0.5rem;
            text-align: center;
            border: 1px solid var(--duo-gray-light);
        }
        .stat-item h3 {
            margin-top: 0;
            color: var(--duo-gray-dark);
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.1rem;
        }
        .stat-item p { font-size: 1.1rem; font-weight: 700; color: var(--duo-text-dark); }

        .tree-panel .stats-grid {
             grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
             margin-top: 1rem;
        }
        .tree-section-container { display: flex; flex-direction: column; flex-grow: 1; }
        .tree-display {
            margin: 0.5rem 0;
            min-height: 130px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s ease-in-out;
            flex-grow: 0.5;
        }
        .tree-display:hover { transform: scale(1.05); }
        .tree-gif { max-width: 100%; max-height: 180px; object-fit: contain; }
        #tree-level-text {
            font-size: 0.9rem;
            margin-top: 0.25rem;
            font-weight: 600;
            color: var(--duo-gray-dark);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 0.6rem;
            text-align: center;
            color: var(--duo-text-dark);
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.4rem;
        }
        .button-group .btn {
            font-size: 0.75rem;
            padding: 0.5rem 0.9rem;
        }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center; z-index: 1000;
            backdrop-filter: blur(3px);
            overflow-y: auto;
            padding: 1rem;
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            width: 90%; max-width: 450px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border-top: 5px solid var(--duo-green);
        }
        .modal-content.max-w-2xl { max-width: 672px; }

        .modal-content h3 {
            font-size: 1.3rem; font-weight: 700; margin-bottom: 1rem; color: var(--duo-text-dark);
            text-align: center;
        }
        .modal-content label {
            font-size: 0.9rem; color: var(--duo-gray-dark); margin-bottom: 0.25rem; display: block; font-weight: 600;
        }
        .modal-content .input-field { font-size: 0.9rem; margin-bottom: 1rem; }
        .modal-content .feedback { font-size: 0.8rem; min-height: 20px; }
        .modal-content .btn-sm {
            font-size: 0.85rem;
            padding: 0.6rem 1rem;
            text-transform: uppercase;
        }
        .modal-content .btn.bg-slate-300 {
            background-color: var(--duo-gray-light);
            color: var(--duo-gray-dark);
            border-bottom-color: var(--duo-gray-medium);
        }
        .modal-content .btn.bg-slate-300:hover {
            background-color: #d1d1d1;
        }
        #shop-decks-container {
            max-height: 150px;
            overflow-y: auto;
        }
        #import-progress-input { display: none; }

        .deck-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--duo-gray-light);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            background-color: var(--duo-gray-lightest);
        }
        .deck-list-item.active-deck-item {
            border-left: 4px solid var(--duo-green);
            background-color: #e8f5e9;
        }
        .deck-list-item .deck-name {
            font-weight: 600;
            color: var(--duo-text-dark);
            flex-grow: 1;
        }
        .deck-list-item .deck-actions .btn {
            padding: 0.3rem 0.6rem;
            font-size: 0.7rem;
            margin-left: 0.25rem;
        }

        @media (max-width: 1024px) {

            html, body {
                height: 100%;
                overflow: hidden;
            }

            .app-header h1 {
                display: none;
            }

        .app-wrapper {
            height: 100dvh;
            padding: 0.5rem;
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

            .main-content-area {
            flex-direction: column;
            flex-grow: 1;
            overflow-y: auto;
            scroll-snap-type: y mandatory;
            gap: 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding-bottom: env(safe-area-inset-bottom, 0px);
            box-sizing: border-box;
        }
        .main-content-area::-webkit-scrollbar {
            display: none;
        }

            .content-wrapper-main {
                order: 1;
                display: contents;
            }

            .study-panel, .tree-panel, .sidebar {
                scroll-snap-align: start;
                height: 100%;
                min-height: 100%;
                margin-bottom: 0 !important;
                overflow-y: auto;
                flex-shrink: 0;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .study-panel::-webkit-scrollbar,
            .tree-panel::-webkit-scrollbar,
            .sidebar::-webkit-scrollbar {
                display: none;
            }

            .sidebar {
                order: 2;
            }


            .scroll-arrow {
                display: none !important;
            }
            .app-header h1 { font-size: 1.5rem; }
        }

        @media (min-width: 1025px) {
            html, body {
                overflow-x: hidden;
                height: auto;
                overflow-y: auto;
            }
             .app-wrapper {
                min-height: 100vh;
                height: auto;
                padding: 0.75rem;
                overflow: visible;
            }
            .main-content-area {
                flex-direction: row;
                align-items: flex-start;
                gap: 1.5rem;
                overflow: visible;
                scroll-snap-type: none;
            }
            .sidebar {
                width: 380px;
                flex-shrink: 0;
                margin-bottom: 0;
                position: sticky;
                top: 1rem;
                align-self: flex-start;
                max-height: calc(100vh - 2rem);
                overflow-y: auto;
                height: auto;
                min-height: auto;
                scroll-snap-align: unset;
            }
            .content-wrapper-main {
                flex-grow: 1;
                flex-direction: row;
                gap: 1.5rem;
                display: flex;
            }
            .study-panel {
                flex-basis: 45%;
                flex-grow: 1;
                margin-bottom: 0;
                height: auto;
                min-height: auto;
                overflow-y: visible;
                scroll-snap-align: unset;
                flex-shrink: 1;
            }
            .tree-panel {
                flex-basis: 55%;
                flex-grow: 1;
                margin-bottom: 0;
                height: auto;
                min-height: auto;
                overflow-y: visible;
                scroll-snap-align: unset;
                flex-shrink: 1;
            }
            .scroll-arrow { display: none !important; }
        }
        .sidebar-section .button-group.grid-cols-2 {
            grid-template-columns: repeat(2, minmax(0, 1fr));
            display: grid;
        }

        @media (max-width: 500px) {
    /* --- Rediseño Modal "Mis Mazos" para pantallas <= 500px --- */

    /* 1. Contenido General del Modal */
    #decks-modal .modal-content {
        padding: 1rem; /* Reducir el padding interno del modal */
    }

    /* 2. Título del Modal y Párrafo de Mazo Activo */
    #decks-modal .modal-content #decksModalTitle {
        font-size: 1.125rem; /* text-lg, mantener si hay espacio, o reducir a 1rem */
        margin-bottom: 0.75rem; /* Ajustar espacio inferior */
    }

    #decks-modal .modal-content p.text-gray-600 { /* Párrafo "Mazo activo para estudiar" */
        font-size: 0.875rem; /* text-sm */
        line-height: 1.4;    /* Mejorar legibilidad si el texto se envuelve */
        margin-bottom: 1rem; /* Espacio antes de la lista de mazos */
    }

    /* 3. Botones Superiores ("Crear Nuevo Mazo", "Estudiar Mazo Principal") */
    #decks-modal .modal-content .my-4.flex { /* El div que contiene estos botones */
        flex-direction: column; /* Apilar botones verticalmente */
        /* Tailwind 'gap-2' (0.5rem) ya está aplicado, lo cual es bueno para el espacio vertical */
    }

    #decks-modal .modal-content .my-4.flex > .btn { /* Botones dentro del div */
        width: 100%; /* Hacer que los botones ocupen todo el ancho */
    }

    /* 4. Contenedor de la Lista de Mazos */
    #decks-modal .modal-content #decks-list-container {
        max-height: 200px;  /* Reducir altura máxima para evitar que el modal sea demasiado alto */
        padding: 0.25rem;   /* Reducir padding si los items internos ya tienen el suyo */
    }

    /* 5. Ítems Individuales en la Lista de Mazos (.deck-list-item) */
    #decks-modal .modal-content #decks-list-container .deck-list-item {
        flex-direction: column;   /* Apilar información del mazo y acciones verticalmente */
        align-items: stretch;     /* Hacer que los bloques hijos ocupen todo el ancho */
        gap: 0.5rem;              /* Espacio entre el bloque de info y el bloque de acciones */
        padding: 0.6rem;          /* Ajustar padding interno del ítem (originalmente p-3 vía JS) */
        margin-bottom: 0.375rem;  /* Reducir margen inferior entre ítems */
    }

    /* 5a. Bloque de Información del Mazo (Nombre y contador de palabras) */
    /* El div.flex-grow es el contenedor del nombre y el contador */
    #decks-modal .modal-content #decks-list-container .deck-list-item > div.flex-grow {
        /* Este div ocupará el ancho completo debido a align-items:stretch en .deck-list-item */
    }

    #decks-modal .modal-content #decks-list-container .deck-list-item .deck-name {
        font-size: 0.9rem;      /* Tamaño de fuente para el nombre del mazo */
        font-weight: 600;       /* Tailwind 'font-semibold' */
        word-break: break-word; /* Permitir que nombres largos se corten y pasen a la siguiente línea */
        display: block;         /* Hacer que el nombre ocupe su propia línea */
        margin-bottom: 0.125rem;/* Pequeño espacio antes del contador de palabras */
    }

    #decks-modal .modal-content #decks-list-container .deck-list-item span.text-xs.text-gray-500 { /* Contador de palabras */
        font-size: 0.75rem;     /* Tailwind 'text-xs' */
        display: block;         /* Hacer que el contador ocupe su propia línea */
        margin-left: 0;         /* Anular el 'ml-2' aplicado por JS para alinear a la izquierda */
    }

    /* 5b. Bloque de Acciones del Mazo (Botones: Estudiar, Editar, Eliminar) */
    #decks-modal .modal-content #decks-list-container .deck-list-item .deck-actions {
        width: 100%;            /* Ocupar todo el ancho */
        display: flex;
        flex-wrap: wrap;        /* Permitir que los botones pasen a la siguiente línea si no caben */
        gap: 0.375rem;          /* Espacio entre botones (6px). Tailwind 'gap-1.5' */
                                /* Esto reemplaza funcionalmente al 'space-x-1' que usa margin */
        justify-content: flex-start; /* Alinear botones al inicio */
    }

    /* Anular el 'space-x-1' (que añade margin-left) si interfiere con 'gap' */
    #decks-modal .modal-content #decks-list-container .deck-list-item .deck-actions > .btn + .btn {
        margin-left: 0;
    }

    #decks-modal .modal-content #decks-list-container .deck-list-item .deck-actions .btn {
        /* Los botones ya tienen !py-1 !px-2 !text-xs vía JS, lo que los hace pequeños */
        flex-grow: 1;         /* Permitir que los botones crezcan para llenar el espacio si son pocos */
        min-width: 75px;      /* Ancho mínimo para asegurar legibilidad y facilidad de toque */
        text-align: center;
    }

    /* 6. Botón de Cerrar Modal */
    #decks-modal .modal-content .flex.justify-end.mt-6 { /* El div contenedor del botón "Cerrar" */
        margin-top: 1rem; /* Reducir el margen superior */
    }
}

    </style>

     <script async src="https://www.googletagmanager.com/gtag/js?id=G-H1P5HZZZYT"></script>
    <script>
     window.dataLayer = window.dataLayer || [];
     function gtag(){dataLayer.push(arguments);}
     gtag('js', new Date());

     gtag('config', 'G-H1P5HZZZYT');
    </script>
</head>
<body>
    <main class="app-wrapper">
        <header class="app-header">
            <h1>Aprende Inglés Fácil con Flashcards Interactivas</h1>
        </header>

        <div class="main-content-area">
            <aside class="sidebar">
                <h2 class="column-title">Panel de Control</h2>

                <section class="sidebar-section" aria-label="Recursos y Tienda">
                    <h3 class="section-title text-[var(--duo-green)]">Recursos y Acciones</h3>
                    <div class="stats-grid sidebar-stats">
                        <div class="stat-item">
                            <h3>Puntos</h3>
                            <p id="score">0</p>
                        </div>
                        <div class="stat-item">
                            <h3>Fertilizante</h3>
                            <p id="fertilizer-count">0</p>
                        </div>
                        <div class="stat-item">
                            <h3>Manzanas</h3>
                            <p id="apples-count">0 🍎</p>
                        </div>
                    </div>
                    <div class="button-group mt-2 grid grid-cols-2 gap-2"> <button id="open-shop-btn" class="btn btn-tertiary w-full">Tienda</button>
                        <button id="open-decks-modal-btn" class="btn btn-secondary w-full">Mazos</button> </div>
                </section>


    <div class="p-4 bg-white shadow-md rounded-lg mx-auto max-w-md mt-4">
    <h3 class="text-lg font-semibold mb-2 text-gray-800">Generar Nuevo Mazo con IA</h3>
    <input type="text" id="deckTopicInput" placeholder="Tema del mazo (ej: 'animales', 'tecnología')"
           class="w-full p-2 border border-gray-300 rounded-md mb-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
    <input type="number" id="numCardsInput" value="10" min="1" max="50"
           class="w-full p-2 border border-gray-300 rounded-md mb-4 focus:outline-none focus:ring-2 focus:ring-blue-500">
    <button id="generateDeckButton"
            class="w-full bg-blue-600 text-white p-2 rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-opacity-50">
        Generar Mazo
    </button>
</div>
                </section>
            </aside>

            <div class="content-wrapper-main">
                <section class="study-panel">
                    <h2 class="column-title">Panel de Estudio</h2>
                    <div class="text-center mb-2">
                        <span class="text-sm font-semibold text-[var(--duo-gray-dark)]">Mazo Activo: </span>
                        <span id="active-deck-display-study-panel" class="text-sm font-bold text-[var(--duo-blue)]">Ninguno</span>
                    </div>
                    <section id="flashcard-section" aria-labelledby="flashcard-title">
                        <div class="flashcard">
                            <div class="question-container">
                                <p id="question-text"></p>
                                <button id="speaker-icon-button" class="hidden" title="Escuchar palabra">🔊</button>
                            </div>
                        </div>
                        <input type="text" id="answer-input" class="input-field mx-auto block hidden" placeholder="Escribe la traducción...">
                        <div id="multiple-choice-options" class="mt-3 space-y-2 w-full max-w-sm mx-auto"></div>
                        <div id="feedback-text" class="feedback text-center"></div>
                        <div class="flex justify-center space-x-2 mt-1.5 button-group">
                            <button id="check-answer-btn" class="btn btn-primary hidden">Revisar</button>
                            <button id="learned-btn" class="btn btn-learned hidden">¡Lo sé!</button>
                            <button id="next-card-btn" class="btn btn-secondary hidden">Siguiente</button>
                        </div>
                    </section>
                    <section class="sidebar-section" aria-label="Gestión de palabras">
                        <h3 class="section-title text-[var(--duo-blue)]">Gestionar Palabras (Mazo Activo)</h3>
                        <div class="button-group">
                             <button id="show-add-card-modal-btn" class="btn btn-primary ">Añadir</button>
                             <button id="show-delete-card-modal-btn" class="btn btn-danger">Eliminar</button>
                             <button id="show-review-learned-modal-btn" class="btn btn-secondary">Ver Aprendidas</button>
                        </div>
                    </section>
                </section>

                <section class="tree-panel">
                     <h2 class="column-title">Tu Árbol de Palabras</h2>
                     <section id="tree-section" class="text-center flex flex-col flex-grow tree-section-container" aria-label="Progreso del Árbol de Palabras">
                        <div id="tree-display" class="tree-display"></div>
                        <p id="tree-level-text">Nivel: Semilla</p>
                        <div class="mt-2 button-group">
                            <button id="use-fertilizer-btn" class="btn btn-secondary w-full sm:w-auto">Usar Fertilizante</button>
                        </div>
                        <div class="stats-grid tree-panel-stats mt-3" aria-label="Estadísticas de producción del árbol">
                            <div class="stat-item">
                                <h3>Producción</h3>
                                <p id="apples-per-day" class="text-xs sm:text-sm">0 / día</p>
                            </div>
                            <div class="stat-item">
                                <h3>Próximas 🍎</h3>
                                <p id="apple-countdown" class="text-xs sm:text-sm">--:--:--</p>
                            </div>
                        </div>
                    </section>
                </section>
            </div>
        </div>

        <button id="scroll-left-btn" class="scroll-arrow left hidden" aria-label="Desplazar a la izquierda">«</button>
        <button id="scroll-right-btn" class="scroll-arrow right hidden" aria-label="Desplazar a la derecha">»</button>
    </main>

    <div id="add-card-modal" class="modal hidden" role="dialog" aria-labelledby="addCardModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="addCardModalTitle">Nueva Palabra (al mazo activo)</h3>
            <label for="new-question">Palabra en Inglés:</label>
            <input type="text" id="new-question" class="input-field w-full" placeholder="Ej: Hello">
            <label for="new-answer">Traducción al Español:</label>
            <input type="text" id="new-answer" class="input-field w-full" placeholder="Ej: Hola">
            <div id="add-card-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="save-card-btn" class="btn btn-primary btn-sm">Guardar</button>
                <button id="cancel-add-card-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="delete-card-modal" class="modal hidden" role="dialog" aria-labelledby="deleteCardModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="deleteCardModalTitle">Eliminar Palabra (del mazo activo)</h3>
            <div class="flex justify-end mb-1">
                 <button id="select-all-delete-btn" class="btn btn-secondary btn-sm !py-1 !px-2 !text-xs hidden">Seleccionar Todas</button>
            </div>
            <div id="delete-card-list-container" class="my-2 max-h-48 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md">
                <p id="no-cards-to-delete-msg" class="text-[var(--duo-gray-dark)] text-sm hidden">No hay palabras para eliminar en el mazo activo.</p>
            </div>
            <div id="delete-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="confirm-delete-card-btn" class="btn btn-danger btn-sm">Eliminar</button>
                <button id="cancel-delete-card-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="review-learned-modal" class="modal hidden" role="dialog" aria-labelledby="reviewLearnedModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="reviewLearnedModalTitle">Palabras Aprendidas (Global)</h3>
            <div id="review-learned-list-container" class="my-2 max-h-52 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md">
                 <p id="no-learned-cards-msg" class="text-[var(--duo-gray-dark)] text-sm hidden">Aún no has marcado ninguna palabra como aprendida.</p>
            </div>
            <div id="review-modal-feedback" class="feedback text-center"></div>
            <div class="flex justify-end mt-3">
                <button id="close-review-learned-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="shop-modal" class="modal hidden" role="dialog" aria-labelledby="shopModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="shopModalTitle">Tienda del Árbol</h3>
            <div id="shop-feedback" class="feedback text-center"></div>
            <div class="space-y-2 my-3">
                <div class="p-2.5 border border-[var(--duo-gray-light)] rounded-lg bg-[var(--duo-gray-lightest)]">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="font-semibold text-sm text-[var(--duo-text-dark)]">Fertilizante</h4>
                            <p class="text-xs text-[var(--duo-gray-dark)]">Costo: <span id="fertilizer-shop-cost-display">10</span> Puntos ✨</p>
                        </div>
                        <button id="buy-fertilizer-shop-btn" class="btn btn-primary btn-sm">Comprar</button>
                    </div>
                </div>
                 <div class="p-2.5 border border-[var(--duo-gray-light)] rounded-lg bg-[var(--duo-gray-lightest)]">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="font-semibold text-sm text-[var(--duo-text-dark)]">1 Manzana 🍎</h4>
                            <p class="text-xs text-[var(--duo-gray-dark)]">Costo: <span id="apple-shop-cost-display">1000</span> Puntos</p>
                        </div>
                        <button id="buy-apple-shop-btn" class="btn btn-primary btn-sm">Comprar</button>
                    </div>
                </div>
                <h4 class="text-md font-semibold text-[var(--duo-text-dark)] pt-3 mt-3 border-t border-[var(--duo-gray-light)]">Mazos de Palabras (Tienda)</h4>
                <div id="shop-decks-container" class="space-y-2">
                    <p id="loading-decks-msg" class="text-sm text-center text-[var(--duo-gray-dark)]">Cargando mazos disponibles...</p>
                </div>
            </div>
            <div class="flex justify-end mt-3">
                <button id="close-shop-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar Tienda</button>
            </div>
        </div>
    </div>

    <div id="decks-modal" class="modal hidden" role="dialog" aria-labelledby="decksModalTitle" aria-modal="true">
        <div class="modal-content max-w-2xl"> <h3 id="decksModalTitle" class="text-lg font-bold">Mis Mazos</h3>

            <div class="my-4 flex flex-wrap gap-2">
                <button id="open-add-new-deck-modal-btn" class="btn btn-primary btn-sm">Crear Nuevo Mazo</button>
                <button id="select-main-deck-btn" class="btn btn-secondary btn-sm">Estudiar Mazo Principal (Todas)</button>
            </div>

            <p class="text-sm text-gray-600 mb-1">Mazo activo para estudiar:
                <strong id="active-deck-name-modal-display" class="text-[var(--duo-blue)]">Ninguno</strong>
            </p>

            <div id="decks-list-container" class="my-3 max-h-72 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md bg-white">
                <p id="no-user-decks-msg" class="text-[var(--duo-gray-dark)] text-sm p-2">No tienes mazos creados. ¡Crea uno para empezar!</p>
            </div>

            <div id="deck-management-feedback" class="feedback text-center mt-2"></div>

            <div class="flex justify-end space-x-2 mt-6">
                <button id="close-decks-modal-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="add-edit-deck-name-modal" class="modal hidden" role="dialog" aria-labelledby="addEditDeckNameModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="addEditDeckNameModalTitle">Crear Nuevo Mazo</h3>
            <label for="deck-name-input">Nombre del Mazo:</label>
            <input type="text" id="deck-name-input" class="input-field w-full" placeholder="Ej: Verbos Comunes">
            <input type="hidden" id="editing-deck-id-input">
            <div id="add-edit-deck-name-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="save-deck-name-btn" class="btn btn-primary btn-sm">Guardar</button>
                <button id="cancel-add-edit-deck-name-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>


    <audio id="correct-sound" src="sounds/correct-sound.mp3" preload="auto"></audio>
    <audio id="incorrect-sound" src="sounds/incorrect-sound.mp3" preload="auto"></audio>

    <script type="module">
        // --- Game State Variables ---
        import { generateFlashcardDeck } from './geminiApi.js';
        let userDecks = [];
        let activeDeckId = null;
        let currentStudyCards = [];
        let learnedFlashcards = [];
        let currentCardIndex = 0;
        let score = 0;
        let fertilizerCount = 0;
        let treeLevel = 0;
        let applesCount = 0;
        let applesPerDay = 0;
        let lastAppleGenerationTime = Date.now();
        let appleCountdownInterval = null;
        let shopDecksData = {};
        let pointsThisHour = 0;
        let lastPointResetTime = Date.now();

        // --- Game Constants ---
        const POINTS_PER_CORRECT_ANSWER = 10;
        const POINTS_FOR_LEARNED_WORD = 20;
        const DEFAULT_FLASHCARDS_DATA = [
            { question: "Hello", answer: "Hola" }, { question: "Goodbye", answer: "Adiós" },
            { question: "Thank you", answer: "Gracias" }, { question: "Please", answer: "Por favor" },
            { question: "Yes", answer: "Sí" }, { question: "No", answer: "No" },
            { question: "Friend", answer: "Amigo" }, { question: "Love", answer: "Amor" }
        ];
        const MAIN_DECK_ID = '__main_all_decks__';
        const CHECK_APPLES_INTERVAL = 60 * 1000;
        const FERTILIZER_SHOP_COST = 50;
        const APPLE_SHOP_COST = 500;
        const TREE_LEVEL_DATA = [
            { name: 'Semilla',         gifName: 'gif_1.gif', fertilizerToNext: 5,   applesPerDay: 0 },
            { name: 'Brote',           gifName: 'gif_2.gif', fertilizerToNext: 10,  applesPerDay: 0 },
            { name: 'Árbol Pequeño',   gifName: 'gif_3.gif', fertilizerToNext: 20,  applesPerDay: 1 },
            { name: 'Árbol Mediano',   gifName: 'gif_4.gif', fertilizerToNext: 40,  applesPerDay: 2 },
            { name: 'Árbol Mìstico',    gifName: 'gif_5.gif', fertilizerToNext: 80,  applesPerDay: 4 },
            { name: 'Árbol Divino',   gifName: 'gif_6.gif', fertilizerToNext: 160, applesPerDay: 8 }
        ];
        const MAX_TREE_LEVEL_INDEX = TREE_LEVEL_DATA.length - 1;
        const SHOP_DECK_DEFINITIONS = [
            { id: "basic_verbs_pack", fileName: "decks/deck_basic_verbs.json" },
            { id: "birds_pack", fileName: "decks/birds.json" },
            { id: "body_parts_pack", fileName: "decks/body.json" },
            { id: "basic_verbs_past_pack", fileName: "decks/deck_basic_verbs_past.json" },
            { id: "fruits_vegetables_pack", fileName: "decks/fruit.json" },
            { id: "land_animals_pack", fileName: "decks/land_animals.json" },
            { id: "marine_animals_pack", fileName: "decks/marine_animals.json" }
        ];
        const ENCRYPTION_KEY_STRING = "miClaveSuperSecreta1234567890!"; // 32 bytes for AES-256
        let cryptoKey;
        const MIN_CARDS_FOR_POINTS = 5;
        const MIN_CARDS_FOR_MULTIPLE_CHOICE = 3;
        const MAX_POINTS_PER_HOUR = 500;
        const ONE_HOUR_IN_MS = 60 * 60 * 1000;


        // --- DOM Elements ---
        const questionTextEl = document.getElementById('question-text');
        const answerInputEl = document.getElementById('answer-input');
        const multipleChoiceOptionsEl = document.getElementById('multiple-choice-options');
        const checkAnswerBtn = document.getElementById('check-answer-btn');
        const learnedBtn = document.getElementById('learned-btn');
        const nextCardBtn = document.getElementById('next-card-btn');
        const feedbackTextEl = document.getElementById('feedback-text');
        const scoreEl = document.getElementById('score');
        const fertilizerCountEl = document.getElementById('fertilizer-count');
        const applesCountEl = document.getElementById('apples-count');
        const treeDisplayEl = document.getElementById('tree-display');
        const treeLevelTextEl = document.getElementById('tree-level-text');
        const useFertilizerBtn = document.getElementById('use-fertilizer-btn');
        const applesPerDayEl = document.getElementById('apples-per-day');
        const appleCountdownEl = document.getElementById('apple-countdown');
        let speakerIconButtonEl = document.getElementById('speaker-icon-button');

        const showAddCardModalBtn = document.getElementById('show-add-card-modal-btn');
        const addCardModal = document.getElementById('add-card-modal');
        const newQuestionInput = document.getElementById('new-question');
        const newAnswerInput = document.getElementById('new-answer');
        const saveCardBtn = document.getElementById('save-card-btn');
        const cancelAddCardBtn = document.getElementById('cancel-add-card-btn');
        const addCardFeedbackEl = document.getElementById('add-card-feedback');

        const showDeleteCardModalBtn = document.getElementById('show-delete-card-modal-btn');
        const deleteCardModal = document.getElementById('delete-card-modal');
        const deleteCardListContainerEl = document.getElementById('delete-card-list-container');
        const noCardsToDeleteMsgEl = document.getElementById('no-cards-to-delete-msg');
        const confirmDeleteCardBtn = document.getElementById('confirm-delete-card-btn');
        const cancelDeleteCardBtn = document.getElementById('cancel-delete-card-btn');
        const deleteFeedbackEl = document.getElementById('delete-feedback');
        const selectAllDeleteBtn = document.getElementById('select-all-delete-btn');

        const showReviewLearnedModalBtn = document.getElementById('show-review-learned-modal-btn');
        const reviewLearnedModal = document.getElementById('review-learned-modal');
        const reviewLearnedListContainerEl = document.getElementById('review-learned-list-container');
        const noLearnedCardsMsgEl = document.getElementById('no-learned-cards-msg');
        const closeReviewLearnedBtn = document.getElementById('close-review-learned-btn');
        const reviewModalFeedbackEl = document.getElementById('review-modal-feedback');

        const openShopBtn = document.getElementById('open-shop-btn');
        const shopModal = document.getElementById('shop-modal');
        const closeShopBtn = document.getElementById('close-shop-btn');
        const buyFertilizerShopBtn = document.getElementById('buy-fertilizer-shop-btn');
        const buyAppleShopBtn = document.getElementById('buy-apple-shop-btn');
        const shopFeedbackEl = document.getElementById('shop-feedback');
        const fertilizerShopCostDisplayEl = document.getElementById('fertilizer-shop-cost-display');
        const appleShopCostDisplayEl = document.getElementById('apple-shop-cost-display');
        const shopDecksContainerEl = document.getElementById('shop-decks-container');
        const loadingDecksMsgEl = document.getElementById('loading-decks-msg');

        const exportProgressBtn = document.getElementById('export-progress-btn');
        const importProgressBtn = document.getElementById('import-progress-btn');
        const importProgressInput = document.getElementById('import-progress-input');
        const importExportFeedbackEl = document.getElementById('import-export-feedback');
        const downloadWordsBtn = document.getElementById('download-words-btn');

        const openDecksModalBtn = document.getElementById('open-decks-modal-btn');
        const decksModal = document.getElementById('decks-modal');
        const closeDecksModalBtn = document.getElementById('close-decks-modal-btn');
        const openAddNewDeckModalBtn = document.getElementById('open-add-new-deck-modal-btn');
        const selectMainDeckBtn = document.getElementById('select-main-deck-btn');
        const decksListContainerEl = document.getElementById('decks-list-container');
        const noUserDecksMsgEl = document.getElementById('no-user-decks-msg');
        const deckManagementFeedbackEl = document.getElementById('deck-management-feedback');
        const activeDeckNameModalDisplayEl = document.getElementById('active-deck-name-modal-display');

        const addEditDeckNameModal = document.getElementById('add-edit-deck-name-modal');
        const addEditDeckNameModalTitleEl = document.getElementById('addEditDeckNameModalTitle');
        const deckNameInputEl = document.getElementById('deck-name-input');
        const editingDeckIdInputEl = document.getElementById('editing-deck-id-input');
        const saveDeckNameBtn = document.getElementById('save-deck-name-btn');
        const cancelAddEditDeckNameBtn = document.getElementById('cancel-add-edit-deck-name-btn');
        const addEditDeckNameFeedbackEl = document.getElementById('add-edit-deck-name-feedback');

        const activeDeckDisplayStudyPanelEl = document.getElementById('active-deck-display-study-panel');

        const correctSound = document.getElementById('correct-sound');
        const incorrectSound = document.getElementById('incorrect-sound');

        // --- Utility Functions ---
        function generateUUID() { return crypto.randomUUID(); }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function openModal(modalElement) { modalElement.classList.remove('hidden'); }
        function closeModal(modalElement) { modalElement.classList.add('hidden'); }

        function clearFeedback(element) {
            const baseClass = element.className.split(' ').filter(cls => cls === 'feedback' || cls === 'text-center' || cls.startsWith('mt-') || cls.startsWith('mb-')).join(' ');
            element.textContent = '';
            element.className = baseClass;
        }

        function showTemporaryFeedback(element, message, type = 'info', duration = 3000) {
            clearFeedback(element);
            element.textContent = message;
            element.classList.add(type);

            if (duration > 0) {
                setTimeout(() => {
                    if (element.textContent === message) {
                        clearFeedback(element);
                        if (element === feedbackTextEl) updateDefaultFeedbackMessage();
                    }
                }, duration);
            }
        }

        // --- Speech Synthesis Function ---
        let synth = window.speechSynthesis;
        let voices = [];

        function populateVoices() {
            if (!synth) return;
            voices = synth.getVoices();
        }

        if (synth) {
            populateVoices();
            if (synth.onvoiceschanged !== undefined) {
                synth.onvoiceschanged = populateVoices;
            }
        }

        function speakWord(text) {
            if (!synth) {
                console.warn("Speech synthesis not supported.");
                if (speakerIconButtonEl) {
                    speakerIconButtonEl.disabled = true;
                    speakerIconButtonEl.classList.add('hidden');
                }
                return;
            }
            if (!text) {
                console.warn("No text to speak.");
                return;
            }

            if (voices.length === 0) {
                populateVoices();
            }

            try {
                synth.cancel();
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';

                const englishVoice = voices.find(voice => voice.lang === 'en-US' && voice.localService) ||
                                     voices.find(voice => voice.lang.startsWith('en-') && voice.localService) ||
                                     voices.find(voice => voice.lang === 'en-US') ||
                                     voices.find(voice => voice.lang.startsWith('en-'));

                if (englishVoice) {
                    utterance.voice = englishVoice;
                }

                utterance.onstart = () => {
                    if (speakerIconButtonEl) speakerIconButtonEl.disabled = true;
                };
                utterance.onend = () => {
                    if (speakerIconButtonEl && currentStudyCards.length > 0) {
                         speakerIconButtonEl.disabled = false;
                    }
                };
                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror triggered:', event);
                    showTemporaryFeedback(feedbackTextEl, `Error de audio: ${event.error || 'desconocido'}.`, "incorrect", 4000);
                    if (speakerIconButtonEl) speakerIconButtonEl.disabled = true;
                };
                synth.speak(utterance);
            } catch (e) {
                console.error("Error in speakWord function:", e);
                showTemporaryFeedback(feedbackTextEl, "Error interno en la función de audio.", "incorrect", 3000);
                if (speakerIconButtonEl) speakerIconButtonEl.disabled = true;
            }
        }


        // --- Crypto Functions ---
        async function initCryptoKey() {
            try {
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw", new TextEncoder().encode(ENCRYPTION_KEY_STRING.slice(0, 32)), // Ensure key is 32 bytes for AES-256
                    { name: "PBKDF2" }, false, ["deriveKey"]
                );
                const salt = new TextEncoder().encode("someFixedSaltValueForDecksApp"); // Salt should ideally be unique per user or random
                cryptoKey = await window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: salt, iterations: 100000, hash: "SHA-256" },
                    keyMaterial, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
                );
            } catch (error) {
                console.error("Error al inicializar CryptoKey:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error de criptografía al iniciar.", "incorrect", 5000);
                [exportProgressBtn, importProgressBtn].forEach(btn => {
                    btn.disabled = true; btn.classList.add('btn-disabled');
                });
            }
        }

        async function encryptData(plaintext) {
            if (!cryptoKey) {
                showTemporaryFeedback(importExportFeedbackEl, "Error: Clave de encriptación no lista.", "incorrect", 3000); return null;
            }
            try {
                const iv = window.crypto.getRandomValues(new Uint8Array(12)); // IV for AES-GCM is typically 12 bytes
                const encodedText = new TextEncoder().encode(plaintext);
                const ciphertext = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, cryptoKey, encodedText);
                // Convert IV and ciphertext to base64 for easy storage/transfer
                const ivBase64 = btoa(String.fromCharCode.apply(null, iv));
                const ciphertextBase64 = btoa(String.fromCharCode.apply(null, new Uint8Array(ciphertext)));
                return { iv: ivBase64, ciphertext: ciphertextBase64 };
            } catch (error) {
                console.error("Error encriptando:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error al encriptar datos.", "incorrect", 3000); return null;
            }
        }

        async function decryptData(ciphertextBase64, ivBase64) {
            if (!cryptoKey) {
                showTemporaryFeedback(importExportFeedbackEl, "Error: Clave de decriptación no lista.", "incorrect", 3000); return null;
            }
            try {
                const iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));
                const ciphertext = Uint8Array.from(atob(ciphertextBase64), c => c.charCodeAt(0)).buffer;
                const decryptedBuffer = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, cryptoKey, ciphertext);
                return new TextDecoder().decode(decryptedBuffer);
            } catch (error) {
                console.error("Error desencriptando:", error);
                // Provide more specific feedback if possible, but avoid leaking too much crypto detail
                showTemporaryFeedback(importExportFeedbackEl, "Error al desencriptar. ¿Archivo o clave incorrectos?", "incorrect", 4000); return null;
            }
        }

        // --- Data Persistence ---
        function saveGameData() {
            const gameData = {
                userDecks, activeDeckId, learnedFlashcards,
                score, fertilizerCount, treeLevel, applesCount,
                lastAppleGenerationTime, pointsThisHour, lastPointResetTime
            };
            localStorage.setItem('flashcardGameDataWithDecks', JSON.stringify(gameData));
        }

        function loadGameData() {
            const savedData = localStorage.getItem('flashcardGameDataWithDecks');
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    userDecks = parsedData.userDecks || [];
                    activeDeckId = parsedData.activeDeckId || null;
                    learnedFlashcards = parsedData.learnedFlashcards || [];
                    score = parsedData.score || 0;
                    fertilizerCount = parsedData.fertilizerCount || 0;
                    treeLevel = parsedData.treeLevel || 0;
                    applesCount = parsedData.applesCount || 0;
                    lastAppleGenerationTime = parsedData.lastAppleGenerationTime || Date.now();
                    pointsThisHour = parsedData.pointsThisHour || 0;
                    lastPointResetTime = parsedData.lastPointResetTime || Date.now();

                    // Data integrity checks
                    userDecks.forEach(deck => {
                        if (!Array.isArray(deck.cards)) deck.cards = [];
                        deck.cards = deck.cards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string' && c.question.trim() !== "" && c.answer.trim() !== "");
                    });
                    learnedFlashcards = learnedFlashcards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string' && c.question.trim() !== "" && c.answer.trim() !== "");


                    if (userDecks.length === 0) {
                        const defaultDeck = {
                            id: generateUUID(),
                            name: "Primer Mazo",
                            cards: DEFAULT_FLASHCARDS_DATA.map(c => ({...c}))
                        };
                        userDecks.push(defaultDeck);
                        activeDeckId = defaultDeck.id;
                    } else if (!activeDeckId || !userDecks.find(d => d.id === activeDeckId) && activeDeckId !== MAIN_DECK_ID) {
                        activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                    }
                } catch (e) {
                    console.error("Error parseando datos guardados (con mazos), reseteando a default:", e);
                    resetToDeckDefaults();
                }
            } else {
                resetToDeckDefaults();
            }
            checkHourlyPointLimit();
            updateCurrentStudyCards();
        }

        function resetToDeckDefaults() {
            const defaultDeck = {
                id: generateUUID(),
                name: "Primer Mazo",
                cards: DEFAULT_FLASHCARDS_DATA.map(c => ({...c}))
            };
            userDecks = [defaultDeck];
            activeDeckId = defaultDeck.id;
            learnedFlashcards = [];
            currentStudyCards = defaultDeck.cards.slice();
            currentCardIndex = 0;
            score = 0;
            fertilizerCount = 0;
            treeLevel = 0;
            applesCount = 0;
            lastAppleGenerationTime = Date.now();
            pointsThisHour = 0;
            lastPointResetTime = Date.now();
        }

        // --- Deck Management Logic ---
        function updateCurrentStudyCards() {
            currentStudyCards = [];
            if (activeDeckId === MAIN_DECK_ID) {
                userDecks.forEach(deck => {
                    deck.cards.forEach(card => {
                        currentStudyCards.push({ ...card, originalDeckId: deck.id }); // Keep track of original deck for "learn"
                    });
                });
                if (currentStudyCards.length > 1) shuffleArray(currentStudyCards);
            } else {
                const deck = userDecks.find(d => d.id === activeDeckId);
                if (deck) {
                    currentStudyCards = deck.cards.slice(); // Work with a copy
                    if (currentStudyCards.length > 1) shuffleArray(currentStudyCards);
                }
            }
            currentCardIndex = 0; // Reset index when cards change
            updateActiveDeckDisplay();
            updateStudyPanelWordManagementButtons();
        }

        function getActiveDeckName() {
            if (activeDeckId === MAIN_DECK_ID) return "Mazo Principal (Todas)";
            const deck = userDecks.find(d => d.id === activeDeckId);
            return deck ? deck.name : "Ninguno Seleccionado";
        }

        function updateActiveDeckDisplay() {
            const name = getActiveDeckName();
            activeDeckDisplayStudyPanelEl.textContent = name;
            activeDeckNameModalDisplayEl.textContent = name;
        }

        function populateDecksListInModal() {
            decksListContainerEl.innerHTML = '';
            if (userDecks.length === 0) {
                noUserDecksMsgEl.classList.remove('hidden');
                return;
            }
            noUserDecksMsgEl.classList.add('hidden');

            userDecks.forEach(deck => {
                const item = document.createElement('div');
                item.className = 'deck-list-item p-3 border rounded-lg mb-2 flex justify-between items-center hover:bg-gray-50 transition-colors';
                if (deck.id === activeDeckId) {
                    item.classList.add('active-deck-item', 'border-green-500', 'bg-green-50');
                }

                item.innerHTML = `
                    <div class="flex-grow">
                        <span class="deck-name font-semibold text-gray-700">${deck.name}</span>
                        <span class="text-xs text-gray-500 ml-2">(${deck.cards.length} palabras)</span>
                    </div>
                    <div class="deck-actions space-x-1">
                        <button class="btn btn-secondary btn-sm select-deck-btn !py-1 !px-2 !text-xs" data-deck-id="${deck.id}">Estudiar</button>
                        <button class="btn btn-tertiary btn-sm edit-deck-name-btn !py-1 !px-2 !text-xs" data-deck-id="${deck.id}" data-deck-name="${deck.name}">Editar Nombre</button>
                        <button class="btn btn-danger btn-sm delete-deck-btn !py-1 !px-2 !text-xs" data-deck-id="${deck.id}">Eliminar</button>
                    </div>
                `;
                decksListContainerEl.appendChild(item);
            });

            decksListContainerEl.querySelectorAll('.select-deck-btn').forEach(btn =>
                btn.addEventListener('click', (e) => handleSelectDeckForStudy(e.target.dataset.deckId))
            );
            decksListContainerEl.querySelectorAll('.edit-deck-name-btn').forEach(btn =>
                btn.addEventListener('click', (e) => handleOpenEditDeckNameModal(e.target.dataset.deckId, e.target.dataset.deckName))
            );
            decksListContainerEl.querySelectorAll('.delete-deck-btn').forEach(btn =>
                btn.addEventListener('click', (e) => handleDeleteDeck(e.target.dataset.deckId))
            );
        }

        function handleOpenAddNewDeckModal() {
            editingDeckIdInputEl.value = ''; // Clear editing ID
            deckNameInputEl.value = '';
            addEditDeckNameModalTitleEl.textContent = 'Crear Nuevo Mazo';
            clearFeedback(addEditDeckNameFeedbackEl);
            openModal(addEditDeckNameModal);
            deckNameInputEl.focus();
        }

        function handleOpenEditDeckNameModal(deckId, currentName) {
            editingDeckIdInputEl.value = deckId;
            deckNameInputEl.value = currentName;
            addEditDeckNameModalTitleEl.textContent = 'Editar Nombre del Mazo';
            clearFeedback(addEditDeckNameFeedbackEl);
            openModal(addEditDeckNameModal);
            deckNameInputEl.focus();
        }

        function handleSaveDeckName() {
            const deckName = deckNameInputEl.value.trim();
            const editingDeckId = editingDeckIdInputEl.value;

            if (!deckName) {
                showTemporaryFeedback(addEditDeckNameFeedbackEl, "El nombre del mazo no puede estar vacío.", "incorrect");
                return;
            }

            if (editingDeckId) { // Editing existing deck
                const deck = userDecks.find(d => d.id === editingDeckId);
                if (deck) {
                    deck.name = deckName;
                    showTemporaryFeedback(deckManagementFeedbackEl, `Nombre del mazo actualizado a "${deckName}".`, "correct", 2000);
                }
            } else { // Creating new deck
                const newDeck = { id: generateUUID(), name: deckName, cards: [] };
                userDecks.push(newDeck);
                showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${deckName}" creado.`, "correct", 2000);
            }
            saveGameData();
            populateDecksListInModal();
            updateActiveDeckDisplay(); // If the active deck was renamed
            closeModal(addEditDeckNameModal);
        }

        function handleDeleteDeck(deckIdToDelete) {
            const deck = userDecks.find(d => d.id === deckIdToDelete);
            if (!deck) return;

            // Using a custom modal for confirmation would be better than window.confirm
            // For now, let's assume window.confirm is acceptable for this context
            if (!confirm(`¿Estás seguro de que quieres eliminar el mazo "${deck.name}" y todas sus ${deck.cards.length} palabras? Esta acción no se puede deshacer.`)) {
                return;
            }

            userDecks = userDecks.filter(d => d.id !== deckIdToDelete);

            // If the active deck was deleted, switch to main or first available
            if (activeDeckId === deckIdToDelete) {
                activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                updateCurrentStudyCards();
                displayCard(); // Refresh study panel
            }

            saveGameData();
            populateDecksListInModal(); // Refresh modal list
            updateActiveDeckDisplay(); // Refresh display of active deck name
            showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${deck.name}" eliminado.`, "correct", 2500);
        }

        function handleSelectDeckForStudy(deckId) {
            activeDeckId = deckId;
            updateCurrentStudyCards();
            displayCard(); // Refresh study panel
            saveGameData();
            populateDecksListInModal(); // To highlight the new active deck
            updateActiveDeckDisplay();
            showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${getActiveDeckName()}" seleccionado para estudiar.`, "info", 2000);
            closeModal(decksModal); // Close the decks management modal
        }

        function handleSelectMainDeckForStudy() {
            activeDeckId = MAIN_DECK_ID;
            updateCurrentStudyCards();
            displayCard();
            saveGameData();
            populateDecksListInModal();
            updateActiveDeckDisplay();
            showTemporaryFeedback(deckManagementFeedbackEl, `Mazo Principal seleccionado para estudiar.`, "info", 2000);
            closeModal(decksModal);
        }

        // --- Import/Export Progress ---
        async function exportProgress() {
            clearFeedback(importExportFeedbackEl);
            const gameData = {
                userDecks, activeDeckId, learnedFlashcards,
                score, fertilizerCount, treeLevel, applesCount,
                lastAppleGenerationTime,
                pointsThisHour, lastPointResetTime // Ensure all relevant data is included
            };
            const jsonData = JSON.stringify(gameData);
            const encryptedPayload = await encryptData(jsonData);

            if (!encryptedPayload) {
                showTemporaryFeedback(importExportFeedbackEl, "Fallo la encriptación. No se pudo exportar.", "incorrect", 3000);
                return;
            }

            const dataToExport = JSON.stringify(encryptedPayload); // This contains {iv, ciphertext}
            const blob = new Blob([dataToExport], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "flashcards_progress_encrypted_v2.json"; // Versioning in filename is good
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showTemporaryFeedback(importExportFeedbackEl, "Progreso exportado y encriptado.", "correct", 3000);
        }

        async function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) {
                showTemporaryFeedback(importExportFeedbackEl, "No se seleccionó archivo.", "info", 3000);
                return;
            }
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const fileContent = e.target.result;
                    const encryptedPayload = JSON.parse(fileContent); // This should be {iv, ciphertext}

                    if (!encryptedPayload.iv || !encryptedPayload.ciphertext) {
                        throw new Error("Formato de archivo encriptado inválido. Faltan IV o Ciphertext.");
                    }

                    const decryptedJson = await decryptData(encryptedPayload.ciphertext, encryptedPayload.iv);
                    if (!decryptedJson) {
                        // decryptData already shows feedback, so just return
                        return;
                    }

                    const importedData = JSON.parse(decryptedJson); // This is the actual game data object

                    // Validate basic structure of importedData
                    if (typeof importedData.score === 'undefined' || typeof importedData.userDecks === 'undefined') {
                         // Attempt to handle very old format if 'flashcards' array exists directly
                        if (Array.isArray(importedData.flashcards)) {
                            console.warn("Importando datos de formato antiguo (solo flashcards).");
                            userDecks = [{ id: generateUUID(), name: "Mazo Importado (Antiguo)", cards: importedData.flashcards || [] }];
                            activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                            learnedFlashcards = importedData.learnedFlashcards || [];
                            // Reset other stats for old format as they weren't saved
                            score = 0; fertilizerCount = 0; treeLevel = 0; applesCount = 0;
                            lastAppleGenerationTime = Date.now(); pointsThisHour = 0; lastPointResetTime = Date.now();
                        } else {
                            throw new Error("Datos importados inválidos o corruptos. Estructura no reconocida.");
                        }
                    } else {
                        // Modern format, assign with fallbacks
                        userDecks = importedData.userDecks || [];
                        activeDeckId = importedData.activeDeckId || (userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID);
                        learnedFlashcards = importedData.learnedFlashcards || [];
                        score = importedData.score || 0;
                        fertilizerCount = importedData.fertilizerCount || 0;
                        treeLevel = importedData.treeLevel || 0;
                        applesCount = importedData.applesCount || 0;
                        lastAppleGenerationTime = importedData.lastAppleGenerationTime || Date.now();
                        pointsThisHour = importedData.pointsThisHour || 0;
                        // --- CORRECTION IS HERE ---
                        lastPointResetTime = importedData.lastPointResetTime || Date.now(); // Was parsedData, now importedData
                    }

                    // Further sanitize imported data
                    userDecks.forEach(deck => {
                        if (!deck.id) deck.id = generateUUID();
                        if (!deck.name) deck.name = "Mazo Importado";
                        if (!Array.isArray(deck.cards)) deck.cards = [];
                        deck.cards = deck.cards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string' && c.question.trim() !== "" && c.answer.trim() !== "");
                    });
                    learnedFlashcards = learnedFlashcards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string' && c.question.trim() !== "" && c.answer.trim() !== "");

                    // Ensure activeDeckId is valid
                    if (!userDecks.find(d => d.id === activeDeckId) && activeDeckId !== MAIN_DECK_ID) {
                        activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                    }


                    saveGameData(); // Save the newly imported and validated data
                    initGameVisuals(); // Refresh the entire game UI
                    showTemporaryFeedback(importExportFeedbackEl, "Progreso importado exitosamente.", "correct", 4000);
                } catch (error) {
                    console.error("Error importando progreso:", error);
                    showTemporaryFeedback(importExportFeedbackEl, `Error al importar: ${error.message}`, "incorrect", 5000);
                } finally {
                    importProgressInput.value = ""; // Reset file input
                }
            };
            reader.onerror = () => {
                showTemporaryFeedback(importExportFeedbackEl, "Error al leer el archivo.", "incorrect", 3000);
                importProgressInput.value = ""; // Reset file input
            };
            reader.readAsText(file);
        }

        // --- Study Panel Logic (Flashcards) ---
        function displayCard() {
            clearFeedback(feedbackTextEl);
            if (currentStudyCards.length === 0) {
                handleNoCardsInActiveDeckState();
                return;
            }
            if (currentCardIndex >= currentStudyCards.length || currentCardIndex < 0) {
                currentCardIndex = 0; // Safety reset
            }
            const currentCard = currentStudyCards[currentCardIndex];
            const englishWord = currentCard.question;
            questionTextEl.textContent = englishWord;
            answerInputEl.value = "";
            answerInputEl.classList.add('hidden'); // Hide by default, only show for text input mode (not used currently)
            checkAnswerBtn.classList.add('hidden'); // Hide by default

            generateAndDisplayOptions(); // For multiple choice

            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.add('hidden');

            if (speakerIconButtonEl) {
                if (englishWord && synth) {
                    speakerIconButtonEl.classList.remove('hidden');
                    speakerIconButtonEl.disabled = false;

                    // Re-attach listener or clone to ensure fresh closure for `englishWord`
                    const newSpeakerButton = speakerIconButtonEl.cloneNode(true);
                    speakerIconButtonEl.parentNode.replaceChild(newSpeakerButton, speakerIconButtonEl);
                    speakerIconButtonEl = newSpeakerButton; // Update global reference

                    speakerIconButtonEl.classList.remove('hidden');
                    speakerIconButtonEl.disabled = false;
                    speakerIconButtonEl.addEventListener('click', () => speakWord(englishWord));

                    speakWord(englishWord); // Auto-speak on new card
                } else {
                    speakerIconButtonEl.classList.add('hidden');
                    speakerIconButtonEl.disabled = true;
                }
            }
            updateDefaultFeedbackMessage();
        }

        function updateDefaultFeedbackMessage() {
            if (currentStudyCards.length === 0) {
                return; // No cards, no specific message needed here, handled by handleNoCardsInActiveDeckState
            }
            const activeDeckIsSpecific = activeDeckId && activeDeckId !== MAIN_DECK_ID;
            const currentDeckCardCount = activeDeckIsSpecific ? (userDecks.find(d=>d.id === activeDeckId)?.cards.length || 0) : currentStudyCards.length;

            if (activeDeckIsSpecific && currentDeckCardCount < MIN_CARDS_FOR_POINTS) {
                showTemporaryFeedback(feedbackTextEl, `El mazo activo "${getActiveDeckName()}" tiene ${currentDeckCardCount} palabras. Necesitas al menos ${MIN_CARDS_FOR_POINTS} para ganar puntos.`, "info", 0);
            } else if (activeDeckIsSpecific && currentDeckCardCount < MIN_CARDS_FOR_MULTIPLE_CHOICE) {
                 showTemporaryFeedback(feedbackTextEl, `El mazo activo "${getActiveDeckName()}" tiene ${currentDeckCardCount} palabras. Añade más para tener ${MIN_CARDS_FOR_MULTIPLE_CHOICE} opciones de respuesta.`, "info", 0);
            } else {
                // If no specific info message, ensure feedback is clear for interaction
                if (!feedbackTextEl.textContent || feedbackTextEl.classList.contains('correct') || feedbackTextEl.classList.contains('incorrect')) {
                    // Only clear if it's not already an info message from above or a result message
                }
            }
        }


        function handleNoCardsInActiveDeckState() {
            questionTextEl.textContent = `¡No hay palabras en "${getActiveDeckName()}"!`;
            if (activeDeckId !== MAIN_DECK_ID) {
                questionTextEl.textContent += " Añade algunas o selecciona otro mazo.";
            } else {
                 questionTextEl.textContent = "¡No hay palabras en ningún mazo! Crea mazos y añade palabras.";
            }
            multipleChoiceOptionsEl.innerHTML = '';
            answerInputEl.classList.add('hidden');
            checkAnswerBtn.classList.add('hidden');
            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.add('hidden');
            if(speakerIconButtonEl) speakerIconButtonEl.classList.add('hidden');
            showTemporaryFeedback(feedbackTextEl, `Usa 'Añadir Palabra' (si un mazo específico está activo) o gestiona tus mazos.`, "info", 0); // Persistent info
        }

        function generateAndDisplayOptions() {
            multipleChoiceOptionsEl.innerHTML = '';
            if (currentStudyCards.length === 0 || currentCardIndex >= currentStudyCards.length) return;

            const correctAnswer = currentStudyCards[currentCardIndex].answer;
            let options = [correctAnswer];

            // Pool of potential distractors from ALL decks
            let distractorPool = [];
            userDecks.forEach(deck => {
                deck.cards.forEach(card => {
                    if (card.answer.toLowerCase() !== correctAnswer.toLowerCase()) {
                        distractorPool.push(card.answer);
                    }
                });
            });
            // Also include learned words as potential distractors if not too many
            learnedFlashcards.forEach(card => {
                 if (card.answer.toLowerCase() !== correctAnswer.toLowerCase()) {
                        distractorPool.push(card.answer);
                    }
            });


            distractorPool = [...new Set(distractorPool)]; // Remove duplicates
            shuffleArray(distractorPool);

            // Add up to (MIN_CARDS_FOR_MULTIPLE_CHOICE - 1) distractors
            for (let i = 0; i < Math.min(MIN_CARDS_FOR_MULTIPLE_CHOICE - 1, distractorPool.length); i++) {
                options.push(distractorPool[i]);
            }

            // If not enough options, fill with generic placeholders or repeat logic (less ideal)
            // For simplicity, if options < MIN_CARDS_FOR_MULTIPLE_CHOICE, it will just show fewer.
            // This is handled by updateDefaultFeedbackMessage informing user to add more cards.

            shuffleArray(options);
            options.forEach(optionText => {
                const button = document.createElement('button');
                button.classList.add('btn', 'option-btn');
                button.textContent = optionText;
                button.dataset.answer = optionText; // Store the answer this button represents
                button.addEventListener('click', handleOptionClick);
                multipleChoiceOptionsEl.appendChild(button);
            });
        }

        function handleOptionClick(event) {
            const clickedButton = event.target;
            const selectedAnswer = clickedButton.dataset.answer;
            const cardBeingStudied = currentStudyCards[currentCardIndex];
            const correctAnswer = cardBeingStudied.answer;

            const optionButtons = multipleChoiceOptionsEl.querySelectorAll('.option-btn');
            optionButtons.forEach(btn => btn.disabled = true); // Disable all options
            nextCardBtn.classList.remove('hidden');

            if (selectedAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                clickedButton.classList.add('selected-correct');
                checkHourlyPointLimit(); // Check before awarding points

                const activeDeckIsSpecific = activeDeckId && activeDeckId !== MAIN_DECK_ID;
                const currentDeckForPointsCheck = activeDeckIsSpecific ? userDecks.find(d=>d.id === activeDeckId) : null;
                // Points can be earned if main deck is active OR specific deck has enough cards
                const canEarnPoints = (activeDeckId === MAIN_DECK_ID && currentStudyCards.length >= MIN_CARDS_FOR_POINTS) ||
                                      (activeDeckIsSpecific && currentDeckForPointsCheck && currentDeckForPointsCheck.cards.length >= MIN_CARDS_FOR_POINTS);

                if (!canEarnPoints) {
                    showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 Pero el mazo activo necesita al menos ${MIN_CARDS_FOR_POINTS} palabras para ganar puntos.`, "info", 4000);
                } else if (pointsThisHour >= MAX_POINTS_PER_HOUR) {
                    showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 Has alcanzado el límite de ${MAX_POINTS_PER_HOUR} puntos esta hora. Intenta más tarde.`, "info", 4000);
                } else {
                    const pointsToAdd = POINTS_PER_CORRECT_ANSWER;
                    let actualPointsAdded = pointsToAdd;
                    if (pointsThisHour + pointsToAdd > MAX_POINTS_PER_HOUR) {
                        actualPointsAdded = MAX_POINTS_PER_HOUR - pointsThisHour;
                        showTemporaryFeedback(feedbackTextEl, `¡Correcto! � +${actualPointsAdded} puntos. (Límite horario alcanzado)`, "correct", 3000);
                    } else {
                        showTemporaryFeedback(feedbackTextEl, "¡Correcto! 🎉", "correct", 2000);
                    }
                    score += actualPointsAdded;
                    pointsThisHour += actualPointsAdded;
                    updateScoreDisplay();
                }
                learnedBtn.classList.remove('hidden'); // Show "I know it!" button
                if (correctSound) { correctSound.currentTime = 0; correctSound.play().catch(console.error); }
            } else {
                clickedButton.classList.add('selected-incorrect');
                // Highlight the actual correct answer
                optionButtons.forEach(btn => {
                    if (btn.dataset.answer.toLowerCase() === correctAnswer.toLowerCase()) {
                        btn.classList.add('actual-correct');
                    }
                });
                const pointsToDeduct = Math.floor(POINTS_PER_CORRECT_ANSWER / 2); // Penalty
                score -= pointsToDeduct;
                if (score < 0) score = 0;
                updateScoreDisplay();
                showTemporaryFeedback(feedbackTextEl, `Incorrecto. Respuesta correcta: ${correctAnswer}. Has perdido ${pointsToDeduct} puntos. 📉`, "incorrect", 3500);
                learnedBtn.classList.add('hidden'); // Don't show "I know it!" on incorrect
                if (incorrectSound) { incorrectSound.currentTime = 0; incorrectSound.play().catch(console.error); }
            }
            nextCardBtn.focus();
            saveGameData();
        }

        function markAsLearned() {
            if (currentStudyCards.length === 0 || currentCardIndex >= currentStudyCards.length) return;

            const cardToLearn = { ...currentStudyCards[currentCardIndex] }; // Get a copy
            let feedbackMessage = "";

            // Check if already learned (by question, case-insensitive)
            if (learnedFlashcards.findIndex(card => card.question.toLowerCase() === cardToLearn.question.toLowerCase()) === -1) {
                // Add to learned list
                learnedFlashcards.push({ question: cardToLearn.question, answer: cardToLearn.answer });

                // Remove from its original deck
                let originalDeckIdToRemoveFrom = null;
                if (activeDeckId === MAIN_DECK_ID && cardToLearn.originalDeckId) {
                    originalDeckIdToRemoveFrom = cardToLearn.originalDeckId;
                } else if (activeDeckId !== MAIN_DECK_ID) {
                    originalDeckIdToRemoveFrom = activeDeckId;
                }

                if (originalDeckIdToRemoveFrom) {
                    const deck = userDecks.find(d => d.id === originalDeckIdToRemoveFrom);
                    if (deck) {
                        deck.cards = deck.cards.filter(c => c.question.toLowerCase() !== cardToLearn.question.toLowerCase());
                    }
                }

                // Award points for learning, similar logic to correct answer
                checkHourlyPointLimit();
                const activeDeckIsSpecific = activeDeckId && activeDeckId !== MAIN_DECK_ID;
                const deckWhereCardWas = originalDeckIdToRemoveFrom ? userDecks.find(d=>d.id === originalDeckIdToRemoveFrom) : null;
                // Points for learning if the deck it came from (plus this card) met criteria, or if it was from main deck study
                const canEarnPointsForLearning = (activeDeckId === MAIN_DECK_ID && currentStudyCards.length >= MIN_CARDS_FOR_POINTS) ||
                                                 (deckWhereCardWas && deckWhereCardWas.cards.length + 1 >= MIN_CARDS_FOR_POINTS);


                if (!canEarnPointsForLearning) {
                     feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. El mazo original necesita ${MIN_CARDS_FOR_POINTS} palabras para ganar puntos por aprender.`;
                } else if (pointsThisHour >= MAX_POINTS_PER_HOUR) {
                    feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. Límite de ${MAX_POINTS_PER_HOUR} puntos/hora alcanzado.`;
                } else {
                    const pointsToAdd = POINTS_FOR_LEARNED_WORD;
                    let actualPointsAdded = pointsToAdd;
                    if (pointsThisHour + pointsToAdd > MAX_POINTS_PER_HOUR) {
                        actualPointsAdded = MAX_POINTS_PER_HOUR - pointsThisHour;
                        feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. +${actualPointsAdded} pts! (Límite horario alcanzado)`;
                    } else {
                         feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. +${actualPointsAdded} pts!`;
                    }
                    score += actualPointsAdded;
                    pointsThisHour += actualPointsAdded;
                    updateScoreDisplay();
                }
                showTemporaryFeedback(feedbackTextEl, feedbackMessage, "info", 3500);
            } else {
                showTemporaryFeedback(feedbackTextEl, `"${cardToLearn.question}" ya estaba marcada como aprendida.`, "info", 2500);
            }

            // Remove from current study session (currentStudyCards)
            currentStudyCards.splice(currentCardIndex, 1);

            saveGameData();
            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.remove('hidden'); // Ensure next button is visible
            nextCardBtn.focus();

            if (currentStudyCards.length === 0) {
                handleNoCardsInActiveDeckState(); // Handle if no cards left to study
            } else {
                // If we removed the last card, loop back to the start of the current (now shorter) list
                if (currentCardIndex >= currentStudyCards.length) {
                    currentCardIndex = 0;
                }
                displayCard(); // Display next or first card
            }
            updateStudyPanelWordManagementButtons(); // Reflect changes in card counts
            populateDecksListInModal(); // Update card counts in deck list
        }


        function moveToNextCard() {
            if (currentStudyCards.length === 0) {
                handleNoCardsInActiveDeckState();
                return;
            }
            currentCardIndex++;
            if (currentCardIndex >= currentStudyCards.length) {
                currentCardIndex = 0; // Loop back to the start
                updateCurrentStudyCards(); // Re-shuffle if settings dictate or just reset view
                if (currentStudyCards.length > 0 && (!feedbackTextEl.textContent || feedbackTextEl.classList.contains('correct') || feedbackTextEl.classList.contains('incorrect'))) {
                    // Only show shuffle message if not overriding an important info message
                     showTemporaryFeedback(feedbackTextEl, "¡Mazo barajado para la siguiente ronda!", "info", 1500);
                }
            }
            displayCard();
        }

        function checkHourlyPointLimit() {
            const now = Date.now();
            if (now - lastPointResetTime >= ONE_HOUR_IN_MS) {
                pointsThisHour = 0;
                lastPointResetTime = now;
                saveGameData(); // Save the reset time and points
            }
        }

        // --- UI Updates for Stats ---
        function updateScoreDisplay() { scoreEl.textContent = score; }
        function updateFertilizerCountDisplay() {
            fertilizerCountEl.textContent = fertilizerCount;
            const currentLevelData = TREE_LEVEL_DATA[treeLevel];
            useFertilizerBtn.disabled = treeLevel >= MAX_TREE_LEVEL_INDEX ||
                                       (treeLevel < MAX_TREE_LEVEL_INDEX && fertilizerCount < currentLevelData.fertilizerToNext);
            useFertilizerBtn.classList.toggle('btn-disabled', useFertilizerBtn.disabled);
        }
        function updateApplesCountDisplay() { applesCountEl.textContent = `${applesCount} 🍎`; }
        function updateApplesPerDayDisplay() { applesPerDayEl.textContent = `${applesPerDay} / día`; }

        function updateTreeVisual() {
            const currentLevelData = TREE_LEVEL_DATA[treeLevel];
            const gifPath = `gifs/${currentLevelData.gifName}`; // Ensure these GIFs exist
            treeDisplayEl.innerHTML = `<img src="${gifPath}" alt="Árbol de progreso: Nivel ${currentLevelData.name}" class="tree-gif mx-auto">`;
            treeLevelTextEl.textContent = `Nivel: ${currentLevelData.name}`;
            applesPerDay = currentLevelData.applesPerDay;
            updateApplesPerDayDisplay();
            if (treeLevel >= MAX_TREE_LEVEL_INDEX) {
                useFertilizerBtn.textContent = "¡Árbol Maximizado!";
                useFertilizerBtn.disabled = true;
            } else {
                useFertilizerBtn.textContent = `Crecer (${currentLevelData.fertilizerToNext} Fert.)`;
                useFertilizerBtn.disabled = fertilizerCount < currentLevelData.fertilizerToNext;
            }
            useFertilizerBtn.classList.toggle('btn-disabled', useFertilizerBtn.disabled);
        }

        function growTree() {
            if (treeLevel >= MAX_TREE_LEVEL_INDEX) {
                showTemporaryFeedback(feedbackTextEl, "Tu árbol ya está en el nivel máximo.", "info", 2500);
                return;
            }
            const requiredFertilizer = TREE_LEVEL_DATA[treeLevel].fertilizerToNext;
            if (fertilizerCount >= requiredFertilizer) {
                fertilizerCount -= requiredFertilizer;
                treeLevel++;
                updateTreeVisual();
                updateFertilizerCountDisplay();
                showTemporaryFeedback(feedbackTextEl, `¡Tu árbol creció a ${TREE_LEVEL_DATA[treeLevel].name}!`, "correct", 2500);
                treeDisplayEl.style.transform = 'scale(1.15)';
                setTimeout(() => { treeDisplayEl.style.transform = 'scale(1)'; }, 300);
                saveGameData();
            } else {
                 showTemporaryFeedback(feedbackTextEl, `Necesitas ${requiredFertilizer - fertilizerCount} más fertilizante.`, "info", 3000);
            }
        }

        // --- Apple Generation ---
        function checkAndGenerateApples() {
            if (applesPerDay <= 0) {
                updateAppleCountdown(); return;
            }
            const now = Date.now();
            const timeElapsedMs = now - lastAppleGenerationTime;
            const generationIntervalMs = ((24 * 60 * 60) / applesPerDay) * 1000; // Milliseconds per apple

            if (timeElapsedMs >= generationIntervalMs) {
                const applesToGenerate = Math.floor(timeElapsedMs / generationIntervalMs);
                applesCount += applesToGenerate;
                lastAppleGenerationTime += applesToGenerate * generationIntervalMs; // Advance last generation time correctly
                updateApplesCountDisplay();
                showTemporaryFeedback(feedbackTextEl, `¡Cosechaste ${applesToGenerate} manzana(s) 🍎!`, "correct", 2000);
                saveGameData();
            }
            updateAppleCountdown(); // Always update countdown
        }

        function updateAppleCountdown() {
            if (appleCountdownInterval) clearInterval(appleCountdownInterval);
            if (applesPerDay <= 0) {
                appleCountdownEl.textContent = "--:--:--"; return;
            }

            function calculateAndDisplayCountdown() {
                const now = Date.now();
                const generationIntervalMs = ((24 * 60 * 60) / applesPerDay) * 1000;
                const timeSinceLastApple = now - lastAppleGenerationTime;

                // Check if an apple should have been generated (this might be redundant if checkAndGenerateApples is called frequently)
                if (timeSinceLastApple >= generationIntervalMs && applesPerDay > 0) {
                    checkAndGenerateApples(); // This will update lastAppleGenerationTime
                    // Recalculate timeSinceLastApple based on potentially updated lastAppleGenerationTime
                    const newTimeSinceLastApple = now - lastAppleGenerationTime;
                    let timeToNextAppleMs = generationIntervalMs - (newTimeSinceLastApple % generationIntervalMs);
                    if (timeToNextAppleMs <= 0) timeToNextAppleMs = generationIntervalMs; // Ensure positive countdown

                    displayTime(timeToNextAppleMs);
                    return;
                }

                let timeToNextAppleMs = generationIntervalMs - (timeSinceLastApple % generationIntervalMs);

                if (timeToNextAppleMs <= 1000 && timeToNextAppleMs > 0) { // About to generate
                     appleCountdownEl.textContent = "¡Ahora!"; return;
                }
                if (timeToNextAppleMs <= 0) timeToNextAppleMs = generationIntervalMs; // Should not happen if logic is correct

                displayTime(timeToNextAppleMs);
            }

            function displayTime(ms) {
                const h = String(Math.floor((ms / (1000 * 60 * 60)) % 24)).padStart(2, '0');
                const m = String(Math.floor((ms / (1000 * 60)) % 60)).padStart(2, '0');
                const s = String(Math.floor((ms / 1000) % 60)).padStart(2, '0');
                appleCountdownEl.textContent = `${h}:${m}:${s}`;
            }

            calculateAndDisplayCountdown(); // Initial display
            appleCountdownInterval = setInterval(calculateAndDisplayCountdown, 1000); // Update every second
        }

        // --- Word Management in Study Panel ---
        function updateStudyPanelWordManagementButtons() {
            const isSpecificDeckActive = activeDeckId && activeDeckId !== MAIN_DECK_ID;
            showAddCardModalBtn.disabled = !isSpecificDeckActive;
            showDeleteCardModalBtn.disabled = !isSpecificDeckActive;

            showAddCardModalBtn.classList.toggle('btn-disabled', !isSpecificDeckActive);
            showDeleteCardModalBtn.classList.toggle('btn-disabled', !isSpecificDeckActive);

            if (!isSpecificDeckActive) {
                addCardModal.querySelector('h3').textContent = "Añadir Palabra (Selecciona un mazo específico)";
                deleteCardModal.querySelector('h3').textContent = "Eliminar Palabra (Selecciona un mazo específico)";
            } else {
                addCardModal.querySelector('h3').textContent = `Nueva Palabra (a "${getActiveDeckName()}")`;
                deleteCardModal.querySelector('h3').textContent = `Eliminar Palabra (de "${getActiveDeckName()}")`;
            }
        }

        showAddCardModalBtn.addEventListener('click', () => {
            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) {
                showTemporaryFeedback(feedbackTextEl, "Selecciona un mazo específico para añadir palabras.", "info", 3000);
                return;
            }
            newQuestionInput.value = ''; newAnswerInput.value = '';
            clearFeedback(addCardFeedbackEl);
            addCardModal.querySelector('h3').textContent = `Nueva Palabra (a "${getActiveDeckName()}")`;
            openModal(addCardModal);
            newQuestionInput.focus();
        });

        cancelAddCardBtn.addEventListener('click', () => closeModal(addCardModal));

        saveCardBtn.addEventListener('click', () => {
            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) {
                showTemporaryFeedback(addCardFeedbackEl, "Error: No hay un mazo específico activo.", "incorrect");
                return;
            }
            const activeDeck = userDecks.find(d => d.id === activeDeckId);
            if (!activeDeck) {
                showTemporaryFeedback(addCardFeedbackEl, "Error: Mazo activo no encontrado.", "incorrect");
                return;
            }

            const newQ = newQuestionInput.value.trim();
            const newA = newAnswerInput.value.trim();
            if (newQ && newA) {
                if (activeDeck.cards.some(c => c.question.toLowerCase() === newQ.toLowerCase())) {
                    showTemporaryFeedback(addCardFeedbackEl, `La palabra "${newQ}" ya existe en el mazo "${activeDeck.name}".`, "incorrect", 2500);
                    return;
                }
                activeDeck.cards.push({ question: newQ, answer: newA });
                updateCurrentStudyCards(); // Refresh study cards if this deck is active
                saveGameData();
                showTemporaryFeedback(addCardFeedbackEl, "¡Palabra añadida con éxito!", "correct", 1500);
                newQuestionInput.value = ''; newAnswerInput.value = ''; // Clear for next entry
                newQuestionInput.focus();

                // If the study panel was showing "no cards", refresh it
                if (questionTextEl.textContent.startsWith("¡No hay palabras en")) {
                    displayCard();
                }
                updateDefaultFeedbackMessage(); // Update info about card counts if necessary
                populateDecksListInModal(); // Update card count in decks modal
            } else {
                showTemporaryFeedback(addCardFeedbackEl, "Ambos campos son obligatorios.", "incorrect", 2000);
            }
        });

        showDeleteCardModalBtn.addEventListener('click', () => {
            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) {
                showTemporaryFeedback(feedbackTextEl, "Selecciona un mazo específico para eliminar palabras.", "info", 3000);
                return;
            }
            deleteCardModal.querySelector('h3').textContent = `Eliminar Palabra (de "${getActiveDeckName()}")`;
            populateDeleteCardList();
            openModal(deleteCardModal);
        });
        cancelDeleteCardBtn.addEventListener('click', () => closeModal(deleteCardModal));

        function populateDeleteCardList() {
            deleteCardListContainerEl.innerHTML = '';
            clearFeedback(deleteFeedbackEl);
            selectAllDeleteBtn.classList.add('hidden'); // Hide by default

            const activeDeck = userDecks.find(d => d.id === activeDeckId);
            if (!activeDeck || activeDeck.cards.length === 0) {
                noCardsToDeleteMsgEl.textContent = `No hay palabras para eliminar en el mazo "${getActiveDeckName()}".`;
                noCardsToDeleteMsgEl.classList.remove('hidden');
                confirmDeleteCardBtn.disabled = true;
                confirmDeleteCardBtn.classList.add('btn-disabled');
                return;
            }

            noCardsToDeleteMsgEl.classList.add('hidden');
            confirmDeleteCardBtn.disabled = false;
            confirmDeleteCardBtn.classList.remove('btn-disabled');
            if (activeDeck.cards.length > 1) selectAllDeleteBtn.classList.remove('hidden');
            selectAllDeleteBtn.textContent = 'Seleccionar Todas'; // Reset button text

            activeDeck.cards.sort((a, b) => a.question.localeCompare(b.question)).forEach((card, index) => {
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center p-1.5 hover:bg-gray-50 rounded';
                listItem.innerHTML = `
                    <input type="checkbox" id="delete-card-${index}" value="${card.question}" class="mr-2 rounded border-gray-300 text-[var(--duo-blue)] focus:ring-[var(--duo-blue)] h-4 w-4">
                    <label for="delete-card-${index}" class="flex-grow text-sm text-[var(--duo-text-dark)] cursor-pointer">
                        ${card.question} - ${card.answer}
                    </label>`;
                deleteCardListContainerEl.appendChild(listItem);
            });
        }

        confirmDeleteCardBtn.addEventListener('click', () => {
            const activeDeck = userDecks.find(d => d.id === activeDeckId);
            if (!activeDeck) {
                showTemporaryFeedback(deleteFeedbackEl, "Error: Mazo activo no encontrado.", "incorrect");
                return;
            }

            const checkboxes = deleteCardListContainerEl.querySelectorAll('input[type="checkbox"]:checked');
            if (checkboxes.length === 0) {
                showTemporaryFeedback(deleteFeedbackEl, "Selecciona al menos una palabra para eliminar.", "incorrect", 2500);
                return;
            }
            const questionsToDelete = Array.from(checkboxes).map(cb => cb.value.toLowerCase());

            activeDeck.cards = activeDeck.cards.filter(card => !questionsToDelete.includes(card.question.toLowerCase()));

            updateCurrentStudyCards(); // Refresh study cards
            saveGameData();
            showTemporaryFeedback(deleteFeedbackEl, `${questionsToDelete.length} palabra(s) eliminada(s) de "${activeDeck.name}".`, "correct", 2000);

            // If current card was deleted, refresh display
            if (currentStudyCards.length > 0) {
                // Check if the currently displayed question was among those deleted
                if (questionTextEl.textContent && questionsToDelete.includes(questionTextEl.textContent.toLowerCase())) {
                    currentCardIndex = 0; // Reset to first card of remaining
                }
                displayCard();
            } else {
                handleNoCardsInActiveDeckState(); // No cards left in this deck
            }
            populateDeleteCardList(); // Refresh the delete list (it should be empty or shorter)
            updateDefaultFeedbackMessage();
            populateDecksListInModal(); // Update card count in decks modal
        });

        selectAllDeleteBtn.addEventListener('click', () => {
            const checkboxes = deleteCardListContainerEl.querySelectorAll('input[type="checkbox"]');
            if (checkboxes.length === 0) return;
            const shouldSelectAll = selectAllDeleteBtn.textContent === 'Seleccionar Todas';
            checkboxes.forEach(checkbox => { checkbox.checked = shouldSelectAll; });
            selectAllDeleteBtn.textContent = shouldSelectAll ? 'Deseleccionar Todas' : 'Seleccionar Todas';
        });

        showReviewLearnedModalBtn.addEventListener('click', () => {
            populateReviewLearnedList();
            openModal(reviewLearnedModal);
        });
        closeReviewLearnedBtn.addEventListener('click', () => closeModal(reviewLearnedModal));

        function populateReviewLearnedList() {
            reviewLearnedListContainerEl.innerHTML = '';
            clearFeedback(reviewModalFeedbackEl);
            if (learnedFlashcards.length === 0) {
                noLearnedCardsMsgEl.classList.remove('hidden');
                return;
            }
            noLearnedCardsMsgEl.classList.add('hidden');
            learnedFlashcards.sort((a, b) => a.question.localeCompare(b.question)).forEach((card) => {
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center justify-between p-1.5 hover:bg-gray-50 rounded';
                listItem.innerHTML = `
                    <span class="text-sm text-[var(--duo-text-dark)]">${card.question} - ${card.answer}</span>
                    <button data-question="${card.question}" class="btn btn-danger btn-sm remove-learned-btn !py-1 !px-2 !text-xs">Olvidar</button>`;
                reviewLearnedListContainerEl.appendChild(listItem);
            });
            reviewLearnedListContainerEl.querySelectorAll('.remove-learned-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const questionToForget = e.target.dataset.question;
                    const cardIndexInLearned = learnedFlashcards.findIndex(c => c.question.toLowerCase() === questionToForget.toLowerCase());

                    if (cardIndexInLearned > -1) {
                        const forgottenCard = learnedFlashcards.splice(cardIndexInLearned, 1)[0];

                        // Add back to a deck. Prioritize active specific deck, then first deck.
                        let movedToDeckName = null;
                        let targetDeckForReturn = null;

                        if (activeDeckId && activeDeckId !== MAIN_DECK_ID) {
                            targetDeckForReturn = userDecks.find(d => d.id === activeDeckId);
                        } else if (userDecks.length > 0) {
                            targetDeckForReturn = userDecks[0]; // Default to first deck if main is active or no specific active
                        }

                        if (targetDeckForReturn) {
                            if (!targetDeckForReturn.cards.some(c => c.question.toLowerCase() === forgottenCard.question.toLowerCase())) {
                                targetDeckForReturn.cards.push({ question: forgottenCard.question, answer: forgottenCard.answer });
                                movedToDeckName = targetDeckForReturn.name;
                            } else {
                                // Card already exists in target deck, perhaps it was never fully removed or re-added manually
                                console.warn(`Card "${forgottenCard.question}" already in target deck "${targetDeckForReturn.name}" upon 'forgetting'.`);
                            }
                        } else {
                            // No user decks exist, create a new one for the forgotten card
                            const newDeck = { id: generateUUID(), name: "Mazo Recuperado", cards: [forgottenCard] };
                            userDecks.push(newDeck);
                            movedToDeckName = newDeck.name;
                            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) activeDeckId = newDeck.id; // Make it active if no specific deck was
                        }

                        updateCurrentStudyCards(); // Refresh study cards
                        saveGameData();
                        populateReviewLearnedList(); // Refresh this modal
                        if (movedToDeckName) {
                            showTemporaryFeedback(reviewModalFeedbackEl, `"${questionToForget}" movida de nuevo al mazo "${movedToDeckName}".`, "info", 2500);
                            populateDecksListInModal(); // Update card counts in decks modal
                        } else {
                             showTemporaryFeedback(reviewModalFeedbackEl, `"${questionToForget}" olvidada. No se pudo añadir a un mazo.`, "info", 2000);
                        }
                        // If study panel was empty, refresh it
                        if (currentStudyCards.length > 0 && questionTextEl.textContent.startsWith("¡No hay palabras")) {
                            displayCard();
                        }
                         updateDefaultFeedbackMessage();
                    }
                });
            });
        }

        // --- Shop Logic ---
        openShopBtn.addEventListener('click', () => {
            clearFeedback(shopFeedbackEl);
            updateShopCosts();
            loadShopDecks(); // Asynchronously load deck definitions
            openModal(shopModal);
        });
        closeShopBtn.addEventListener('click', () => closeModal(shopModal));
        buyFertilizerShopBtn.addEventListener('click', () => {
            if (score >= FERTILIZER_SHOP_COST) {
                score -= FERTILIZER_SHOP_COST;
                fertilizerCount++;
                updateScoreDisplay();
                updateFertilizerCountDisplay();
                saveGameData();
                showTemporaryFeedback(shopFeedbackEl, "¡Fertilizante comprado!", "correct", 2000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, "Puntos insuficientes.", "incorrect", 2000);
            }
        });
        buyAppleShopBtn.addEventListener('click', () => {
            if (score >= APPLE_SHOP_COST) {
                score -= APPLE_SHOP_COST;
                applesCount++;
                updateScoreDisplay();
                updateApplesCountDisplay();
                saveGameData();
                showTemporaryFeedback(shopFeedbackEl, "¡Manzana comprada! 🍎", "correct", 2000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, "Puntos insuficientes.", "incorrect", 2000);
            }
        });
        function updateShopCosts() {
            fertilizerShopCostDisplayEl.textContent = FERTILIZER_SHOP_COST;
            appleShopCostDisplayEl.textContent = APPLE_SHOP_COST;
        }
        async function loadShopDecks() {
            shopDecksContainerEl.innerHTML = ''; // Clear previous items
            loadingDecksMsgEl.classList.remove('hidden');
            let decksDisplayed = 0;

            for (const deckDef of SHOP_DECK_DEFINITIONS) {
                try {
                    // Fetch with cache busting to get fresh data if JSON files are updated
                    const response = await fetch(deckDef.fileName + `?v=${Date.now()}`);
                    if (!response.ok) throw new Error(`HTTP error ${response.status} for ${deckDef.fileName}`);
                    const deckData = await response.json(); // deckData should have {name, cost, cards}
                    shopDecksData[deckDef.id] = deckData; // Store for purchase logic

                    const deckItemEl = document.createElement('div');
                    deckItemEl.className = 'p-2.5 border rounded-lg bg-gray-50';
                    deckItemEl.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="font-semibold text-sm">${deckData.name}</h4>
                                <p class="text-xs text-gray-500">Costo: <span class="deck-cost">${deckData.cost}</span> 🍎 | Palabras: ${deckData.cards.length}</p>
                            </div>
                            <button class="btn btn-primary btn-sm buy-deck-btn !py-1 !px-2 !text-xs" data-deck-id="${deckDef.id}">Comprar</button>
                        </div>`;
                    shopDecksContainerEl.appendChild(deckItemEl);
                    decksDisplayed++;
                } catch (error) {
                    console.error(`Error cargando mazo de tienda ${deckDef.fileName}:`, error);
                     // Optionally display an error for this specific deck in the shop UI
                }
            }
            loadingDecksMsgEl.classList.add('hidden');
            if (decksDisplayed === 0 && SHOP_DECK_DEFINITIONS.length > 0) {
                 shopDecksContainerEl.innerHTML = '<p class="text-sm text-center text-[var(--duo-gray-dark)]">No se pudieron cargar los mazos de la tienda.</p>';
            }

            shopDecksContainerEl.querySelectorAll('.buy-deck-btn').forEach(button => {
                button.addEventListener('click', (e) => handleBuyShopDeck(e.target.dataset.deckId));
            });
        }

        function handleBuyShopDeck(deckId) {
            const deckDataFromShop = shopDecksData[deckId];
            if (!deckDataFromShop) {
                showTemporaryFeedback(shopFeedbackEl, "Error: Mazo de tienda no encontrado.", "incorrect"); return;
            }
            if (applesCount >= deckDataFromShop.cost) {
                // Check if a deck with the same name already exists
                if (userDecks.some(d => d.name.toLowerCase() === deckDataFromShop.name.toLowerCase())) {
                     showTemporaryFeedback(shopFeedbackEl, `Ya tienes un mazo llamado "${deckDataFromShop.name}". Renombra el existente o este no se añadirá.`, "info", 4000);
                     return;
                }

                applesCount -= deckDataFromShop.cost;
                const newDeckFromShop = {
                    id: generateUUID(), // Generate a new unique ID for the user's copy
                    name: deckDataFromShop.name,
                    cards: deckDataFromShop.cards.map(c => ({...c})) // Deep copy cards
                };
                userDecks.push(newDeckFromShop);

                updateApplesCountDisplay();
                saveGameData();
                populateDecksListInModal(); // Update "My Decks" modal
                showTemporaryFeedback(shopFeedbackEl, `¡Mazo "${deckDataFromShop.name}" comprado y añadido a tus mazos!`, "correct", 3000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, `Manzanas insuficientes.`, "incorrect");
            }
        }

        // --- Global Event Listeners & Init ---
        openDecksModalBtn.addEventListener('click', () => {
            populateDecksListInModal();
            updateActiveDeckDisplay(); // Ensure active deck name is current in modal
            clearFeedback(deckManagementFeedbackEl);
            openModal(decksModal);
        });
        closeDecksModalBtn.addEventListener('click', () => closeModal(decksModal));
        openAddNewDeckModalBtn.addEventListener('click', handleOpenAddNewDeckModal);
        selectMainDeckBtn.addEventListener('click', handleSelectMainDeckForStudy);

        saveDeckNameBtn.addEventListener('click', handleSaveDeckName);
        cancelAddEditDeckNameBtn.addEventListener('click', () => closeModal(addEditDeckNameModal));

        learnedBtn.addEventListener('click', markAsLearned);
        nextCardBtn.addEventListener('click', () => moveToNextCard());

        useFertilizerBtn.addEventListener('click', growTree);
        exportProgressBtn.addEventListener('click', exportProgress);
        importProgressBtn.addEventListener('click', () => importProgressInput.click()); // Trigger file input
        importProgressInput.addEventListener('change', handleImportFile);
        downloadWordsBtn.addEventListener('click', () => {
            let contentToDownload = [];
            let fileNamePrefix = "todas_tus_palabras";

            if (activeDeckId && activeDeckId !== MAIN_DECK_ID) {
                const activeDeck = userDecks.find(d => d.id === activeDeckId);
                if (activeDeck && activeDeck.cards.length > 0) {
                    contentToDownload.push(`=== Palabras del Mazo: ${activeDeck.name} ===`);
                    contentToDownload.push(...activeDeck.cards.map(c => `${c.question}: ${c.answer}`));
                    fileNamePrefix = activeDeck.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                } else {
                     showTemporaryFeedback(importExportFeedbackEl, "El mazo activo está vacío.", "info");
                }
            } else { // Main deck or no specific deck (download all)
                userDecks.forEach(deck => {
                    if (deck.cards.length > 0) {
                        contentToDownload.push(`=== Palabras del Mazo: ${deck.name} ===`);
                        contentToDownload.push(...deck.cards.map(c => `${c.question}: ${c.answer}`));
                        contentToDownload.push(""); // Add a blank line between decks
                    }
                });
            }

            if (learnedFlashcards.length > 0) {
                contentToDownload.push("=== Palabras Aprendidas (Global) ===");
                contentToDownload.push(...learnedFlashcards.map(c => `${c.question}: ${c.answer}`));
            }

            if (contentToDownload.length === 0) {
                 showTemporaryFeedback(importExportFeedbackEl, "No hay palabras para descargar.", "info"); return;
            }

            const textContent = contentToDownload.join('\r\n');
            const blob = new Blob([textContent], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `flashcards_${fileNamePrefix}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showTemporaryFeedback(importExportFeedbackEl, "Archivo de palabras descargado.", "correct");
        });

        function initGameVisuals() {
            updateCurrentStudyCards(); // This will also call displayCard if cards exist
            displayCard(); // Call explicitly to handle no-card state correctly
            updateAllStatsDisplays();
            checkAndGenerateApples(); // Initial check
            updateStudyPanelWordManagementButtons();
        }

        function updateAllStatsDisplays() {
            updateScoreDisplay();
            updateFertilizerCountDisplay();
            updateApplesCountDisplay();
            updateTreeVisual(); // This also updates applesPerDay display
        }

        async function initGame() {
            // Initialize Speech Synthesis
            synth = window.speechSynthesis;
            if (synth) {
                populateVoices();
                if (synth.onvoiceschanged !== undefined) {
                    synth.onvoiceschanged = populateVoices;
                }
            } else {
                 console.warn("Speech synthesis is not supported in this browser.");
                if(speakerIconButtonEl) speakerIconButtonEl.style.display = 'none'; // Hide button if no synth
            }

            await initCryptoKey(); // Prepare encryption key
            loadGameData();        // Load saved progress or defaults
            initGameVisuals();     // Set up the UI based on loaded data

            // Start apple generation interval if not already started (e.g. on script reload)
            if (!window.appleCheckIntervalId) { // Use a global-like scope for interval ID
                 window.appleCheckIntervalId = setInterval(checkAndGenerateApples, CHECK_APPLES_INTERVAL);
            }
        }

        window.onload = initGame;


document.addEventListener('DOMContentLoaded', () => { // Asegúrate de que el DOM esté cargado
    const generateDeckButton = document.getElementById('generateDeckButton');
    if (generateDeckButton) {
        generateDeckButton.addEventListener('click', handleGenerateDeckButtonClick);
    }

        // AHORA PUEDES IMPORTAR geminiApi.js
        import { generateFlashcardDeck } from './geminiApi.js'; // Ajusta la ruta si geminiApi.js no está en la misma carpeta que index.html

        // Define la función para manejar la generación del mazo
        async function handleGenerateDeckButtonClick() {
            // Asume que tienes un input para el tema y otro para el número de tarjetas en tu HTML
            const topicInput = document.getElementById('deckTopicInput'); // Asegúrate de que exista este ID en tu HTML
            const numCardsInput = document.getElementById('numCardsInput'); // Asegúrate de que exista este ID en tu HTML

            const topic = topicInput ? topicInput.value : ''; // Manejo si el input no existe aún
            const numCards = numCardsInput ? parseInt(numCardsInput.value, 10) : 10;

            if (!topic) {
                alert("Por favor, ingresa un tema para el mazo.");
                return;
            }

            // Aquí puedes mostrar un spinner o deshabilitar el botón de generación
            console.log("Generando mazo sobre:", topic);

            try {
                const newDeck = await generateFlashcardDeck(topic, numCards);

                if (newDeck) {
                    console.log("Mazo generado exitosamente:", newDeck);
                    // Aquí es donde integrarías el nuevo mazo con la lógica de tu juego.
                    // Por ejemplo, añadiéndolo a una lista de mazos disponibles,
                    // guardándolo en tu `gameData`, y actualizando la UI.

                    // Ejemplo (adaptado a tu lógica de juego):
                    // Asumiendo que 'gameData' es una variable global o accesible aquí
                    if (typeof gameData !== 'undefined' && gameData.decks) {
                        gameData.decks.push({
                            name: `Mazo de IA: ${topic}`, // Nombre descriptivo para el mazo generado
                            cards: newDeck
                        });
                        saveGameData(); // Llama a tu función para guardar el estado del juego
                        // Aquí necesitarías una función para actualizar la UI que muestre los mazos
                        // Por ejemplo, volver a renderizar la lista de mazos o añadir dinámicamente el nuevo.
                        alert(`Mazo "${topic}" generado y añadido.`);
                    } else {
                        console.warn("gameData.decks no está disponible o no es un array. El mazo no se añadió a la data del juego.");
                        alert("Mazo generado, pero no se pudo añadir al juego. Revisa la consola.");
                    }
                } else {
                    alert("No se pudo generar el mazo. Intenta de nuevo.");
                }
            } catch (error) {
                console.error("Hubo un error al generar el mazo:", error);
                alert("Hubo un error al generar el mazo. Revisa la consola para más detalles.");
            } finally {
                // Aquí puedes ocultar el spinner o habilitar el botón de nuevo
            }
        }




    </script>
</body>
</html>
