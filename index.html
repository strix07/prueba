<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <title>Flashcards de Inglés Fácil: Aprende Vocabulario Interactivo con Mazos y Audio</title>

    <meta name="description" content="Mejora tu vocabulario en inglés con flashcards interactivas, mazos personalizables y pronunciación de audio. Aprende nuevas palabras, gestiona tus mazos y progreso, y haz crecer tu árbol de conocimiento. ¡Estudia inglés fácil!">
    <meta name="keywords" content="flashcards inglés, aprender inglés, vocabulario inglés, pronunciación inglés, audio inglés, mazos de estudio, inglés fácil, tarjetas de memoria, estudiar inglés, memorizar palabras, app inglés, aplicación para aprender inglés, mejorar inglés">
    <link rel="canonical" href="https://flashcards-inglesfacil.netlify.app/">
    <meta name="robots" content="index, follow">

    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6819141919218513"
     crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Flashcards de Inglés Fácil con Mazos y Audio",
      "description": "Aplicación web interactiva con flashcards, gestión de mazos y pronunciación de audio para aprender y memorizar vocabulario en inglés de forma fácil y divertida, con seguimiento de progreso y elementos de gamificación como un árbol de palabras.",
      "applicationCategory": "EducationalApplication, GameApplication",
      "operatingSystem": "Web",
      "browserRequirements": "Requires HTML5 support, JavaScript enabled, Web Speech API.",
      "url": "https://www.tu-dominio.com/ruta-a-esta-app/",
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "author": {
        "@type": "Person",
        "name": "Nemus"
      },
      "keywords": "flashcards, inglés, aprender inglés, vocabulario, pronunciación, audio, estudiar, memorizar, aplicación educativa, juego educativo, mazos de estudio"
    }
    </script>

    <style>
        :root {
            --duo-green: #4CAF50;
            --duo-green-dark: #388E3C;
            --duo-green-light: #66BB6A;
            --duo-blue: #1cb0f6;
            --duo-blue-dark: #138bc4;
            --duo-red: #ff4b4b;
            --duo-red-dark: #fa2d2d;
            --duo-orange: #ff9600;
            --duo-orange-dark: #e88800;
            --duo-yellow: #ffc800;
            --duo-gray-lightest: #f7f7f7;
            --duo-gray-light: #e5e5e5;
            --duo-gray-medium: #afafaf;
            --duo-gray-dark: #777777;
            --duo-text-dark: #4b4b4b;
            --duo-text-light: #ffffff;
            --duo-correct-bg: #d7ffb8;
            --duo-correct-text: #58a700;
            --duo-incorrect-bg: #ffdfe0;
            --duo-incorrect-text: #ea2b2b;
        }

        html, body {
            margin: 0;
            font-family: 'Nunito', sans-serif;
            background-color: var(--duo-gray-lightest);
            color: var(--duo-text-dark);
        }
        .app-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            height: auto; /* Cambiará en móvil */
            padding: 0.75rem; /* Cambiará en móvil */
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        .app-header {
            margin-bottom: 0.75rem;
            text-align: center;
            width: 100%;
            max-width: 1400px;
        }
        .app-header h1 {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--duo-green);
            margin-bottom: 0.5rem;
        }

        .main-content-area {
            display: flex;
            width: 100%;
            max-width: 1400px;
            flex-grow: 1;
            gap: 1rem;
            overflow: visible; /* Cambiará en móvil */
        }

        .column-title {
            font-size: 1.4rem;
            font-weight: 800;
            color: var(--duo-text-dark);
            text-align: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--duo-gray-light);
        }

        .sidebar {
            background-color: var(--duo-text-light);
            padding: 1.1rem;
            border-radius: 1rem;
            border: 1px solid var(--duo-gray-light);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }
        .sidebar-section .section-title {
            font-size: 1.0rem;
            font-weight: 700;
            margin-bottom: 0.6rem;
            text-align: center;
            color: var(--duo-text-dark);
        }
        .sidebar-section .button-group .btn {
            font-size: 0.8rem;
            padding: 0.6rem 1rem;
            width: auto;
        }
        .sidebar .stats-grid {
            grid-template-columns: repeat(auto-fit, minmax(75px, 1fr));
            gap: 0.4rem;
            margin-bottom: 0;
        }
        .sidebar .stat-item h3 { font-size: 0.65rem; }
        .sidebar .stat-item p { font-size: 1rem; }

        .content-wrapper-main {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 1rem;
            overflow: visible;
        }

        .study-panel, .tree-panel {
            background-color: var(--duo-text-light);
            padding: 1.1rem;
            border-radius: 1rem;
            border: 1px solid var(--duo-gray-light);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            overflow-y: visible;
        }

        #flashcard-section { margin-bottom: 0.75rem; }
        .flashcard {
            background-color: var(--duo-text-light);
            border: 2px solid var(--duo-gray-light);
            padding: 1.1rem;
            border-radius: 0.75rem;
            margin-bottom: 0.75rem;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.03);
        }
        .question-container {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
        }
        #question-text {
            font-size: 1.15rem;
            font-weight: 700;
            color: var(--duo-text-dark);
        }
        #speaker-icon-button {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--duo-blue);
            cursor: pointer;
            padding: 0.25rem;
            line-height: 1;
        }
        #speaker-icon-button:hover {
            color: var(--duo-blue-dark);
        }
        #speaker-icon-button:disabled {
            color: var(--duo-gray-medium);
            cursor: not-allowed;
        }


        .input-field {
            padding: 0.6rem 0.9rem;
            border: 2px solid var(--duo-gray-light);
            border-radius: 0.75rem;
            width: 100%;
            max-width: 280px;
            margin: 0.375rem auto;
            box-sizing: border-box;
            font-size: 0.9rem;
            color: var(--duo-text-dark);
            transition: border-color 0.2s ease;
        }
        .input-field:focus {
            border-color: var(--duo-blue);
            outline: none;
            box-shadow: 0 0 0 3px rgba(28, 176, 246, 0.2);
        }
        .feedback {
            margin-top: 0.375rem;
            font-weight: 700;
            min-height: 20px;
            font-size: 0.85rem;
            margin-bottom: 0.6rem;
            padding: 0.4rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        .feedback.correct {
            background-color: var(--duo-correct-bg);
            color: var(--duo-correct-text);
            border: 1px solid var(--duo-correct-text);
        }
        .feedback.incorrect {
            background-color: var(--duo-incorrect-bg);
            color: var(--duo-incorrect-text);
            border: 1px solid var(--duo-incorrect-text);
        }
         .feedback.info {
            background-color: #e0f2fe;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }
        .feedback.loading {
            background-color: #fff3cd; /* Light yellow */
            color: #856404; /* Dark yellow text */
            border: 1px solid #ffeeba; /* Yellow border */
        }


        .btn {
            padding: 0.65rem 1.1rem;
            border-radius: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.15s ease;
            cursor: pointer;
            border: none;
            border-bottom: 3px solid rgba(0,0,0,0.2);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 90px;
            font-size: 0.85rem;
            color: var(--duo-text-light);
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .btn:active:not(:disabled) {
            transform: translateY(0px);
            border-bottom-width: 1px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .btn-primary { background-color: var(--duo-green); border-bottom-color: var(--duo-green-dark); }
        .btn-primary:hover:not(:disabled) { background-color: var(--duo-green-light); }
        .btn-secondary { background-color: var(--duo-blue); border-bottom-color: var(--duo-blue-dark); }
        .btn-secondary:hover:not(:disabled) { background-color: #4acaff; }
        .btn-tertiary { background-color: var(--duo-orange); border-bottom-color: var(--duo-orange-dark); }
        .btn-tertiary:hover:not(:disabled) { background-color: #ffae40; }
        .btn-danger { background-color: var(--duo-red); border-bottom-color: var(--duo-red-dark); }
        .btn-danger:hover:not(:disabled) { background-color: #ff6a6a; }
        .btn-learned { background-color: var(--duo-yellow); border-bottom-color: #e6b400; color: var(--duo-text-dark); }
        .btn-learned:hover:not(:disabled) { background-color: #ffd433; }
        .btn-ai { background-color: #6A0DAD; border-bottom-color: #4B0082; /* Purple shades */ }
        .btn-ai:hover:not(:disabled) { background-color: #8A2BE2; }

        .btn-disabled, .btn:disabled {
            background-color: var(--duo-gray-light) !important;
            border-bottom-color: var(--duo-gray-medium) !important;
            color: var(--duo-gray-dark) !important;
            cursor: not-allowed !important;
            transform: none !important;
            box-shadow: 0 2px 3px rgba(0,0,0,0.05) !important;
        }
        .btn-disabled:hover, .btn:disabled:hover { background-color: var(--duo-gray-light) !important; }


        .option-btn {
            background-color: var(--duo-text-light);
            color: var(--duo-text-dark);
            border: 2px solid var(--duo-gray-light);
            padding: 0.75rem;
            text-align: left;
            text-transform: none;
            font-size: 0.95rem;
            font-weight: 600;
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .option-btn:hover:not(:disabled) {
            border-color: var(--duo-blue);
            background-color: #f0f8ff;
            transform: translateY(-1px);
        }
        .option-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            background-color: var(--duo-gray-lightest);
        }
        .option-btn.selected-correct {
            background-color: var(--duo-correct-bg) !important;
            color: var(--duo-correct-text) !important;
            border-color: var(--duo-correct-text) !important;
            font-weight: 700;
        }
        .option-btn.selected-incorrect {
            background-color: var(--duo-incorrect-bg) !important;
            color: var(--duo-incorrect-text) !important;
            border-color: var(--duo-incorrect-text) !important;
            font-weight: 700;
        }
        .option-btn.actual-correct {
            background-color: var(--duo-correct-bg) !important;
            color: var(--duo-correct-text) !important;
            border: 2px dashed var(--duo-correct-text) !important;
        }

        .stats-grid {
            display: grid;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .stat-item {
            background-color: var(--duo-gray-lightest);
            padding: 0.6rem;
            border-radius: 0.5rem;
            text-align: center;
            border: 1px solid var(--duo-gray-light);
        }
        .stat-item h3 {
            margin-top: 0;
            color: var(--duo-gray-dark);
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.1rem;
        }
        .stat-item p { font-size: 1.1rem; font-weight: 700; color: var(--duo-text-dark); }

        .tree-panel .stats-grid {
             grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
             margin-top: 1rem;
        }
        .tree-section-container { display: flex; flex-direction: column; flex-grow: 1; }
        .tree-display {
            margin: 0.5rem 0;
            min-height: 130px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s ease-in-out;
            flex-grow: 0.5;
        }
        .tree-display:hover { transform: scale(1.05); }
        .tree-gif { max-width: 100%; max-height: 180px; object-fit: contain; }
        #tree-level-text {
            font-size: 0.9rem;
            margin-top: 0.25rem;
            font-weight: 600;
            color: var(--duo-gray-dark);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 0.6rem;
            text-align: center;
            color: var(--duo-text-dark);
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.4rem;
        }
        .button-group .btn {
            font-size: 0.75rem;
            padding: 0.5rem 0.9rem;
        }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center; z-index: 1000;
            backdrop-filter: blur(3px);
            overflow-y: auto;
            padding: 1rem;
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            width: 90%; max-width: 450px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border-top: 5px solid var(--duo-green);
        }
        .modal-content.max-w-2xl { max-width: 672px; }

        .modal-content h3 {
            font-size: 1.3rem; font-weight: 700; margin-bottom: 1rem; color: var(--duo-text-dark);
            text-align: center;
        }
        .modal-content label {
            font-size: 0.9rem; color: var(--duo-gray-dark); margin-bottom: 0.25rem; display: block; font-weight: 600;
        }
        .modal-content .input-field { font-size: 0.9rem; margin-bottom: 1rem; }
        .modal-content .feedback { font-size: 0.8rem; min-height: 20px; }
        .modal-content .btn-sm {
            font-size: 0.85rem;
            padding: 0.6rem 1rem;
            text-transform: uppercase;
        }
        .modal-content .btn.bg-slate-300 {
            background-color: var(--duo-gray-light);
            color: var(--duo-gray-dark);
            border-bottom-color: var(--duo-gray-medium);
        }
        .modal-content .btn.bg-slate-300:hover {
            background-color: #d1d1d1;
        }
        #shop-decks-container {
            max-height: 150px;
            overflow-y: auto;
        }
        #import-progress-input { display: none; }

        .deck-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--duo-gray-light);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            background-color: var(--duo-gray-lightest);
        }
        .deck-list-item.active-deck-item {
            border-left: 4px solid var(--duo-green);
            background-color: #e8f5e9;
        }
        .deck-list-item .deck-name {
            font-weight: 600;
            color: var(--duo-text-dark);
            flex-grow: 1;
        }
        .deck-list-item .deck-actions .btn {
            padding: 0.3rem 0.6rem;
            font-size: 0.7rem;
            margin-left: 0.25rem;
        }
        .loading-spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--duo-blue);
            animation: spin 1s ease infinite;
            margin: 1rem auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        @media (max-width: 1024px) {

            html, body {
                height: 100%;
                overflow: hidden;
            }

            .app-header h1 {
                display: none;
            }

        .app-wrapper {
            height: 100dvh;
            padding: 0.5rem;
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

            .main-content-area {
            flex-direction: column;
            flex-grow: 1;
            overflow-y: auto;
            scroll-snap-type: y mandatory;
            gap: 0;
            scrollbar-width: none;
            -ms-overflow-style: none;
            padding-bottom: env(safe-area-inset-bottom, 0px);
            box-sizing: border-box;
        }
        .main-content-area::-webkit-scrollbar {
            display: none;
        }

            .content-wrapper-main {
                order: 1;
                display: contents;
            }

            .study-panel, .tree-panel, .sidebar {
                scroll-snap-align: start;
                height: 100%;
                min-height: 100%;
                margin-bottom: 0 !important;
                overflow-y: auto;
                flex-shrink: 0;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .study-panel::-webkit-scrollbar,
            .tree-panel::-webkit-scrollbar,
            .sidebar::-webkit-scrollbar {
                display: none;
            }

            .sidebar {
                order: 2;
            }


            .scroll-arrow {
                display: none !important;
            }
            .app-header h1 { font-size: 1.5rem; }
        }

        @media (min-width: 1025px) {
            html, body {
                overflow-x: hidden;
                height: auto;
                overflow-y: auto;
            }
             .app-wrapper {
                min-height: 100vh;
                height: auto;
                padding: 0.75rem;
                overflow: visible;
            }
            .main-content-area {
                flex-direction: row;
                align-items: flex-start;
                gap: 1.5rem;
                overflow: visible;
                scroll-snap-type: none;
            }
            .sidebar {
                width: 380px;
                flex-shrink: 0;
                margin-bottom: 0;
                position: sticky;
                top: 1rem;
                align-self: flex-start;
                max-height: calc(100vh - 2rem);
                overflow-y: auto;
                height: auto;
                min-height: auto;
                scroll-snap-align: unset;
            }
            .content-wrapper-main {
                flex-grow: 1;
                flex-direction: row;
                gap: 1.5rem;
                display: flex;
            }
            .study-panel {
                flex-basis: 45%;
                flex-grow: 1;
                margin-bottom: 0;
                height: auto;
                min-height: auto;
                overflow-y: visible;
                scroll-snap-align: unset;
                flex-shrink: 1;
            }
            .tree-panel {
                flex-basis: 55%;
                flex-grow: 1;
                margin-bottom: 0;
                height: auto;
                min-height: auto;
                overflow-y: visible;
                scroll-snap-align: unset;
                flex-shrink: 1;
            }
            .scroll-arrow { display: none !important; }
        }
        .sidebar-section .button-group.grid-cols-2 {
            grid-template-columns: repeat(2, minmax(0, 1fr));
            display: grid;
        }

    </style>

     <script async src="https://www.googletagmanager.com/gtag/js?id=G-H1P5HZZZYT"></script>
    <script>
     window.dataLayer = window.dataLayer || [];
     function gtag(){dataLayer.push(arguments);}
     gtag('js', new Date());

     gtag('config', 'G-H1P5HZZZYT');
    </script>
</head>
<body>
    <main class="app-wrapper">
        <header class="app-header">
            <h1>Aprende Inglés Fácil con Flashcards Interactivas</h1>
        </header>

        <div class="main-content-area">
            <aside class="sidebar">
                <h2 class="column-title">Panel de Control</h2>

                <section class="sidebar-section" aria-label="Recursos y Tienda">
                    <h3 class="section-title text-[var(--duo-green)]">Recursos y Acciones</h3>
                    <div class="stats-grid sidebar-stats">
                        <div class="stat-item">
                            <h3>Puntos</h3>
                            <p id="score">0</p>
                        </div>
                        <div class="stat-item">
                            <h3>Fertilizante</h3>
                            <p id="fertilizer-count">0</p>
                        </div>
                        <div class="stat-item">
                            <h3>Manzanas</h3>
                            <p id="apples-count">0 🍎</p>
                        </div>
                    </div>
                    <div class="button-group mt-2 grid grid-cols-2 gap-2"> <button id="open-shop-btn" class="btn btn-tertiary w-full">Tienda</button>
                        <button id="open-decks-modal-btn" class="btn btn-secondary w-full">Mazos</button> </div>
                </section>


                <section class="sidebar-section" aria-label="Gestión de progreso general">
                    <h3 class="section-title text-[var(--duo-blue)]">Progreso General</h3>
                    <div class="button-group">
                         <button id="export-progress-btn" class="btn btn-tertiary">Exportar</button>
                         <button id="import-progress-btn" class="btn btn-tertiary">Importar</button>
                         <button id="download-words-btn" class="btn btn-tertiary">Descargar Palabras</button>
                         <input type="file" id="import-progress-input" accept=".json, .enc">
                    </div>
                    <div id="import-export-feedback" class="feedback text-center mt-1.5"></div>
                </section>
            </aside>

            <div class="content-wrapper-main">
                <section class="study-panel">
                    <h2 class="column-title">Panel de Estudio</h2>
                    <div class="text-center mb-2">
                        <span class="text-sm font-semibold text-[var(--duo-gray-dark)]">Mazo Activo: </span>
                        <span id="active-deck-display-study-panel" class="text-sm font-bold text-[var(--duo-blue)]">Ninguno</span>
                    </div>
                    <section id="flashcard-section" aria-labelledby="flashcard-title">
                        <div class="flashcard">
                            <div class="question-container">
                                <p id="question-text"></p>
                                <button id="speaker-icon-button" class="hidden" title="Escuchar palabra">🔊</button>
                            </div>
                        </div>
                        <input type="text" id="answer-input" class="input-field mx-auto block hidden" placeholder="Escribe la traducción...">
                        <div id="multiple-choice-options" class="mt-3 space-y-2 w-full max-w-sm mx-auto"></div>
                        <div id="feedback-text" class="feedback text-center"></div>
                        <div class="flex justify-center space-x-2 mt-1.5 button-group">
                            <button id="check-answer-btn" class="btn btn-primary hidden">Revisar</button>
                            <button id="learned-btn" class="btn btn-learned hidden">¡Lo sé!</button>
                            <button id="next-card-btn" class="btn btn-secondary hidden">Siguiente</button>
                        </div>
                    </section>
                    <section class="sidebar-section" aria-label="Gestión de palabras">
                        <h3 class="section-title text-[var(--duo-blue)]">Gestionar Palabras (Mazo Activo)</h3>
                        <div class="button-group">
                             <button id="show-add-card-modal-btn" class="btn btn-primary ">Añadir</button>
                             <button id="show-delete-card-modal-btn" class="btn btn-danger">Eliminar</button>
                             <button id="show-review-learned-modal-btn" class="btn btn-secondary">Ver Aprendidas</button>
                        </div>
                    </section>
                </section>

                <section class="tree-panel">
                     <h2 class="column-title">Tu Árbol de Palabras</h2>
                     <section id="tree-section" class="text-center flex flex-col flex-grow tree-section-container" aria-label="Progreso del Árbol de Palabras">
                        <div id="tree-display" class="tree-display"></div>
                        <p id="tree-level-text">Nivel: Semilla</p>
                        <div class="mt-2 button-group">
                            <button id="use-fertilizer-btn" class="btn btn-secondary w-full sm:w-auto">Usar Fertilizante</button>
                        </div>
                        <div class="stats-grid tree-panel-stats mt-3" aria-label="Estadísticas de producción del árbol">
                            <div class="stat-item">
                                <h3>Producción</h3>
                                <p id="apples-per-day" class="text-xs sm:text-sm">0 / día</p>
                            </div>
                            <div class="stat-item">
                                <h3>Próximas 🍎</h3>
                                <p id="apple-countdown" class="text-xs sm:text-sm">--:--:--</p>
                            </div>
                        </div>
                    </section>
                </section>
            </div>
        </div>

        <button id="scroll-left-btn" class="scroll-arrow left hidden" aria-label="Desplazar a la izquierda">«</button>
        <button id="scroll-right-btn" class="scroll-arrow right hidden" aria-label="Desplazar a la derecha">»</button>
    </main>

    <div id="add-card-modal" class="modal hidden" role="dialog" aria-labelledby="addCardModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="addCardModalTitle">Nueva Palabra (al mazo activo)</h3>
            <label for="new-question">Palabra en Inglés:</label>
            <input type="text" id="new-question" class="input-field w-full" placeholder="Ej: Hello">
            <label for="new-answer">Traducción al Español:</label>
            <input type="text" id="new-answer" class="input-field w-full" placeholder="Ej: Hola">
            <div id="add-card-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="save-card-btn" class="btn btn-primary btn-sm">Guardar</button>
                <button id="cancel-add-card-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="delete-card-modal" class="modal hidden" role="dialog" aria-labelledby="deleteCardModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="deleteCardModalTitle">Eliminar Palabra (del mazo activo)</h3>
            <div class="flex justify-end mb-1">
                 <button id="select-all-delete-btn" class="btn btn-secondary btn-sm !py-1 !px-2 !text-xs hidden">Seleccionar Todas</button>
            </div>
            <div id="delete-card-list-container" class="my-2 max-h-48 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md">
                <p id="no-cards-to-delete-msg" class="text-[var(--duo-gray-dark)] text-sm hidden">No hay palabras para eliminar en el mazo activo.</p>
            </div>
            <div id="delete-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="confirm-delete-card-btn" class="btn btn-danger btn-sm">Eliminar</button>
                <button id="cancel-delete-card-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="review-learned-modal" class="modal hidden" role="dialog" aria-labelledby="reviewLearnedModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="reviewLearnedModalTitle">Palabras Aprendidas (Global)</h3>
            <div id="review-learned-list-container" class="my-2 max-h-52 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md">
                 <p id="no-learned-cards-msg" class="text-[var(--duo-gray-dark)] text-sm hidden">Aún no has marcado ninguna palabra como aprendida.</p>
            </div>
            <div id="review-modal-feedback" class="feedback text-center"></div>
            <div class="flex justify-end mt-3">
                <button id="close-review-learned-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="shop-modal" class="modal hidden" role="dialog" aria-labelledby="shopModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="shopModalTitle">Tienda del Árbol</h3>
            <div id="shop-feedback" class="feedback text-center"></div>
            <div class="space-y-2 my-3">
                <div class="p-2.5 border border-[var(--duo-gray-light)] rounded-lg bg-[var(--duo-gray-lightest)]">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="font-semibold text-sm text-[var(--duo-text-dark)]">Fertilizante</h4>
                            <p class="text-xs text-[var(--duo-gray-dark)]">Costo: <span id="fertilizer-shop-cost-display">10</span> Puntos ✨</p>
                        </div>
                        <button id="buy-fertilizer-shop-btn" class="btn btn-primary btn-sm">Comprar</button>
                    </div>
                </div>
                 <div class="p-2.5 border border-[var(--duo-gray-light)] rounded-lg bg-[var(--duo-gray-lightest)]">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="font-semibold text-sm text-[var(--duo-text-dark)]">1 Manzana 🍎</h4>
                            <p class="text-xs text-[var(--duo-gray-dark)]">Costo: <span id="apple-shop-cost-display">1000</span> Puntos</p>
                        </div>
                        <button id="buy-apple-shop-btn" class="btn btn-primary btn-sm">Comprar</button>
                    </div>
                </div>
                <h4 class="text-md font-semibold text-[var(--duo-text-dark)] pt-3 mt-3 border-t border-[var(--duo-gray-light)]">Mazos de Palabras (Tienda)</h4>
                <div id="shop-decks-container" class="space-y-2">
                    <p id="loading-decks-msg" class="text-sm text-center text-[var(--duo-gray-dark)]">Cargando mazos disponibles...</p>
                </div>
            </div>
            <div class="flex justify-end mt-3">
                <button id="close-shop-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar Tienda</button>
            </div>
        </div>
    </div>

    <div id="decks-modal" class="modal hidden" role="dialog" aria-labelledby="decksModalTitle" aria-modal="true">
        <div class="modal-content max-w-2xl"> <h3 id="decksModalTitle" class="text-lg font-bold">Mis Mazos</h3>

            <div class="my-4 flex flex-wrap gap-2">
                <button id="open-add-new-deck-modal-btn" class="btn btn-primary btn-sm">Crear Nuevo Mazo</button>
                <button id="open-ai-deck-modal-btn" class="btn btn-ai btn-sm">✨ Generar Mazo con IA</button>
                <button id="select-main-deck-btn" class="btn btn-secondary btn-sm">Estudiar Mazo Principal (Todas)</button>
            </div>

            <p class="text-sm text-gray-600 mb-1">Mazo activo para estudiar:
                <strong id="active-deck-name-modal-display" class="text-[var(--duo-blue)]">Ninguno</strong>
            </p>

            <div id="decks-list-container" class="my-3 max-h-72 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md bg-white">
                <p id="no-user-decks-msg" class="text-[var(--duo-gray-dark)] text-sm p-2">No tienes mazos creados. ¡Crea uno para empezar!</p>
            </div>

            <div id="deck-management-feedback" class="feedback text-center mt-2"></div>

            <div class="flex justify-end space-x-2 mt-6">
                <button id="close-decks-modal-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="add-edit-deck-name-modal" class="modal hidden" role="dialog" aria-labelledby="addEditDeckNameModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="addEditDeckNameModalTitle">Crear Nuevo Mazo</h3>
            <label for="deck-name-input">Nombre del Mazo:</label>
            <input type="text" id="deck-name-input" class="input-field w-full" placeholder="Ej: Verbos Comunes">
            <input type="hidden" id="editing-deck-id-input">
            <div id="add-edit-deck-name-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="save-deck-name-btn" class="btn btn-primary btn-sm">Guardar</button>
                <button id="cancel-add-edit-deck-name-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="ai-deck-modal" class="modal hidden" role="dialog" aria-labelledby="aiDeckModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="aiDeckModalTitle">Generar Mazo con IA ✨</h3>
            <label for="ai-deck-topic-input">Tema para el nuevo mazo (ej: "frutas", "animales de granja"):</label>
            <input type="text" id="ai-deck-topic-input" class="input-field w-full" placeholder="Escribe el tema aquí...">
            
            <label for="ai-deck-name-input" class="mt-2">Nombre para el nuevo mazo (opcional, se generará si se deja vacío):</label>
            <input type="text" id="ai-deck-name-input" class="input-field w-full" placeholder="Ej: Mazo de Frutas (IA)">

            <div id="ai-deck-feedback" class="feedback text-center"></div>
            <div id="ai-loading-indicator" class="loading-spinner hidden my-3"></div>

            <div class="flex justify-end space-x-2 mt-3">
                <button id="generate-ai-deck-btn" class="btn btn-ai btn-sm">Generar Mazo</button>
                <button id="cancel-ai-deck-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>


    <audio id="correct-sound" src="sounds/correct-sound.mp3" preload="auto"></audio>
    <audio id="incorrect-sound" src="sounds/incorrect-sound.mp3" preload="auto"></audio>

    <script>
        // --- Game State Variables ---
        let userDecks = [];
        let activeDeckId = null;
        let currentStudyCards = [];
        let learnedFlashcards = [];
        let currentCardIndex = 0;
        let score = 0;
        let fertilizerCount = 0;
        let treeLevel = 0;
        let applesCount = 0;
        let applesPerDay = 0;
        let lastAppleGenerationTime = Date.now();
        let appleCountdownInterval = null;
        let shopDecksData = {};
        let pointsThisHour = 0;
        let lastPointResetTime = Date.now();

        // --- Game Constants ---
        const POINTS_PER_CORRECT_ANSWER = 10;
        const POINTS_FOR_LEARNED_WORD = 20;
        const DEFAULT_FLASHCARDS_DATA = [
            { question: "Hello", answer: "Hola" }, { question: "Goodbye", answer: "Adiós" },
            { question: "Thank you", answer: "Gracias" }, { question: "Please", answer: "Por favor" },
            { question: "Yes", answer: "Sí" }, { question: "No", answer: "No" },
            { question: "Friend", answer: "Amigo" }, { question: "Love", answer: "Amor" }
        ];
        const MAIN_DECK_ID = '__main_all_decks__';
        const CHECK_APPLES_INTERVAL = 60 * 1000; // 1 minute
        const FERTILIZER_SHOP_COST = 50;
        const APPLE_SHOP_COST = 500;
        const TREE_LEVEL_DATA = [
            { name: 'Semilla',         gifName: 'gif_1.gif', fertilizerToNext: 5,   applesPerDay: 0 },
            { name: 'Brote',           gifName: 'gif_2.gif', fertilizerToNext: 10,  applesPerDay: 0 },
            { name: 'Árbol Pequeño',   gifName: 'gif_3.gif', fertilizerToNext: 20,  applesPerDay: 1 },
            { name: 'Árbol Mediano',   gifName: 'gif_4.gif', fertilizerToNext: 40,  applesPerDay: 2 },
            { name: 'Árbol Mìstico',    gifName: 'gif_5.gif', fertilizerToNext: 80,  applesPerDay: 4 },
            { name: 'Árbol Divino',   gifName: 'gif_6.gif', fertilizerToNext: 160, applesPerDay: 8 }
        ];
        const MAX_TREE_LEVEL_INDEX = TREE_LEVEL_DATA.length - 1;
        const SHOP_DECK_DEFINITIONS = [
            { id: "basic_verbs_pack", fileName: "decks/deck_basic_verbs.json" },
            { id: "birds_pack", fileName: "decks/birds.json" },
            { id: "body_parts_pack", fileName: "decks/body.json" },
            { id: "basic_verbs_past_pack", fileName: "decks/deck_basic_verbs_past.json" },
            { id: "fruits_vegetables_pack", fileName: "decks/fruit.json" },
            { id: "land_animals_pack", fileName: "decks/land_animals.json" },
            { id: "marine_animals_pack", fileName: "decks/marine_animals.json" }
        ];
        const ENCRYPTION_KEY_STRING = "miClaveSuperSecreta1234567890!"; // 32 bytes for AES-256
        let cryptoKey;
        const MIN_CARDS_FOR_POINTS = 5;
        const MIN_CARDS_FOR_MULTIPLE_CHOICE = 3; // Min cards in a deck for multiple choice to have enough distractors
        const MAX_POINTS_PER_HOUR = 500;
        const ONE_HOUR_IN_MS = 60 * 60 * 1000;
        

        // --- DOM Elements ---
        const questionTextEl = document.getElementById('question-text');
        const answerInputEl = document.getElementById('answer-input');
        const multipleChoiceOptionsEl = document.getElementById('multiple-choice-options');
        const checkAnswerBtn = document.getElementById('check-answer-btn');
        const learnedBtn = document.getElementById('learned-btn');
        const nextCardBtn = document.getElementById('next-card-btn');
        const feedbackTextEl = document.getElementById('feedback-text');
        const scoreEl = document.getElementById('score');
        const fertilizerCountEl = document.getElementById('fertilizer-count');
        const applesCountEl = document.getElementById('apples-count');
        const treeDisplayEl = document.getElementById('tree-display');
        const treeLevelTextEl = document.getElementById('tree-level-text');
        const useFertilizerBtn = document.getElementById('use-fertilizer-btn');
        const applesPerDayEl = document.getElementById('apples-per-day');
        const appleCountdownEl = document.getElementById('apple-countdown');
        let speakerIconButtonEl = document.getElementById('speaker-icon-button');

        const showAddCardModalBtn = document.getElementById('show-add-card-modal-btn');
        const addCardModal = document.getElementById('add-card-modal');
        const newQuestionInput = document.getElementById('new-question');
        const newAnswerInput = document.getElementById('new-answer');
        const saveCardBtn = document.getElementById('save-card-btn');
        const cancelAddCardBtn = document.getElementById('cancel-add-card-btn');
        const addCardFeedbackEl = document.getElementById('add-card-feedback');

        const showDeleteCardModalBtn = document.getElementById('show-delete-card-modal-btn');
        const deleteCardModal = document.getElementById('delete-card-modal');
        const deleteCardListContainerEl = document.getElementById('delete-card-list-container');
        const noCardsToDeleteMsgEl = document.getElementById('no-cards-to-delete-msg');
        const confirmDeleteCardBtn = document.getElementById('confirm-delete-card-btn');
        const cancelDeleteCardBtn = document.getElementById('cancel-delete-card-btn');
        const deleteFeedbackEl = document.getElementById('delete-feedback');
        const selectAllDeleteBtn = document.getElementById('select-all-delete-btn');

        const showReviewLearnedModalBtn = document.getElementById('show-review-learned-modal-btn');
        const reviewLearnedModal = document.getElementById('review-learned-modal');
        const reviewLearnedListContainerEl = document.getElementById('review-learned-list-container');
        const noLearnedCardsMsgEl = document.getElementById('no-learned-cards-msg');
        const closeReviewLearnedBtn = document.getElementById('close-review-learned-btn');
        const reviewModalFeedbackEl = document.getElementById('review-modal-feedback');

        const openShopBtn = document.getElementById('open-shop-btn');
        const shopModal = document.getElementById('shop-modal');
        const closeShopBtn = document.getElementById('close-shop-btn');
        const buyFertilizerShopBtn = document.getElementById('buy-fertilizer-shop-btn');
        const buyAppleShopBtn = document.getElementById('buy-apple-shop-btn');
        const shopFeedbackEl = document.getElementById('shop-feedback');
        const fertilizerShopCostDisplayEl = document.getElementById('fertilizer-shop-cost-display');
        const appleShopCostDisplayEl = document.getElementById('apple-shop-cost-display');
        const shopDecksContainerEl = document.getElementById('shop-decks-container');
        const loadingDecksMsgEl = document.getElementById('loading-decks-msg');

        const exportProgressBtn = document.getElementById('export-progress-btn');
        const importProgressBtn = document.getElementById('import-progress-btn');
        const importProgressInput = document.getElementById('import-progress-input');
        const importExportFeedbackEl = document.getElementById('import-export-feedback');
        const downloadWordsBtn = document.getElementById('download-words-btn');

        const openDecksModalBtn = document.getElementById('open-decks-modal-btn');
        const decksModal = document.getElementById('decks-modal');
        const closeDecksModalBtn = document.getElementById('close-decks-modal-btn');
        const openAddNewDeckModalBtn = document.getElementById('open-add-new-deck-modal-btn');
        const selectMainDeckBtn = document.getElementById('select-main-deck-btn');
        const decksListContainerEl = document.getElementById('decks-list-container');
        const noUserDecksMsgEl = document.getElementById('no-user-decks-msg');
        const deckManagementFeedbackEl = document.getElementById('deck-management-feedback');
        const activeDeckNameModalDisplayEl = document.getElementById('active-deck-name-modal-display');

        const addEditDeckNameModal = document.getElementById('add-edit-deck-name-modal');
        const addEditDeckNameModalTitleEl = document.getElementById('addEditDeckNameModalTitle');
        const deckNameInputEl = document.getElementById('deck-name-input');
        const editingDeckIdInputEl = document.getElementById('editing-deck-id-input');
        const saveDeckNameBtn = document.getElementById('save-deck-name-btn');
        const cancelAddEditDeckNameBtn = document.getElementById('cancel-add-edit-deck-name-btn');
        const addEditDeckNameFeedbackEl = document.getElementById('add-edit-deck-name-feedback');

        const activeDeckDisplayStudyPanelEl = document.getElementById('active-deck-display-study-panel');

        const correctSound = document.getElementById('correct-sound');
        const incorrectSound = document.getElementById('incorrect-sound');

        // AI Deck Generation Modal Elements
        const openAiDeckModalBtn = document.getElementById('open-ai-deck-modal-btn');
        const aiDeckModal = document.getElementById('ai-deck-modal');
        const aiDeckTopicInputEl = document.getElementById('ai-deck-topic-input');
        const aiDeckNameInputEl = document.getElementById('ai-deck-name-input');
        const aiDeckFeedbackEl = document.getElementById('ai-deck-feedback');
        const aiLoadingIndicatorEl = document.getElementById('ai-loading-indicator');
        const generateAiDeckBtn = document.getElementById('generate-ai-deck-btn');
        const cancelAiDeckBtn = document.getElementById('cancel-ai-deck-btn');


        // --- Utility Functions ---
        function generateUUID() { return crypto.randomUUID(); }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function openModal(modalElement) { modalElement.classList.remove('hidden'); }
        function closeModal(modalElement) { modalElement.classList.add('hidden'); }

        function clearFeedback(element) {
            const baseClass = element.className.split(' ').filter(cls => cls === 'feedback' || cls === 'text-center' || cls.startsWith('mt-') || cls.startsWith('mb-')).join(' ');
            element.textContent = '';
            element.className = baseClass;
        }

        function showTemporaryFeedback(element, message, type = 'info', duration = 3000) {
            clearFeedback(element);
            element.textContent = message;
            element.classList.add(type);

            if (duration > 0) {
                setTimeout(() => {
                    if (element.textContent === message) { // Only clear if the message hasn't changed
                        clearFeedback(element);
                        if (element === feedbackTextEl) updateDefaultFeedbackMessage();
                    }
                }, duration);
            }
        }

        // --- Speech Synthesis Function ---
        let synth = window.speechSynthesis;
        let voices = [];

        function populateVoices() {
            if (!synth) return;
            voices = synth.getVoices();
        }

        if (synth) {
            populateVoices();
            if (synth.onvoiceschanged !== undefined) {
                synth.onvoiceschanged = populateVoices;
            }
        }

        function speakWord(text) {
            if (!synth) {
                console.warn("Speech synthesis not supported.");
                if (speakerIconButtonEl) {
                    speakerIconButtonEl.disabled = true;
                    speakerIconButtonEl.classList.add('hidden');
                }
                return;
            }
            if (!text) {
                console.warn("No text to speak.");
                return;
            }

            if (voices.length === 0) { // Attempt to populate voices again if empty
                populateVoices();
            }

            try {
                synth.cancel(); // Cancel any ongoing speech
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = 'en-US';

                // Try to find a suitable English voice
                const englishVoice = voices.find(voice => voice.lang === 'en-US' && voice.localService) || // Prefer local US English
                                     voices.find(voice => voice.lang.startsWith('en-') && voice.localService) || // Prefer local any English
                                     voices.find(voice => voice.lang === 'en-US') || // Any US English
                                     voices.find(voice => voice.lang.startsWith('en-')); // Any English

                if (englishVoice) {
                    utterance.voice = englishVoice;
                } else {
                    console.warn("No suitable English (en-US or en-*) voice found. Using default.");
                }

                utterance.onstart = () => {
                    if (speakerIconButtonEl) speakerIconButtonEl.disabled = true;
                };
                utterance.onend = () => {
                    if (speakerIconButtonEl && currentStudyCards.length > 0) { // Only re-enable if there's something to speak
                         speakerIconButtonEl.disabled = false;
                    }
                };
                utterance.onerror = (event) => {
                    console.error('SpeechSynthesisUtterance.onerror triggered:', event);
                    showTemporaryFeedback(feedbackTextEl, `Error de audio: ${event.error || 'desconocido'}.`, "incorrect", 4000);
                    if (speakerIconButtonEl) speakerIconButtonEl.disabled = true; // Disable on error
                };
                synth.speak(utterance);
            } catch (e) {
                console.error("Error in speakWord function:", e);
                showTemporaryFeedback(feedbackTextEl, "Error interno en la función de audio.", "incorrect", 3000);
                if (speakerIconButtonEl) speakerIconButtonEl.disabled = true; // Disable on error
            }
        }


        // --- Crypto Functions ---
        async function initCryptoKey() {
            try {
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw", new TextEncoder().encode(ENCRYPTION_KEY_STRING.slice(0, 32)),
                    { name: "PBKDF2" }, false, ["deriveKey"]
                );
                const salt = new TextEncoder().encode("someFixedSaltValueForDecksApp");
                cryptoKey = await window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: salt, iterations: 100000, hash: "SHA-256" },
                    keyMaterial, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
                );
            } catch (error) {
                console.error("Error al inicializar CryptoKey:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error de criptografía al iniciar.", "incorrect", 5000);
                [exportProgressBtn, importProgressBtn].forEach(btn => {
                    btn.disabled = true; btn.classList.add('btn-disabled');
                });
            }
        }

        async function encryptData(plaintext) {
            if (!cryptoKey) {
                showTemporaryFeedback(importExportFeedbackEl, "Error: Clave de encriptación no lista.", "incorrect", 3000); return null;
            }
            try {
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encodedText = new TextEncoder().encode(plaintext);
                const ciphertext = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, cryptoKey, encodedText);
                const ivBase64 = btoa(String.fromCharCode.apply(null, iv));
                const ciphertextBase64 = btoa(String.fromCharCode.apply(null, new Uint8Array(ciphertext)));
                return { iv: ivBase64, ciphertext: ciphertextBase64 };
            } catch (error) {
                console.error("Error encriptando:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error al encriptar datos.", "incorrect", 3000); return null;
            }
        }

        async function decryptData(ciphertextBase64, ivBase64) {
            if (!cryptoKey) {
                showTemporaryFeedback(importExportFeedbackEl, "Error: Clave de decriptación no lista.", "incorrect", 3000); return null;
            }
            try {
                const iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));
                const ciphertext = Uint8Array.from(atob(ciphertextBase64), c => c.charCodeAt(0)).buffer;
                const decryptedBuffer = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, cryptoKey, ciphertext);
                return new TextDecoder().decode(decryptedBuffer);
            } catch (error) {
                console.error("Error desencriptando:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error al desencriptar. ¿Archivo o clave incorrectos?", "incorrect", 4000); return null;
            }
        }

        // --- Data Persistence ---
        function saveGameData() {
            const gameData = {
                userDecks, activeDeckId, learnedFlashcards,
                score, fertilizerCount, treeLevel, applesCount,
                lastAppleGenerationTime, pointsThisHour, lastPointResetTime
            };
            localStorage.setItem('flashcardGameDataWithDecks', JSON.stringify(gameData));
        }

        function loadGameData() {
            const savedData = localStorage.getItem('flashcardGameDataWithDecks');
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    userDecks = parsedData.userDecks || [];
                    activeDeckId = parsedData.activeDeckId || null;
                    learnedFlashcards = parsedData.learnedFlashcards || [];
                    score = parsedData.score || 0;
                    fertilizerCount = parsedData.fertilizerCount || 0;
                    treeLevel = parsedData.treeLevel || 0;
                    applesCount = parsedData.applesCount || 0;
                    lastAppleGenerationTime = parsedData.lastAppleGenerationTime || Date.now();
                    pointsThisHour = parsedData.pointsThisHour || 0;
                    lastPointResetTime = parsedData.lastPointResetTime || Date.now();

                    userDecks.forEach(deck => {
                        if (!Array.isArray(deck.cards)) deck.cards = [];
                        deck.cards = deck.cards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string' && c.question.trim() !== "" && c.answer.trim() !== "");
                    });
                    learnedFlashcards = learnedFlashcards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string' && c.question.trim() !== "" && c.answer.trim() !== "");


                    if (userDecks.length === 0) {
                        const defaultDeck = {
                            id: generateUUID(),
                            name: "Primer Mazo",
                            cards: DEFAULT_FLASHCARDS_DATA.map(c => ({...c}))
                        };
                        userDecks.push(defaultDeck);
                        activeDeckId = defaultDeck.id;
                    } else if (!activeDeckId || !userDecks.find(d => d.id === activeDeckId) && activeDeckId !== MAIN_DECK_ID) {
                        activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                    }
                } catch (e) {
                    console.error("Error parseando datos guardados (con mazos), reseteando a default:", e);
                    resetToDeckDefaults();
                }
            } else {
                resetToDeckDefaults();
            }
            checkHourlyPointLimit();
            updateCurrentStudyCards();
        }

        function resetToDeckDefaults() {
            const defaultDeck = {
                id: generateUUID(),
                name: "Primer Mazo",
                cards: DEFAULT_FLASHCARDS_DATA.map(c => ({...c}))
            };
            userDecks = [defaultDeck];
            activeDeckId = defaultDeck.id;
            learnedFlashcards = [];
            currentStudyCards = defaultDeck.cards.slice();
            currentCardIndex = 0;
            score = 0;
            fertilizerCount = 0;
            treeLevel = 0;
            applesCount = 0;
            lastAppleGenerationTime = Date.now();
            pointsThisHour = 0;
            lastPointResetTime = Date.now();
        }

        // --- Deck Management Logic ---
        function updateCurrentStudyCards() {
            currentStudyCards = [];
            if (activeDeckId === MAIN_DECK_ID) {
                userDecks.forEach(deck => {
                    deck.cards.forEach(card => {
                        currentStudyCards.push({ ...card, originalDeckId: deck.id });
                    });
                });
                if (currentStudyCards.length > 1) shuffleArray(currentStudyCards);
            } else {
                const deck = userDecks.find(d => d.id === activeDeckId);
                if (deck) {
                    currentStudyCards = deck.cards.slice();
                    if (currentStudyCards.length > 1) shuffleArray(currentStudyCards);
                }
            }
            currentCardIndex = 0;
            updateActiveDeckDisplay();
            updateStudyPanelWordManagementButtons();
        }

        function getActiveDeckName() {
            if (activeDeckId === MAIN_DECK_ID) return "Mazo Principal (Todas)";
            const deck = userDecks.find(d => d.id === activeDeckId);
            return deck ? deck.name : "Ninguno Seleccionado";
        }

        function updateActiveDeckDisplay() {
            const name = getActiveDeckName();
            activeDeckDisplayStudyPanelEl.textContent = name;
            activeDeckNameModalDisplayEl.textContent = name;
        }

        function populateDecksListInModal() {
            decksListContainerEl.innerHTML = '';
            if (userDecks.length === 0) {
                noUserDecksMsgEl.classList.remove('hidden');
                return;
            }
            noUserDecksMsgEl.classList.add('hidden');

            userDecks.forEach(deck => {
                const item = document.createElement('div');
                item.className = 'deck-list-item p-3 border rounded-lg mb-2 flex justify-between items-center hover:bg-gray-50 transition-colors';
                if (deck.id === activeDeckId) {
                    item.classList.add('active-deck-item', 'border-green-500', 'bg-green-50');
                }

                item.innerHTML = `
                    <div class="flex-grow">
                        <span class="deck-name font-semibold text-gray-700">${deck.name}</span>
                        <span class="text-xs text-gray-500 ml-2">(${deck.cards.length} palabras)</span>
                    </div>
                    <div class="deck-actions space-x-1">
                        <button class="btn btn-secondary btn-sm select-deck-btn !py-1 !px-2 !text-xs" data-deck-id="${deck.id}">Estudiar</button>
                        <button class="btn btn-tertiary btn-sm edit-deck-name-btn !py-1 !px-2 !text-xs" data-deck-id="${deck.id}" data-deck-name="${deck.name}">Editar Nombre</button>
                        <button class="btn btn-danger btn-sm delete-deck-btn !py-1 !px-2 !text-xs" data-deck-id="${deck.id}">Eliminar</button>
                    </div>
                `;
                decksListContainerEl.appendChild(item);
            });

            decksListContainerEl.querySelectorAll('.select-deck-btn').forEach(btn =>
                btn.addEventListener('click', (e) => handleSelectDeckForStudy(e.target.dataset.deckId))
            );
            decksListContainerEl.querySelectorAll('.edit-deck-name-btn').forEach(btn =>
                btn.addEventListener('click', (e) => handleOpenEditDeckNameModal(e.target.dataset.deckId, e.target.dataset.deckName))
            );
            decksListContainerEl.querySelectorAll('.delete-deck-btn').forEach(btn =>
                btn.addEventListener('click', (e) => handleDeleteDeck(e.target.dataset.deckId))
            );
        }

        function handleOpenAddNewDeckModal() {
            editingDeckIdInputEl.value = '';
            deckNameInputEl.value = '';
            addEditDeckNameModalTitleEl.textContent = 'Crear Nuevo Mazo';
            clearFeedback(addEditDeckNameFeedbackEl);
            openModal(addEditDeckNameModal);
            deckNameInputEl.focus();
        }

        function handleOpenEditDeckNameModal(deckId, currentName) {
            editingDeckIdInputEl.value = deckId;
            deckNameInputEl.value = currentName;
            addEditDeckNameModalTitleEl.textContent = 'Editar Nombre del Mazo';
            clearFeedback(addEditDeckNameFeedbackEl);
            openModal(addEditDeckNameModal);
            deckNameInputEl.focus();
        }

        function handleSaveDeckName() {
            const deckName = deckNameInputEl.value.trim();
            const editingDeckId = editingDeckIdInputEl.value;

            if (!deckName) {
                showTemporaryFeedback(addEditDeckNameFeedbackEl, "El nombre del mazo no puede estar vacío.", "incorrect");
                return;
            }

            if (editingDeckId) {
                const deck = userDecks.find(d => d.id === editingDeckId);
                if (deck) {
                    deck.name = deckName;
                    showTemporaryFeedback(deckManagementFeedbackEl, `Nombre del mazo actualizado a "${deckName}".`, "correct", 2000);
                }
            } else {
                const newDeck = { id: generateUUID(), name: deckName, cards: [] };
                userDecks.push(newDeck);
                showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${deckName}" creado.`, "correct", 2000);
            }
            saveGameData();
            populateDecksListInModal();
            updateActiveDeckDisplay();
            closeModal(addEditDeckNameModal);
        }

        function handleDeleteDeck(deckIdToDelete) {
            const deck = userDecks.find(d => d.id === deckIdToDelete);
            if (!deck) return;

            if (!confirm(`¿Estás seguro de que quieres eliminar el mazo "${deck.name}" y todas sus ${deck.cards.length} palabras? Esta acción no se puede deshacer.`)) {
                return;
            }

            userDecks = userDecks.filter(d => d.id !== deckIdToDelete);

            if (activeDeckId === deckIdToDelete) {
                activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                updateCurrentStudyCards();
                displayCard();
            }

            saveGameData();
            populateDecksListInModal();
            updateActiveDeckDisplay();
            showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${deck.name}" eliminado.`, "correct", 2500);
        }

        function handleSelectDeckForStudy(deckId) {
            activeDeckId = deckId;
            updateCurrentStudyCards();
            displayCard();
            saveGameData();
            populateDecksListInModal();
            updateActiveDeckDisplay();
            showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${getActiveDeckName()}" seleccionado para estudiar.`, "info", 2000);
            closeModal(decksModal);
        }

        function handleSelectMainDeckForStudy() {
            activeDeckId = MAIN_DECK_ID;
            updateCurrentStudyCards();
            displayCard();
            saveGameData();
            populateDecksListInModal();
            updateActiveDeckDisplay();
            showTemporaryFeedback(deckManagementFeedbackEl, `Mazo Principal seleccionado para estudiar.`, "info", 2000);
            closeModal(decksModal);
        }

        // --- Import/Export Progress ---
        async function exportProgress() {
            clearFeedback(importExportFeedbackEl);
            const gameData = {
                userDecks, activeDeckId, learnedFlashcards,
                score, fertilizerCount, treeLevel, applesCount,
                lastAppleGenerationTime,
                pointsThisHour, lastPointResetTime
            };
            const jsonData = JSON.stringify(gameData);
            const encryptedPayload = await encryptData(jsonData);

            if (!encryptedPayload) {
                showTemporaryFeedback(importExportFeedbackEl, "Fallo la encriptación. No se pudo exportar.", "incorrect", 3000);
                return;
            }

            const dataToExport = JSON.stringify(encryptedPayload);
            const blob = new Blob([dataToExport], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "flashcards_progress_encrypted_v2.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showTemporaryFeedback(importExportFeedbackEl, "Progreso exportado y encriptado.", "correct", 3000);
        }

        async function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) {
                showTemporaryFeedback(importExportFeedbackEl, "No se seleccionó archivo.", "info", 3000);
                return;
            }
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const fileContent = e.target.result;
                    const encryptedPayload = JSON.parse(fileContent);

                    if (!encryptedPayload.iv || !encryptedPayload.ciphertext) {
                        throw new Error("Formato de archivo encriptado inválido. Faltan IV o Ciphertext.");
                    }

                    const decryptedJson = await decryptData(encryptedPayload.ciphertext, encryptedPayload.iv);
                    if (!decryptedJson) {
                        return;
                    }

                    const importedData = JSON.parse(decryptedJson);

                    if (typeof importedData.score === 'undefined' || typeof importedData.userDecks === 'undefined') {
                        if (Array.isArray(importedData.flashcards)) {
                            console.warn("Importando datos de formato antiguo (solo flashcards).");
                            userDecks = [{ id: generateUUID(), name: "Mazo Importado (Antiguo)", cards: importedData.flashcards || [] }];
                            activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                            learnedFlashcards = importedData.learnedFlashcards || [];
                            score = 0; fertilizerCount = 0; treeLevel = 0; applesCount = 0;
                            lastAppleGenerationTime = Date.now(); pointsThisHour = 0; lastPointResetTime = Date.now();
                        } else {
                            throw new Error("Datos importados inválidos o corruptos. Estructura no reconocida.");
                        }
                    } else {
                        userDecks = importedData.userDecks || [];
                        activeDeckId = importedData.activeDeckId || (userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID);
                        learnedFlashcards = importedData.learnedFlashcards || [];
                        score = importedData.score || 0;
                        fertilizerCount = importedData.fertilizerCount || 0;
                        treeLevel = importedData.treeLevel || 0;
                        applesCount = importedData.applesCount || 0;
                        lastAppleGenerationTime = importedData.lastAppleGenerationTime || Date.now();
                        pointsThisHour = importedData.pointsThisHour || 0;
                        lastPointResetTime = importedData.lastPointResetTime || Date.now();
                    }

                    userDecks.forEach(deck => {
                        if (!deck.id) deck.id = generateUUID();
                        if (!deck.name) deck.name = "Mazo Importado";
                        if (!Array.isArray(deck.cards)) deck.cards = [];
                        deck.cards = deck.cards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string' && c.question.trim() !== "" && c.answer.trim() !== "");
                    });
                    learnedFlashcards = learnedFlashcards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string' && c.question.trim() !== "" && c.answer.trim() !== "");

                    if (!userDecks.find(d => d.id === activeDeckId) && activeDeckId !== MAIN_DECK_ID) {
                        activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                    }

                    saveGameData();
                    initGameVisuals();
                    showTemporaryFeedback(importExportFeedbackEl, "Progreso importado exitosamente.", "correct", 4000);
                } catch (error) {
                    console.error("Error importando progreso:", error);
                    showTemporaryFeedback(importExportFeedbackEl, `Error al importar: ${error.message}`, "incorrect", 5000);
                } finally {
                    importProgressInput.value = "";
                }
            };
            reader.onerror = () => {
                showTemporaryFeedback(importExportFeedbackEl, "Error al leer el archivo.", "incorrect", 3000);
                importProgressInput.value = "";
            };
            reader.readAsText(file);
        }

        // --- Study Panel Logic (Flashcards) ---
        function displayCard() {
            clearFeedback(feedbackTextEl);
            if (currentStudyCards.length === 0) {
                handleNoCardsInActiveDeckState();
                return;
            }
            if (currentCardIndex >= currentStudyCards.length || currentCardIndex < 0) {
                currentCardIndex = 0;
            }
            const currentCard = currentStudyCards[currentCardIndex];
            const englishWord = currentCard.question;
            questionTextEl.textContent = englishWord;
            answerInputEl.value = "";
            answerInputEl.classList.add('hidden');
            checkAnswerBtn.classList.add('hidden');

            generateAndDisplayOptions();

            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.add('hidden');

            if (speakerIconButtonEl) {
                if (englishWord && synth) {
                    speakerIconButtonEl.classList.remove('hidden');
                    speakerIconButtonEl.disabled = false;

                    const newSpeakerButton = speakerIconButtonEl.cloneNode(true);
                    speakerIconButtonEl.parentNode.replaceChild(newSpeakerButton, speakerIconButtonEl);
                    speakerIconButtonEl = newSpeakerButton;

                    speakerIconButtonEl.classList.remove('hidden');
                    speakerIconButtonEl.disabled = false;
                    speakerIconButtonEl.addEventListener('click', () => speakWord(englishWord));

                    speakWord(englishWord);
                } else {
                    speakerIconButtonEl.classList.add('hidden');
                    speakerIconButtonEl.disabled = true;
                }
            }
            updateDefaultFeedbackMessage();
        }

        function updateDefaultFeedbackMessage() {
            if (currentStudyCards.length === 0) {
                return;
            }
            const activeDeckIsSpecific = activeDeckId && activeDeckId !== MAIN_DECK_ID;
            const currentDeckCardCount = activeDeckIsSpecific ? (userDecks.find(d=>d.id === activeDeckId)?.cards.length || 0) : currentStudyCards.length;

            if (activeDeckIsSpecific && currentDeckCardCount < MIN_CARDS_FOR_POINTS) {
                showTemporaryFeedback(feedbackTextEl, `El mazo activo "${getActiveDeckName()}" tiene ${currentDeckCardCount} palabras. Necesitas al menos ${MIN_CARDS_FOR_POINTS} para ganar puntos.`, "info", 0);
            } else if (activeDeckIsSpecific && currentDeckCardCount < MIN_CARDS_FOR_MULTIPLE_CHOICE) {
                 showTemporaryFeedback(feedbackTextEl, `El mazo activo "${getActiveDeckName()}" tiene ${currentDeckCardCount} palabras. Añade más para tener ${MIN_CARDS_FOR_MULTIPLE_CHOICE} opciones de respuesta.`, "info", 0);
            } else {
                // No specific message, clear any previous non-info message
                if (feedbackTextEl.textContent && !feedbackTextEl.classList.contains('info')) {
                     // clearFeedback(feedbackTextEl); // Avoid clearing if it's a persistent info message
                }
            }
        }


        function handleNoCardsInActiveDeckState() {
            questionTextEl.textContent = `¡No hay palabras en "${getActiveDeckName()}"!`;
            if (activeDeckId !== MAIN_DECK_ID) {
                questionTextEl.textContent += " Añade algunas o selecciona otro mazo.";
            } else {
                 questionTextEl.textContent = "¡No hay palabras en ningún mazo! Crea mazos y añade palabras.";
            }
            multipleChoiceOptionsEl.innerHTML = '';
            answerInputEl.classList.add('hidden');
            checkAnswerBtn.classList.add('hidden');
            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.add('hidden');
            if(speakerIconButtonEl) speakerIconButtonEl.classList.add('hidden');
            showTemporaryFeedback(feedbackTextEl, `Usa 'Añadir Palabra' (si un mazo específico está activo) o gestiona tus mazos.`, "info", 0);
        }

        function generateAndDisplayOptions() {
            multipleChoiceOptionsEl.innerHTML = '';
            if (currentStudyCards.length === 0 || currentCardIndex >= currentStudyCards.length) return;

            const correctAnswer = currentStudyCards[currentCardIndex].answer;
            let options = [correctAnswer];

            let distractorPool = [];
            userDecks.forEach(deck => {
                deck.cards.forEach(card => {
                    if (card.answer.toLowerCase() !== correctAnswer.toLowerCase()) {
                        distractorPool.push(card.answer);
                    }
                });
            });
            learnedFlashcards.forEach(card => {
                 if (card.answer.toLowerCase() !== correctAnswer.toLowerCase()) {
                        distractorPool.push(card.answer);
                    }
            });


            distractorPool = [...new Set(distractorPool)];
            shuffleArray(distractorPool);

            for (let i = 0; i < Math.min(MIN_CARDS_FOR_MULTIPLE_CHOICE - 1, distractorPool.length); i++) {
                options.push(distractorPool[i]);
            }

            shuffleArray(options);
            options.forEach(optionText => {
                const button = document.createElement('button');
                button.classList.add('btn', 'option-btn');
                button.textContent = optionText;
                button.dataset.answer = optionText;
                button.addEventListener('click', handleOptionClick);
                multipleChoiceOptionsEl.appendChild(button);
            });
        }

        function handleOptionClick(event) {
            const clickedButton = event.target;
            const selectedAnswer = clickedButton.dataset.answer;
            const cardBeingStudied = currentStudyCards[currentCardIndex];
            const correctAnswer = cardBeingStudied.answer;

            const optionButtons = multipleChoiceOptionsEl.querySelectorAll('.option-btn');
            optionButtons.forEach(btn => btn.disabled = true);
            nextCardBtn.classList.remove('hidden');

            if (selectedAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                clickedButton.classList.add('selected-correct');
                checkHourlyPointLimit();

                const activeDeckIsSpecific = activeDeckId && activeDeckId !== MAIN_DECK_ID;
                const currentDeckForPointsCheck = activeDeckIsSpecific ? userDecks.find(d=>d.id === activeDeckId) : null;
                const canEarnPoints = (activeDeckId === MAIN_DECK_ID && currentStudyCards.length >= MIN_CARDS_FOR_POINTS) ||
                                      (activeDeckIsSpecific && currentDeckForPointsCheck && currentDeckForPointsCheck.cards.length >= MIN_CARDS_FOR_POINTS);

                if (!canEarnPoints) {
                    showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 Pero el mazo activo necesita al menos ${MIN_CARDS_FOR_POINTS} palabras para ganar puntos.`, "info", 4000);
                } else if (pointsThisHour >= MAX_POINTS_PER_HOUR) {
                    showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 Has alcanzado el límite de ${MAX_POINTS_PER_HOUR} puntos esta hora. Intenta más tarde.`, "info", 4000);
                } else {
                    const pointsToAdd = POINTS_PER_CORRECT_ANSWER;
                    let actualPointsAdded = pointsToAdd;
                    if (pointsThisHour + pointsToAdd > MAX_POINTS_PER_HOUR) {
                        actualPointsAdded = MAX_POINTS_PER_HOUR - pointsThisHour;
                        showTemporaryFeedback(feedbackTextEl, `¡Correcto!  +${actualPointsAdded} puntos. (Límite horario alcanzado)`, "correct", 3000);
                    } else {
                        showTemporaryFeedback(feedbackTextEl, "¡Correcto! 🎉", "correct", 2000);
                    }
                    score += actualPointsAdded;
                    pointsThisHour += actualPointsAdded;
                    updateScoreDisplay();
                }
                learnedBtn.classList.remove('hidden');
                if (correctSound) { correctSound.currentTime = 0; correctSound.play().catch(console.error); }
            } else {
                clickedButton.classList.add('selected-incorrect');
                optionButtons.forEach(btn => {
                    if (btn.dataset.answer.toLowerCase() === correctAnswer.toLowerCase()) {
                        btn.classList.add('actual-correct');
                    }
                });
                const pointsToDeduct = Math.floor(POINTS_PER_CORRECT_ANSWER / 2);
                score -= pointsToDeduct;
                if (score < 0) score = 0;
                updateScoreDisplay();
                showTemporaryFeedback(feedbackTextEl, `Incorrecto. Respuesta correcta: ${correctAnswer}. Has perdido ${pointsToDeduct} puntos. 📉`, "incorrect", 3500);
                learnedBtn.classList.add('hidden');
                if (incorrectSound) { incorrectSound.currentTime = 0; incorrectSound.play().catch(console.error); }
            }
            nextCardBtn.focus();
            saveGameData();
        }

        function markAsLearned() {
            if (currentStudyCards.length === 0 || currentCardIndex >= currentStudyCards.length) return;

            const cardToLearn = { ...currentStudyCards[currentCardIndex] };
            let feedbackMessage = "";

            if (learnedFlashcards.findIndex(card => card.question.toLowerCase() === cardToLearn.question.toLowerCase()) === -1) {
                learnedFlashcards.push({ question: cardToLearn.question, answer: cardToLearn.answer });

                let originalDeckIdToRemoveFrom = null;
                if (activeDeckId === MAIN_DECK_ID && cardToLearn.originalDeckId) {
                    originalDeckIdToRemoveFrom = cardToLearn.originalDeckId;
                } else if (activeDeckId !== MAIN_DECK_ID) {
                    originalDeckIdToRemoveFrom = activeDeckId;
                }

                if (originalDeckIdToRemoveFrom) {
                    const deck = userDecks.find(d => d.id === originalDeckIdToRemoveFrom);
                    if (deck) {
                        deck.cards = deck.cards.filter(c => c.question.toLowerCase() !== cardToLearn.question.toLowerCase());
                    }
                }

                checkHourlyPointLimit();
                const activeDeckIsSpecific = activeDeckId && activeDeckId !== MAIN_DECK_ID;
                const deckWhereCardWas = originalDeckIdToRemoveFrom ? userDecks.find(d=>d.id === originalDeckIdToRemoveFrom) : null;
                const canEarnPointsForLearning = (activeDeckId === MAIN_DECK_ID && currentStudyCards.length >= MIN_CARDS_FOR_POINTS) ||
                                                 (deckWhereCardWas && deckWhereCardWas.cards.length + 1 >= MIN_CARDS_FOR_POINTS);


                if (!canEarnPointsForLearning) {
                     feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. El mazo original necesita ${MIN_CARDS_FOR_POINTS} palabras para ganar puntos por aprender.`;
                } else if (pointsThisHour >= MAX_POINTS_PER_HOUR) {
                    feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. Límite de ${MAX_POINTS_PER_HOUR} puntos/hora alcanzado.`;
                } else {
                    const pointsToAdd = POINTS_FOR_LEARNED_WORD;
                    let actualPointsAdded = pointsToAdd;
                    if (pointsThisHour + pointsToAdd > MAX_POINTS_PER_HOUR) {
                        actualPointsAdded = MAX_POINTS_PER_HOUR - pointsThisHour;
                        feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. +${actualPointsAdded} pts! (Límite horario alcanzado)`;
                    } else {
                         feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. +${actualPointsAdded} pts!`;
                    }
                    score += actualPointsAdded;
                    pointsThisHour += actualPointsAdded;
                    updateScoreDisplay();
                }
                showTemporaryFeedback(feedbackTextEl, feedbackMessage, "info", 3500);
            } else {
                showTemporaryFeedback(feedbackTextEl, `"${cardToLearn.question}" ya estaba marcada como aprendida.`, "info", 2500);
            }

            currentStudyCards.splice(currentCardIndex, 1);

            saveGameData();
            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.remove('hidden');
            nextCardBtn.focus();

            if (currentStudyCards.length === 0) {
                handleNoCardsInActiveDeckState();
            } else {
                if (currentCardIndex >= currentStudyCards.length) {
                    currentCardIndex = 0;
                }
                displayCard();
            }
            updateStudyPanelWordManagementButtons();
            populateDecksListInModal();
        }


        function moveToNextCard() {
            if (currentStudyCards.length === 0) {
                handleNoCardsInActiveDeckState();
                return;
            }
            currentCardIndex++;
            if (currentCardIndex >= currentStudyCards.length) {
                currentCardIndex = 0;
                updateCurrentStudyCards();
                if (currentStudyCards.length > 0 && (!feedbackTextEl.textContent || !feedbackTextEl.classList.contains('info'))) {
                     showTemporaryFeedback(feedbackTextEl, "¡Mazo barajado para la siguiente ronda!", "info", 1500);
                }
            }
            displayCard();
        }

        function checkHourlyPointLimit() {
            const now = Date.now();
            if (now - lastPointResetTime >= ONE_HOUR_IN_MS) {
                pointsThisHour = 0;
                lastPointResetTime = now;
                saveGameData();
            }
        }

        // --- UI Updates for Stats ---
        function updateScoreDisplay() { scoreEl.textContent = score; }
        function updateFertilizerCountDisplay() {
            fertilizerCountEl.textContent = fertilizerCount;
            const currentLevelData = TREE_LEVEL_DATA[treeLevel];
            useFertilizerBtn.disabled = treeLevel >= MAX_TREE_LEVEL_INDEX ||
                                       (treeLevel < MAX_TREE_LEVEL_INDEX && fertilizerCount < currentLevelData.fertilizerToNext);
            useFertilizerBtn.classList.toggle('btn-disabled', useFertilizerBtn.disabled);
        }
        function updateApplesCountDisplay() { applesCountEl.textContent = `${applesCount} 🍎`; }
        function updateApplesPerDayDisplay() { applesPerDayEl.textContent = `${applesPerDay} / día`; }

        function updateTreeVisual() {
            const currentLevelData = TREE_LEVEL_DATA[treeLevel];
            const gifPath = `gifs/${currentLevelData.gifName}`;
            treeDisplayEl.innerHTML = `<img src="${gifPath}" alt="Árbol de progreso: Nivel ${currentLevelData.name}" class="tree-gif mx-auto">`;
            treeLevelTextEl.textContent = `Nivel: ${currentLevelData.name}`;
            applesPerDay = currentLevelData.applesPerDay;
            updateApplesPerDayDisplay();
            if (treeLevel >= MAX_TREE_LEVEL_INDEX) {
                useFertilizerBtn.textContent = "¡Árbol Maximizado!";
                useFertilizerBtn.disabled = true;
            } else {
                useFertilizerBtn.textContent = `Crecer (${currentLevelData.fertilizerToNext} Fert.)`;
                useFertilizerBtn.disabled = fertilizerCount < currentLevelData.fertilizerToNext;
            }
            useFertilizerBtn.classList.toggle('btn-disabled', useFertilizerBtn.disabled);
        }

        function growTree() {
            if (treeLevel >= MAX_TREE_LEVEL_INDEX) {
                showTemporaryFeedback(feedbackTextEl, "Tu árbol ya está en el nivel máximo.", "info", 2500);
                return;
            }
            const requiredFertilizer = TREE_LEVEL_DATA[treeLevel].fertilizerToNext;
            if (fertilizerCount >= requiredFertilizer) {
                fertilizerCount -= requiredFertilizer;
                treeLevel++;
                updateTreeVisual();
                updateFertilizerCountDisplay();
                showTemporaryFeedback(feedbackTextEl, `¡Tu árbol creció a ${TREE_LEVEL_DATA[treeLevel].name}!`, "correct", 2500);
                treeDisplayEl.style.transform = 'scale(1.15)';
                setTimeout(() => { treeDisplayEl.style.transform = 'scale(1)'; }, 300);
                saveGameData();
            } else {
                 showTemporaryFeedback(feedbackTextEl, `Necesitas ${requiredFertilizer - fertilizerCount} más fertilizante.`, "info", 3000);
            }
        }

        // --- Apple Generation ---
        function checkAndGenerateApples() {
            if (applesPerDay <= 0) {
                updateAppleCountdown(); return;
            }
            const now = Date.now();
            const timeElapsedMs = now - lastAppleGenerationTime;
            const generationIntervalMs = ((24 * 60 * 60) / applesPerDay) * 1000;

            if (timeElapsedMs >= generationIntervalMs) {
                const applesToGenerate = Math.floor(timeElapsedMs / generationIntervalMs);
                applesCount += applesToGenerate;
                lastAppleGenerationTime += applesToGenerate * generationIntervalMs;
                updateApplesCountDisplay();
                showTemporaryFeedback(feedbackTextEl, `¡Cosechaste ${applesToGenerate} manzana(s) 🍎!`, "correct", 2000);
                saveGameData();
            }
            updateAppleCountdown();
        }

        function updateAppleCountdown() {
            if (appleCountdownInterval) clearInterval(appleCountdownInterval);
            if (applesPerDay <= 0) {
                appleCountdownEl.textContent = "--:--:--"; return;
            }

            function calculateAndDisplayCountdown() {
                const now = Date.now();
                const generationIntervalMs = ((24 * 60 * 60) / applesPerDay) * 1000;
                const timeSinceLastApple = now - lastAppleGenerationTime;

                if (timeSinceLastApple >= generationIntervalMs && applesPerDay > 0) {
                    checkAndGenerateApples();
                    const newTimeSinceLastApple = now - lastAppleGenerationTime;
                    let timeToNextAppleMs = generationIntervalMs - (newTimeSinceLastApple % generationIntervalMs);
                    if (timeToNextAppleMs <= 0) timeToNextAppleMs = generationIntervalMs;

                    displayTime(timeToNextAppleMs);
                    return;
                }

                let timeToNextAppleMs = generationIntervalMs - (timeSinceLastApple % generationIntervalMs);

                if (timeToNextAppleMs <= 1000 && timeToNextAppleMs > 0) {
                     appleCountdownEl.textContent = "¡Ahora!"; return;
                }
                if (timeToNextAppleMs <= 0) timeToNextAppleMs = generationIntervalMs;

                displayTime(timeToNextAppleMs);
            }

            function displayTime(ms) {
                const h = String(Math.floor((ms / (1000 * 60 * 60)) % 24)).padStart(2, '0');
                const m = String(Math.floor((ms / (1000 * 60)) % 60)).padStart(2, '0');
                const s = String(Math.floor((ms / 1000) % 60)).padStart(2, '0');
                appleCountdownEl.textContent = `${h}:${m}:${s}`;
            }

            calculateAndDisplayCountdown();
            appleCountdownInterval = setInterval(calculateAndDisplayCountdown, 1000);
        }

        // --- Word Management in Study Panel ---
        function updateStudyPanelWordManagementButtons() {
            const isSpecificDeckActive = activeDeckId && activeDeckId !== MAIN_DECK_ID;
            showAddCardModalBtn.disabled = !isSpecificDeckActive;
            showDeleteCardModalBtn.disabled = !isSpecificDeckActive;

            showAddCardModalBtn.classList.toggle('btn-disabled', !isSpecificDeckActive);
            showDeleteCardModalBtn.classList.toggle('btn-disabled', !isSpecificDeckActive);

            if (!isSpecificDeckActive) {
                addCardModal.querySelector('h3').textContent = "Añadir Palabra (Selecciona un mazo específico)";
                deleteCardModal.querySelector('h3').textContent = "Eliminar Palabra (Selecciona un mazo específico)";
            } else {
                addCardModal.querySelector('h3').textContent = `Nueva Palabra (a "${getActiveDeckName()}")`;
                deleteCardModal.querySelector('h3').textContent = `Eliminar Palabra (de "${getActiveDeckName()}")`;
            }
        }

        showAddCardModalBtn.addEventListener('click', () => {
            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) {
                showTemporaryFeedback(feedbackTextEl, "Selecciona un mazo específico para añadir palabras.", "info", 3000);
                return;
            }
            newQuestionInput.value = ''; newAnswerInput.value = '';
            clearFeedback(addCardFeedbackEl);
            addCardModal.querySelector('h3').textContent = `Nueva Palabra (a "${getActiveDeckName()}")`;
            openModal(addCardModal);
            newQuestionInput.focus();
        });

        cancelAddCardBtn.addEventListener('click', () => closeModal(addCardModal));

        saveCardBtn.addEventListener('click', () => {
            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) {
                showTemporaryFeedback(addCardFeedbackEl, "Error: No hay un mazo específico activo.", "incorrect");
                return;
            }
            const activeDeck = userDecks.find(d => d.id === activeDeckId);
            if (!activeDeck) {
                showTemporaryFeedback(addCardFeedbackEl, "Error: Mazo activo no encontrado.", "incorrect");
                return;
            }

            const newQ = newQuestionInput.value.trim();
            const newA = newAnswerInput.value.trim();
            if (newQ && newA) {
                if (activeDeck.cards.some(c => c.question.toLowerCase() === newQ.toLowerCase())) {
                    showTemporaryFeedback(addCardFeedbackEl, `La palabra "${newQ}" ya existe en el mazo "${activeDeck.name}".`, "incorrect", 2500);
                    return;
                }
                activeDeck.cards.push({ question: newQ, answer: newA });
                updateCurrentStudyCards();
                saveGameData();
                showTemporaryFeedback(addCardFeedbackEl, "¡Palabra añadida con éxito!", "correct", 1500);
                newQuestionInput.value = ''; newAnswerInput.value = '';
                newQuestionInput.focus();

                if (questionTextEl.textContent.startsWith("¡No hay palabras en")) {
                    displayCard();
                }
                updateDefaultFeedbackMessage();
                populateDecksListInModal();
            } else {
                showTemporaryFeedback(addCardFeedbackEl, "Ambos campos son obligatorios.", "incorrect", 2000);
            }
        });

        showDeleteCardModalBtn.addEventListener('click', () => {
            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) {
                showTemporaryFeedback(feedbackTextEl, "Selecciona un mazo específico para eliminar palabras.", "info", 3000);
                return;
            }
            deleteCardModal.querySelector('h3').textContent = `Eliminar Palabra (de "${getActiveDeckName()}")`;
            populateDeleteCardList();
            openModal(deleteCardModal);
        });
        cancelDeleteCardBtn.addEventListener('click', () => closeModal(deleteCardModal));

        function populateDeleteCardList() {
            deleteCardListContainerEl.innerHTML = '';
            clearFeedback(deleteFeedbackEl);
            selectAllDeleteBtn.classList.add('hidden');

            const activeDeck = userDecks.find(d => d.id === activeDeckId);
            if (!activeDeck || activeDeck.cards.length === 0) {
                noCardsToDeleteMsgEl.textContent = `No hay palabras para eliminar en el mazo "${getActiveDeckName()}".`;
                noCardsToDeleteMsgEl.classList.remove('hidden');
                confirmDeleteCardBtn.disabled = true;
                confirmDeleteCardBtn.classList.add('btn-disabled');
                return;
            }

            noCardsToDeleteMsgEl.classList.add('hidden');
            confirmDeleteCardBtn.disabled = false;
            confirmDeleteCardBtn.classList.remove('btn-disabled');
            if (activeDeck.cards.length > 1) selectAllDeleteBtn.classList.remove('hidden');
            selectAllDeleteBtn.textContent = 'Seleccionar Todas';

            activeDeck.cards.sort((a, b) => a.question.localeCompare(b.question)).forEach((card, index) => {
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center p-1.5 hover:bg-gray-50 rounded';
                listItem.innerHTML = `
                    <input type="checkbox" id="delete-card-${index}" value="${card.question}" class="mr-2 rounded border-gray-300 text-[var(--duo-blue)] focus:ring-[var(--duo-blue)] h-4 w-4">
                    <label for="delete-card-${index}" class="flex-grow text-sm text-[var(--duo-text-dark)] cursor-pointer">
                        ${card.question} - ${card.answer}
                    </label>`;
                deleteCardListContainerEl.appendChild(listItem);
            });
        }

        confirmDeleteCardBtn.addEventListener('click', () => {
            const activeDeck = userDecks.find(d => d.id === activeDeckId);
            if (!activeDeck) {
                showTemporaryFeedback(deleteFeedbackEl, "Error: Mazo activo no encontrado.", "incorrect");
                return;
            }

            const checkboxes = deleteCardListContainerEl.querySelectorAll('input[type="checkbox"]:checked');
            if (checkboxes.length === 0) {
                showTemporaryFeedback(deleteFeedbackEl, "Selecciona al menos una palabra para eliminar.", "incorrect", 2500);
                return;
            }
            const questionsToDelete = Array.from(checkboxes).map(cb => cb.value.toLowerCase());

            activeDeck.cards = activeDeck.cards.filter(card => !questionsToDelete.includes(card.question.toLowerCase()));

            updateCurrentStudyCards();
            saveGameData();
            showTemporaryFeedback(deleteFeedbackEl, `${questionsToDelete.length} palabra(s) eliminada(s) de "${activeDeck.name}".`, "correct", 2000);

            if (currentStudyCards.length > 0) {
                if (questionTextEl.textContent && questionsToDelete.includes(questionTextEl.textContent.toLowerCase())) {
                    currentCardIndex = 0;
                }
                displayCard();
            } else {
                handleNoCardsInActiveDeckState();
            }
            populateDeleteCardList();
            updateDefaultFeedbackMessage();
            populateDecksListInModal();
        });

        selectAllDeleteBtn.addEventListener('click', () => {
            const checkboxes = deleteCardListContainerEl.querySelectorAll('input[type="checkbox"]');
            if (checkboxes.length === 0) return;
            const shouldSelectAll = selectAllDeleteBtn.textContent === 'Seleccionar Todas';
            checkboxes.forEach(checkbox => { checkbox.checked = shouldSelectAll; });
            selectAllDeleteBtn.textContent = shouldSelectAll ? 'Deseleccionar Todas' : 'Seleccionar Todas';
        });

        showReviewLearnedModalBtn.addEventListener('click', () => {
            populateReviewLearnedList();
            openModal(reviewLearnedModal);
        });
        closeReviewLearnedBtn.addEventListener('click', () => closeModal(reviewLearnedModal));

        function populateReviewLearnedList() {
            reviewLearnedListContainerEl.innerHTML = '';
            clearFeedback(reviewModalFeedbackEl);
            if (learnedFlashcards.length === 0) {
                noLearnedCardsMsgEl.classList.remove('hidden');
                return;
            }
            noLearnedCardsMsgEl.classList.add('hidden');
            learnedFlashcards.sort((a, b) => a.question.localeCompare(b.question)).forEach((card) => {
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center justify-between p-1.5 hover:bg-gray-50 rounded';
                listItem.innerHTML = `
                    <span class="text-sm text-[var(--duo-text-dark)]">${card.question} - ${card.answer}</span>
                    <button data-question="${card.question}" class="btn btn-danger btn-sm remove-learned-btn !py-1 !px-2 !text-xs">Olvidar</button>`;
                reviewLearnedListContainerEl.appendChild(listItem);
            });
            reviewLearnedListContainerEl.querySelectorAll('.remove-learned-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const questionToForget = e.target.dataset.question;
                    const cardIndexInLearned = learnedFlashcards.findIndex(c => c.question.toLowerCase() === questionToForget.toLowerCase());

                    if (cardIndexInLearned > -1) {
                        const forgottenCard = learnedFlashcards.splice(cardIndexInLearned, 1)[0];

                        let movedToDeckName = null;
                        let targetDeckForReturn = null;

                        if (activeDeckId && activeDeckId !== MAIN_DECK_ID) {
                            targetDeckForReturn = userDecks.find(d => d.id === activeDeckId);
                        } else if (userDecks.length > 0) {
                            targetDeckForReturn = userDecks[0];
                        }

                        if (targetDeckForReturn) {
                            if (!targetDeckForReturn.cards.some(c => c.question.toLowerCase() === forgottenCard.question.toLowerCase())) {
                                targetDeckForReturn.cards.push({ question: forgottenCard.question, answer: forgottenCard.answer });
                                movedToDeckName = targetDeckForReturn.name;
                            } else {
                                console.warn(`Card "${forgottenCard.question}" already in target deck "${targetDeckForReturn.name}" upon 'forgetting'.`);
                            }
                        } else {
                            const newDeck = { id: generateUUID(), name: "Mazo Recuperado", cards: [forgottenCard] };
                            userDecks.push(newDeck);
                            movedToDeckName = newDeck.name;
                            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) activeDeckId = newDeck.id;
                        }

                        updateCurrentStudyCards();
                        saveGameData();
                        populateReviewLearnedList();
                        if (movedToDeckName) {
                            showTemporaryFeedback(reviewModalFeedbackEl, `"${questionToForget}" movida de nuevo al mazo "${movedToDeckName}".`, "info", 2500);
                            populateDecksListInModal();
                        } else {
                             showTemporaryFeedback(reviewModalFeedbackEl, `"${questionToForget}" olvidada. No se pudo añadir a un mazo.`, "info", 2000);
                        }
                        if (currentStudyCards.length > 0 && questionTextEl.textContent.startsWith("¡No hay palabras")) {
                            displayCard();
                        }
                         updateDefaultFeedbackMessage();
                    }
                });
            });
        }

        // --- Shop Logic ---
        openShopBtn.addEventListener('click', () => {
            clearFeedback(shopFeedbackEl);
            updateShopCosts();
            loadShopDecks();
            openModal(shopModal);
        });
        closeShopBtn.addEventListener('click', () => closeModal(shopModal));
        buyFertilizerShopBtn.addEventListener('click', () => {
            if (score >= FERTILIZER_SHOP_COST) {
                score -= FERTILIZER_SHOP_COST;
                fertilizerCount++;
                updateScoreDisplay();
                updateFertilizerCountDisplay();
                saveGameData();
                showTemporaryFeedback(shopFeedbackEl, "¡Fertilizante comprado!", "correct", 2000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, "Puntos insuficientes.", "incorrect", 2000);
            }
        });
        buyAppleShopBtn.addEventListener('click', () => {
            if (score >= APPLE_SHOP_COST) {
                score -= APPLE_SHOP_COST;
                applesCount++;
                updateScoreDisplay();
                updateApplesCountDisplay();
                saveGameData();
                showTemporaryFeedback(shopFeedbackEl, "¡Manzana comprada! 🍎", "correct", 2000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, "Puntos insuficientes.", "incorrect", 2000);
            }
        });
        function updateShopCosts() {
            fertilizerShopCostDisplayEl.textContent = FERTILIZER_SHOP_COST;
            appleShopCostDisplayEl.textContent = APPLE_SHOP_COST;
        }
        async function loadShopDecks() {
            shopDecksContainerEl.innerHTML = '';
            loadingDecksMsgEl.classList.remove('hidden');
            let decksDisplayed = 0;

            for (const deckDef of SHOP_DECK_DEFINITIONS) {
                try {
                    const response = await fetch(deckDef.fileName + `?v=${Date.now()}`);
                    if (!response.ok) throw new Error(`HTTP error ${response.status} for ${deckDef.fileName}`);
                    const deckData = await response.json();
                    shopDecksData[deckDef.id] = deckData;

                    const deckItemEl = document.createElement('div');
                    deckItemEl.className = 'p-2.5 border rounded-lg bg-gray-50';
                    deckItemEl.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="font-semibold text-sm">${deckData.name}</h4>
                                <p class="text-xs text-gray-500">Costo: <span class="deck-cost">${deckData.cost}</span> 🍎 | Palabras: ${deckData.cards.length}</p>
                            </div>
                            <button class="btn btn-primary btn-sm buy-deck-btn !py-1 !px-2 !text-xs" data-deck-id="${deckDef.id}">Comprar</button>
                        </div>`;
                    shopDecksContainerEl.appendChild(deckItemEl);
                    decksDisplayed++;
                } catch (error) {
                    console.error(`Error cargando mazo de tienda ${deckDef.fileName}:`, error);
                }
            }
            loadingDecksMsgEl.classList.add('hidden');
            if (decksDisplayed === 0 && SHOP_DECK_DEFINITIONS.length > 0) {
                 shopDecksContainerEl.innerHTML = '<p class="text-sm text-center text-[var(--duo-gray-dark)]">No se pudieron cargar los mazos de la tienda.</p>';
            }

            shopDecksContainerEl.querySelectorAll('.buy-deck-btn').forEach(button => {
                button.addEventListener('click', (e) => handleBuyShopDeck(e.target.dataset.deckId));
            });
        }

        function handleBuyShopDeck(deckId) {
            const deckDataFromShop = shopDecksData[deckId];
            if (!deckDataFromShop) {
                showTemporaryFeedback(shopFeedbackEl, "Error: Mazo de tienda no encontrado.", "incorrect"); return;
            }
            if (applesCount >= deckDataFromShop.cost) {
                if (userDecks.some(d => d.name.toLowerCase() === deckDataFromShop.name.toLowerCase())) {
                     showTemporaryFeedback(shopFeedbackEl, `Ya tienes un mazo llamado "${deckDataFromShop.name}". Renombra el existente o este no se añadirá.`, "info", 4000);
                     return;
                }

                applesCount -= deckDataFromShop.cost;
                const newDeckFromShop = {
                    id: generateUUID(),
                    name: deckDataFromShop.name,
                    cards: deckDataFromShop.cards.map(c => ({...c}))
                };
                userDecks.push(newDeckFromShop);

                updateApplesCountDisplay();
                saveGameData();
                populateDecksListInModal();
                showTemporaryFeedback(shopFeedbackEl, `¡Mazo "${deckDataFromShop.name}" comprado y añadido a tus mazos!`, "correct", 3000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, `Manzanas insuficientes.`, "incorrect");
            }
        }

        // --- AI Deck Generation Logic ---
        openAiDeckModalBtn.addEventListener('click', () => {
            aiDeckTopicInputEl.value = '';
            aiDeckNameInputEl.value = '';
            clearFeedback(aiDeckFeedbackEl);
            aiLoadingIndicatorEl.classList.add('hidden');
            generateAiDeckBtn.disabled = false;
            openModal(aiDeckModal);
            aiDeckTopicInputEl.focus();
        });

        cancelAiDeckBtn.addEventListener('click', () => closeModal(aiDeckModal));

        generateAiDeckBtn.addEventListener('click', async () => {
            const topic = aiDeckTopicInputEl.value.trim();
            let deckName = aiDeckNameInputEl.value.trim();

            if (!topic) {
                showTemporaryFeedback(aiDeckFeedbackEl, "Por favor, introduce un tema para el mazo.", "incorrect");
                return;
            }

            if (!deckName) {
                deckName = `Mazo IA: ${topic.charAt(0).toUpperCase() + topic.slice(1)}`;
            }
            
            // Check if a deck with the same name already exists
            if (userDecks.some(d => d.name.toLowerCase() === deckName.toLowerCase())) {
                showTemporaryFeedback(aiDeckFeedbackEl, `Ya existe un mazo llamado "${deckName}". Elige otro nombre.`, "incorrect", 4000);
                return;
            }

            clearFeedback(aiDeckFeedbackEl);
            aiLoadingIndicatorEl.classList.remove('hidden');
            generateAiDeckBtn.disabled = true;
            showTemporaryFeedback(aiDeckFeedbackEl, "Generando mazo con IA... Esto puede tardar un momento.", "loading", 0);


            const prompt = `Genera una lista de 10 a 15 pares de palabras para un mazo de flashcards sobre el tema '${topic}'. Cada par debe tener una palabra en inglés ('question') y su traducción al español ('answer'). Devuelve el resultado como un JSON que se ajuste al siguiente esquema. Asegúrate de que las palabras sean relevantes para el tema y variadas.`;
            
            const schema = {
                type: "ARRAY",
                items: {
                    type: "OBJECT",
                    properties: {
                        "question": { "type": "STRING", description: "La palabra o frase corta en Inglés." },
                        "answer": { "type": "STRING", description: "La traducción al Español." }
                    },
                    required: ["question", "answer"]
                }
            };

            let chatHistory = [{ role: "user", parts: [{ text: prompt }] }];
            const payload = {
                contents: chatHistory,
                generationConfig: {
                    responseMimeType: "application/json",
                    responseSchema: schema
                }
            };
            
          // ... (código anterior en la función generateAiDeckBtn) ...
// const apiKey = GEMINI_API_KEY; // Ya no se necesita aquí
const netlifyFunctionUrl = `/.netlify/functions/generate-ai-deck`; // URL de tu función

// El payload para tu función de Netlify solo necesita los datos que la función espera
const functionPayload = {
    topic: topic,
    wordCount: wordCount,
    deckName: deckName // Si tu función lo usa, si no, puedes omitirlo del payload a la función
};

try {
    const response = await fetch(netlifyFunctionUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(functionPayload) // Envía el topic, wordCount, etc. a tu función
    });

    // El resto del manejo de la respuesta de la función es similar,
    // ya que la función de Netlify debería devolver la respuesta de Gemini (o un error).
    if (!response.ok) {
        const errorBody = await response.json(); // Error de tu Netlify Function
        console.error("Netlify Function Error Response:", errorBody);
        let errorMessage = `Error llamando a la función: ${response.status}`;
        if (errorBody && errorBody.error) {
            errorMessage += ` - ${errorBody.error}`;
        }
        throw new Error(errorMessage);
    }

    const result = await response.json(); // Esto ahora es la respuesta de tu Netlify Function, que contiene la respuesta de Gemini

    // El resto de la lógica para procesar `result.candidates` sigue igual
    if (result.candidates && result.candidates.length > 0 &&
        result.candidates[0].content && result.candidates[0].content.parts &&
        result.candidates[0].content.parts.length > 0) {

        const jsonText = result.candidates[0].content.parts[0].text;
        // ... resto de tu lógica para crear el mazo ...
    } else if (result.error) { // Si la función de Netlify devolvió un error estructurado de Gemini
         console.error("Error desde la API de Gemini (vía Netlify Function):", result.error);
         throw new Error(`Error de la API de Gemini: ${result.error}`);
    }
     else {
         console.error("Netlify Function Unexpected Response Structure:", result);
        throw new Error("Respuesta inesperada de la función de IA. No se encontraron 'candidates' o 'parts'.");
    }
// ... (resto del try-catch) ...

                if (!response.ok) {
                    const errorBody = await response.json();
                    console.error("Gemini API Error Response:", errorBody);
                    let errorMessage = `Error de la API: ${response.status}`;
                    if (errorBody && errorBody.error && errorBody.error.message) {
                        errorMessage += ` - ${errorBody.error.message}`;
                    }
                    throw new Error(errorMessage);
                }

                const result = await response.json();

                if (result.candidates && result.candidates.length > 0 &&
                    result.candidates[0].content && result.candidates[0].content.parts &&
                    result.candidates[0].content.parts.length > 0) {
                    
                    const jsonText = result.candidates[0].content.parts[0].text;
                    const generatedCards = JSON.parse(jsonText); // This should be an array of {question, answer}

                    if (Array.isArray(generatedCards) && generatedCards.length > 0) {
                        const newAiDeck = {
                            id: generateUUID(),
                            name: deckName,
                            cards: generatedCards.filter(c => c.question && c.answer) // Basic validation
                        };
                        userDecks.push(newAiDeck);
                        saveGameData();
                        populateDecksListInModal();
                        showTemporaryFeedback(aiDeckFeedbackEl, `¡Mazo "${deckName}" generado y añadido con ${newAiDeck.cards.length} palabras!`, "correct", 4000);
                        closeModal(aiDeckModal);
                        // Optionally, make the new deck active
                        // handleSelectDeckForStudy(newAiDeck.id); 
                        // closeModal(decksModal); // Close parent modal too if new deck is made active
                        showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${deckName}" (IA) añadido.`, "correct", 3000);

                    } else {
                        throw new Error("La IA generó una respuesta vacía o en formato incorrecto.");
                    }
                } else {
                     console.error("Gemini API Unexpected Response Structure:", result);
                    throw new Error("Respuesta inesperada de la API de IA. No se encontraron 'candidates' o 'parts'.");
                }

            } catch (error) {
                console.error("Error generando mazo con IA:", error);
                showTemporaryFeedback(aiDeckFeedbackEl, `Error: ${error.message}. Intenta de nuevo.`, "incorrect", 5000);
            } finally {
                aiLoadingIndicatorEl.classList.add('hidden');
                generateAiDeckBtn.disabled = false;
                // Clear loading message if it's still there and wasn't replaced by success/error
                if (aiDeckFeedbackEl.classList.contains('loading')) {
                    clearFeedback(aiDeckFeedbackEl);
                }
            }
        });


        // --- Global Event Listeners & Init ---
        openDecksModalBtn.addEventListener('click', () => {
            populateDecksListInModal();
            updateActiveDeckDisplay();
            clearFeedback(deckManagementFeedbackEl);
            openModal(decksModal);
        });
        closeDecksModalBtn.addEventListener('click', () => closeModal(decksModal));
        openAddNewDeckModalBtn.addEventListener('click', handleOpenAddNewDeckModal);
        selectMainDeckBtn.addEventListener('click', handleSelectMainDeckForStudy);

        saveDeckNameBtn.addEventListener('click', handleSaveDeckName);
        cancelAddEditDeckNameBtn.addEventListener('click', () => closeModal(addEditDeckNameModal));

        learnedBtn.addEventListener('click', markAsLearned);
        nextCardBtn.addEventListener('click', () => moveToNextCard());

        useFertilizerBtn.addEventListener('click', growTree);
        exportProgressBtn.addEventListener('click', exportProgress);
        importProgressBtn.addEventListener('click', () => importProgressInput.click());
        importProgressInput.addEventListener('change', handleImportFile);
        downloadWordsBtn.addEventListener('click', () => {
            let contentToDownload = [];
            let fileNamePrefix = "todas_tus_palabras";

            if (activeDeckId && activeDeckId !== MAIN_DECK_ID) {
                const activeDeck = userDecks.find(d => d.id === activeDeckId);
                if (activeDeck && activeDeck.cards.length > 0) {
                    contentToDownload.push(`=== Palabras del Mazo: ${activeDeck.name} ===`);
                    contentToDownload.push(...activeDeck.cards.map(c => `${c.question}: ${c.answer}`));
                    fileNamePrefix = activeDeck.name.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                } else {
                     showTemporaryFeedback(importExportFeedbackEl, "El mazo activo está vacío.", "info");
                }
            } else {
                userDecks.forEach(deck => {
                    if (deck.cards.length > 0) {
                        contentToDownload.push(`=== Palabras del Mazo: ${deck.name} ===`);
                        contentToDownload.push(...deck.cards.map(c => `${c.question}: ${c.answer}`));
                        contentToDownload.push("");
                    }
                });
            }

            if (learnedFlashcards.length > 0) {
                contentToDownload.push("=== Palabras Aprendidas (Global) ===");
                contentToDownload.push(...learnedFlashcards.map(c => `${c.question}: ${c.answer}`));
            }

            if (contentToDownload.length === 0) {
                 showTemporaryFeedback(importExportFeedbackEl, "No hay palabras para descargar.", "info"); return;
            }

            const textContent = contentToDownload.join('\r\n');
            const blob = new Blob([textContent], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `flashcards_${fileNamePrefix}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showTemporaryFeedback(importExportFeedbackEl, "Archivo de palabras descargado.", "correct");
        });

        function initGameVisuals() {
            updateCurrentStudyCards();
            displayCard();
            updateAllStatsDisplays();
            checkAndGenerateApples();
            updateStudyPanelWordManagementButtons();
        }

        function updateAllStatsDisplays() {
            updateScoreDisplay();
            updateFertilizerCountDisplay();
            updateApplesCountDisplay();
            updateTreeVisual();
        }

        async function initGame() {
            synth = window.speechSynthesis;
            if (synth) {
                populateVoices();
                if (synth.onvoiceschanged !== undefined) {
                    synth.onvoiceschanged = populateVoices;
                }
            } else {
                 console.warn("Speech synthesis is not supported in this browser.");
                if(speakerIconButtonEl) speakerIconButtonEl.style.display = 'none';
            }

            await initCryptoKey();
            loadGameData();
            initGameVisuals();

            if (!window.appleCheckIntervalId) {
                 window.appleCheckIntervalId = setInterval(checkAndGenerateApples, CHECK_APPLES_INTERVAL);
            }
        }

        window.onload = initGame;

    </script>
</body>
</html>
