<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <title>Flashcards de Inglés Fácil: Aprende Vocabulario Interactivo con Mazos</title>

    <meta name="description" content="Mejora tu vocabulario en inglés con flashcards interactivas y mazos personalizables. Aprende nuevas palabras, gestiona tus mazos y progreso, y haz crecer tu árbol de conocimiento. ¡Estudia inglés fácil!">

    <meta name="keywords" content="flashcards inglés, aprender inglés, vocabulario inglés, mazos de estudio, inglés fácil, tarjetas de memoria, estudiar inglés, memorizar palabras, app inglés, aplicación para aprender inglés, mejorar inglés">

    <link rel="canonical" href="https://flashcards-inglesfacil.netlify.app/">

    <meta name="robots" content="index, follow">

    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6819141919218513"
     crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Flashcards de Inglés Fácil con Mazos",
      "description": "Aplicación web interactiva con flashcards y gestión de mazos para aprender y memorizar vocabulario en inglés de forma fácil y divertida, con seguimiento de progreso y elementos de gamificación como un árbol de palabras.",
      "applicationCategory": "EducationalApplication, GameApplication",
      "operatingSystem": "Web",
      "browserRequirements": "Requires HTML5 support, JavaScript enabled.",
      "url": "https://www.tu-dominio.com/ruta-a-esta-app/", /* ¡REEMPLAZA ESTO! */
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "author": {
        "@type": "Person", /* O "Person" si eres un desarrollador individual */
        "name": "Nemus" /* ¡REEMPLAZA ESTO! */
      },
      "keywords": "flashcards, inglés, aprender inglés, vocabulario, estudiar, memorizar, aplicación educativa, juego educativo, mazos de estudio"
    }
    </script>

    <style>
        :root {
            --duo-green: #4CAF50;
            --duo-green-dark: #388E3C;
            --duo-green-light: #66BB6A;
            --duo-blue: #1cb0f6;
            --duo-blue-dark: #138bc4;
            --duo-red: #ff4b4b;
            --duo-red-dark: #fa2d2d;
            --duo-orange: #ff9600;
            --duo-orange-dark: #e88800;
            --duo-yellow: #ffc800;
            --duo-gray-lightest: #f7f7f7;
            --duo-gray-light: #e5e5e5;
            --duo-gray-medium: #afafaf;
            --duo-gray-dark: #777777;
            --duo-text-dark: #4b4b4b;
            --duo-text-light: #ffffff;
            --duo-correct-bg: #d7ffb8;
            --duo-correct-text: #58a700;
            --duo-incorrect-bg: #ffdfe0;
            --duo-incorrect-text: #ea2b2b;
        }

        html, body {
            margin: 0;
            font-family: 'Nunito', sans-serif;
            background-color: var(--duo-gray-lightest);
            color: var(--duo-text-dark);
        }
        .app-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            height: auto; /* Cambiará en móvil */
            padding: 0.75rem; /* Cambiará en móvil */
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        .app-header {
            margin-bottom: 0.75rem; 
            text-align: center;
            width: 100%;
            max-width: 1400px; 
        }
        .app-header h1 {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--duo-green);
            margin-bottom: 0.5rem;
        }

        .main-content-area {
            display: flex;
            width: 100%;
            max-width: 1400px; 
            flex-grow: 1;
            gap: 1rem; 
            overflow: visible; /* Cambiará en móvil */
        }

        .column-title {
            font-size: 1.4rem;
            font-weight: 800;
            color: var(--duo-text-dark);
            text-align: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--duo-gray-light);
        }

        .sidebar {
            background-color: var(--duo-text-light);
            padding: 1.1rem;
            border-radius: 1rem;
            border: 1px solid var(--duo-gray-light);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }
        .sidebar-section .section-title {
            font-size: 1.0rem;
            font-weight: 700;
            margin-bottom: 0.6rem;
            text-align: center;
            color: var(--duo-text-dark);
        }
        .sidebar-section .button-group .btn {
            font-size: 0.8rem;
            padding: 0.6rem 1rem;
            width: auto;
        }
        .sidebar .stats-grid {
            grid-template-columns: repeat(auto-fit, minmax(75px, 1fr));
            gap: 0.4rem;
            margin-bottom: 0;
        }
        .sidebar .stat-item h3 { font-size: 0.65rem; }
        .sidebar .stat-item p { font-size: 1rem; }

        .content-wrapper-main {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 1rem; /* Este gap separará study-panel y tree-panel en desktop. En móvil, display:contents lo anula. */
            overflow: visible; /* Cambiará en móvil si es necesario */
        }

        .study-panel, .tree-panel {
            background-color: var(--duo-text-light);
            padding: 1.1rem;
            border-radius: 1rem;
            border: 1px solid var(--duo-gray-light);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            overflow-y: visible; /* Cambiará en móvil */
        }

        #flashcard-section { margin-bottom: 0.75rem; }
        .flashcard {
            background-color: var(--duo-text-light);
            border: 2px solid var(--duo-gray-light);
            padding: 1.1rem;
            border-radius: 0.75rem;
            margin-bottom: 0.75rem;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.03);
        }
        #question-text {
            font-size: 1.15rem;
            font-weight: 700;
            color: var(--duo-text-dark);
        }
        .input-field {
            padding: 0.6rem 0.9rem;
            border: 2px solid var(--duo-gray-light);
            border-radius: 0.75rem;
            width: 100%;
            max-width: 280px;
            margin: 0.375rem auto;
            box-sizing: border-box;
            font-size: 0.9rem;
            color: var(--duo-text-dark);
            transition: border-color 0.2s ease;
        }
        .input-field:focus {
            border-color: var(--duo-blue);
            outline: none;
            box-shadow: 0 0 0 3px rgba(28, 176, 246, 0.2);
        }
        .feedback {
            margin-top: 0.375rem;
            font-weight: 700;
            min-height: 20px;
            font-size: 0.85rem;
            margin-bottom: 0.6rem;
            padding: 0.4rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        .feedback.correct {
            background-color: var(--duo-correct-bg);
            color: var(--duo-correct-text);
            border: 1px solid var(--duo-correct-text);
        }
        .feedback.incorrect {
            background-color: var(--duo-incorrect-bg);
            color: var(--duo-incorrect-text);
            border: 1px solid var(--duo-incorrect-text);
        }
         .feedback.info {
            background-color: #e0f2fe;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .btn {
            padding: 0.65rem 1.1rem;
            border-radius: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.15s ease;
            cursor: pointer;
            border: none;
            border-bottom: 3px solid rgba(0,0,0,0.2);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 90px;
            font-size: 0.85rem;
            color: var(--duo-text-light);
        }
        .btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .btn:active:not(:disabled) {
            transform: translateY(0px);
            border-bottom-width: 1px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .btn-primary { background-color: var(--duo-green); border-bottom-color: var(--duo-green-dark); }
        .btn-primary:hover:not(:disabled) { background-color: var(--duo-green-light); }
        .btn-secondary { background-color: var(--duo-blue); border-bottom-color: var(--duo-blue-dark); }
        .btn-secondary:hover:not(:disabled) { background-color: #4acaff; }
        .btn-tertiary { background-color: var(--duo-orange); border-bottom-color: var(--duo-orange-dark); }
        .btn-tertiary:hover:not(:disabled) { background-color: #ffae40; }
        .btn-danger { background-color: var(--duo-red); border-bottom-color: var(--duo-red-dark); }
        .btn-danger:hover:not(:disabled) { background-color: #ff6a6a; }
        .btn-learned { background-color: var(--duo-yellow); border-bottom-color: #e6b400; color: var(--duo-text-dark); }
        .btn-learned:hover:not(:disabled) { background-color: #ffd433; }
        .btn-disabled, .btn:disabled { /* Combined selector for disabled state */
            background-color: var(--duo-gray-light) !important;
            border-bottom-color: var(--duo-gray-medium) !important;
            color: var(--duo-gray-dark) !important;
            cursor: not-allowed !important;
            transform: none !important;
            box-shadow: 0 2px 3px rgba(0,0,0,0.05) !important;
        }
        .btn-disabled:hover, .btn:disabled:hover { background-color: var(--duo-gray-light) !important; }


        .option-btn {
            background-color: var(--duo-text-light);
            color: var(--duo-text-dark);
            border: 2px solid var(--duo-gray-light);
            padding: 0.75rem;
            text-align: left;
            text-transform: none;
            font-size: 0.95rem;
            font-weight: 600;
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .option-btn:hover:not(:disabled) {
            border-color: var(--duo-blue);
            background-color: #f0f8ff;
            transform: translateY(-1px);
        }
        .option-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            background-color: var(--duo-gray-lightest);
        }
        .option-btn.selected-correct {
            background-color: var(--duo-correct-bg) !important;
            color: var(--duo-correct-text) !important;
            border-color: var(--duo-correct-text) !important;
            font-weight: 700;
        }
        .option-btn.selected-incorrect {
            background-color: var(--duo-incorrect-bg) !important;
            color: var(--duo-incorrect-text) !important;
            border-color: var(--duo-incorrect-text) !important;
            font-weight: 700;
        }
        .option-btn.actual-correct {
            background-color: var(--duo-correct-bg) !important;
            color: var(--duo-correct-text) !important;
            border: 2px dashed var(--duo-correct-text) !important;
        }

        .stats-grid {
            display: grid;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .stat-item {
            background-color: var(--duo-gray-lightest);
            padding: 0.6rem;
            border-radius: 0.5rem;
            text-align: center;
            border: 1px solid var(--duo-gray-light);
        }
        .stat-item h3 {
            margin-top: 0;
            color: var(--duo-gray-dark);
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.1rem;
        }
        .stat-item p { font-size: 1.1rem; font-weight: 700; color: var(--duo-text-dark); }
        
        .tree-panel .stats-grid {
             grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
             margin-top: 1rem;
        }
        .tree-section-container { display: flex; flex-direction: column; flex-grow: 1; }
        .tree-display {
            margin: 0.5rem 0;
            min-height: 130px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s ease-in-out;
            flex-grow: 0.5;
        }
        .tree-display:hover { transform: scale(1.05); }
        .tree-gif { max-width: 100%; max-height: 180px; object-fit: contain; }
        #tree-level-text {
            font-size: 0.9rem;
            margin-top: 0.25rem;
            font-weight: 600;
            color: var(--duo-gray-dark);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 0.6rem;
            text-align: center;
            color: var(--duo-text-dark);
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.4rem;
        }
        .button-group .btn {
            font-size: 0.75rem;
            padding: 0.5rem 0.9rem;
        }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center; z-index: 1000;
            backdrop-filter: blur(3px);
            overflow-y: auto; /* Allow modal itself to scroll if content is too tall */
            padding: 1rem; /* Padding for small screens */
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            width: 90%; max-width: 450px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border-top: 5px solid var(--duo-green);
        }
        .modal-content.max-w-2xl { max-width: 672px; } /* For larger modals like Decks */

        .modal-content h3 {
            font-size: 1.3rem; font-weight: 700; margin-bottom: 1rem; color: var(--duo-text-dark);
            text-align: center;
        }
        .modal-content label {
            font-size: 0.9rem; color: var(--duo-gray-dark); margin-bottom: 0.25rem; display: block; font-weight: 600;
        }
        .modal-content .input-field { font-size: 0.9rem; margin-bottom: 1rem; }
        .modal-content .feedback { font-size: 0.8rem; min-height: 20px; }
        .modal-content .btn-sm {
            font-size: 0.85rem;
            padding: 0.6rem 1rem;
            text-transform: uppercase;
        }
        .modal-content .btn.bg-slate-300 {
            background-color: var(--duo-gray-light);
            color: var(--duo-gray-dark);
            border-bottom-color: var(--duo-gray-medium);
        }
        .modal-content .btn.bg-slate-300:hover {
            background-color: #d1d1d1;
        }
        #shop-decks-container {
            max-height: 150px;
            overflow-y: auto;
        }
        #import-progress-input { display: none; }

        /* Deck list item styling */
        .deck-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border: 1px solid var(--duo-gray-light);
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            background-color: var(--duo-gray-lightest);
        }
        .deck-list-item.active-deck-item {
            border-left: 4px solid var(--duo-green);
            background-color: #e8f5e9; /* Light green tint */
        }
        .deck-list-item .deck-name {
            font-weight: 600;
            color: var(--duo-text-dark);
            flex-grow: 1;
        }
        .deck-list-item .deck-actions .btn {
            padding: 0.3rem 0.6rem;
            font-size: 0.7rem;
            margin-left: 0.25rem;
        }
       
        @media (max-width: 1024px) { /* Móvil y Tablet */
            
            html, body {
                height: 100%; 
                overflow: hidden; 
            }

            .app-header h1 {
                display: none; /* Esto ocultará el título */
            }
            
        .app-wrapper {
            height: 100dvh; /* O 100vh si dvh causa problemas inesperados */
            padding: 0.5rem; /* Padding general para los bordes del app-wrapper */
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

            .main-content-area {
            flex-direction: column;
            flex-grow: 1;
            overflow-y: auto;
            scroll-snap-type: y mandatory;
            gap: 0;
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* IE 10+ */
            padding-bottom: env(safe-area-inset-bottom, 0px); /* Ajusta el 0px si necesitas un padding mínimo adicional */
            box-sizing: border-box; /* Importante para que el padding no aumente el tamaño del scroll */
        }
        .main-content-area::-webkit-scrollbar { /* WebKit */
            display: none;
        }

            .content-wrapper-main {
                order: 1; 
                display: contents; 
            }

            .study-panel, .tree-panel, .sidebar {
                scroll-snap-align: start;
                height: 100%;
                min-height: 100%;
                margin-bottom: 0 !important;
                overflow-y: auto;
                flex-shrink: 0;
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            .study-panel::-webkit-scrollbar,
            .tree-panel::-webkit-scrollbar,
            .sidebar::-webkit-scrollbar {
                display: none;
            }

            .sidebar {
                order: 2; 
            }


            .scroll-arrow {
                display: none !important; 
            }
            .app-header h1 { font-size: 1.5rem; }
        }

        @media (min-width: 1025px) { /* Escritorio */
            html, body {
                overflow-x: hidden; 
                height: auto; 
                overflow-y: auto; 
            }
             .app-wrapper { 
                min-height: 100vh;
                height: auto;
                padding: 0.75rem;
                overflow: visible; 
            }
            .main-content-area {
                flex-direction: row; 
                align-items: flex-start;
                gap: 1.5rem;
                overflow: visible; 
                scroll-snap-type: none; 
            }
            .sidebar {
                width: 380px;
                flex-shrink: 0;
                margin-bottom: 0; 
                position: sticky; 
                top: 1rem; 
                align-self: flex-start;
                max-height: calc(100vh - 2rem); 
                overflow-y: auto; 
                height: auto; 
                min-height: auto; 
                scroll-snap-align: unset; 
            }
            .content-wrapper-main {
                flex-grow: 1;
                flex-direction: row; 
                gap: 1.5rem;
                display: flex; 
            }
            .study-panel {
                flex-basis: 45%; 
                flex-grow: 1;
                margin-bottom: 0; 
                height: auto; 
                min-height: auto; 
                overflow-y: visible; 
                scroll-snap-align: unset; 
                flex-shrink: 1; 
            }
            .tree-panel {
                flex-basis: 55%; 
                flex-grow: 1;
                margin-bottom: 0; 
                height: auto; 
                min-height: auto; 
                overflow-y: visible; 
                scroll-snap-align: unset; 
                flex-shrink: 1; 
            }
            .scroll-arrow { display: none !important; } 
        }
        .sidebar-section .button-group.grid-cols-2 {
            grid-template-columns: repeat(2, minmax(0, 1fr));
            display: grid;
        }

    </style>

     <script async src="https://www.googletagmanager.com/gtag/js?id=G-H1P5HZZZYT"></script>
    <script>
     window.dataLayer = window.dataLayer || [];
     function gtag(){dataLayer.push(arguments);}
     gtag('js', new Date());

     gtag('config', 'G-H1P5HZZZYT');
    </script>
</head>
<body>
    <main class="app-wrapper">
        <header class="app-header">
            <h1>Aprende Inglés Fácil con Flashcards Interactivas</h1>
        </header>

        <div class="main-content-area">
            <aside class="sidebar">
                <h2 class="column-title">Panel de Control</h2>

                <section class="sidebar-section" aria-label="Recursos y Tienda">
                    <h3 class="section-title text-[var(--duo-green)]">Recursos y Acciones</h3>
                    <div class="stats-grid sidebar-stats">
                        <div class="stat-item">
                            <h3>Puntos</h3>
                            <p id="score">0</p>
                        </div>
                        <div class="stat-item">
                            <h3>Fertilizante</h3>
                            <p id="fertilizer-count">0</p>
                        </div>
                        <div class="stat-item">
                            <h3>Manzanas</h3>
                            <p id="apples-count">0 🍎</p>
                        </div>
                    </div>
                    <div class="button-group mt-2 grid grid-cols-2 gap-2"> <button id="open-shop-btn" class="btn btn-tertiary w-full">Tienda</button>
                        <button id="open-decks-modal-btn" class="btn btn-secondary w-full">Mazos</button> </div>
                </section>


                <section class="sidebar-section" aria-label="Gestión de progreso general">
                    <h3 class="section-title text-[var(--duo-blue)]">Progreso General</h3>
                    <div class="button-group">
                         <button id="export-progress-btn" class="btn btn-tertiary">Exportar</button>
                         <button id="import-progress-btn" class="btn btn-tertiary">Importar</button>
                         <button id="download-words-btn" class="btn btn-tertiary">Descargar Palabras</button>
                         <input type="file" id="import-progress-input" accept=".json, .enc">
                    </div>
                    <div id="import-export-feedback" class="feedback text-center mt-1.5"></div>
                </section>
            </aside>

            <div class="content-wrapper-main">
                <section class="study-panel">
                    <h2 class="column-title">Panel de Estudio</h2>
                    <div class="text-center mb-2">
                        <span class="text-sm font-semibold text-[var(--duo-gray-dark)]">Mazo Activo: </span>
                        <span id="active-deck-display-study-panel" class="text-sm font-bold text-[var(--duo-blue)]">Ninguno</span>
                    </div>
                    <section id="flashcard-section" aria-labelledby="flashcard-title">
                        <div class="flashcard">
                            <p id="question-text"></p>
                        </div>
                        <input type="text" id="answer-input" class="input-field mx-auto block hidden" placeholder="Escribe la traducción...">
                        <div id="multiple-choice-options" class="mt-3 space-y-2 w-full max-w-sm mx-auto"></div>
                        <div id="feedback-text" class="feedback text-center"></div>
                        <div class="flex justify-center space-x-2 mt-1.5 button-group">
                            <button id="check-answer-btn" class="btn btn-primary hidden">Revisar</button>
                            <button id="learned-btn" class="btn btn-learned hidden">¡Lo sé!</button>
                            <button id="next-card-btn" class="btn btn-secondary hidden">Siguiente</button>
                        </div>
                    </section>
                    <section class="sidebar-section" aria-label="Gestión de palabras">
                        <h3 class="section-title text-[var(--duo-blue)]">Gestionar Palabras (Mazo Activo)</h3>
                        <div class="button-group">
                             <button id="show-add-card-modal-btn" class="btn btn-primary ">Añadir</button>
                             <button id="show-delete-card-modal-btn" class="btn btn-danger">Eliminar</button>
                             <button id="show-review-learned-modal-btn" class="btn btn-secondary">Ver Aprendidas</button>
                        </div>
                    </section>
                </section>

                <section class="tree-panel">
                     <h2 class="column-title">Tu Árbol de Palabras</h2>
                     <section id="tree-section" class="text-center flex flex-col flex-grow tree-section-container" aria-label="Progreso del Árbol de Palabras">
                        <div id="tree-display" class="tree-display"></div>
                        <p id="tree-level-text">Nivel: Semilla</p>
                        <div class="mt-2 button-group">
                            <button id="use-fertilizer-btn" class="btn btn-secondary w-full sm:w-auto">Usar Fertilizante</button>
                        </div>
                        <div class="stats-grid tree-panel-stats mt-3" aria-label="Estadísticas de producción del árbol">
                            <div class="stat-item">
                                <h3>Producción</h3>
                                <p id="apples-per-day" class="text-xs sm:text-sm">0 / día</p>
                            </div>
                            <div class="stat-item">
                                <h3>Próximas 🍎</h3>
                                <p id="apple-countdown" class="text-xs sm:text-sm">--:--:--</p>
                            </div>
                        </div>
                    </section>
                </section>
            </div>
        </div>

        <button id="scroll-left-btn" class="scroll-arrow left hidden" aria-label="Desplazar a la izquierda">«</button>
        <button id="scroll-right-btn" class="scroll-arrow right hidden" aria-label="Desplazar a la derecha">»</button>
    </main>

    <div id="add-card-modal" class="modal hidden" role="dialog" aria-labelledby="addCardModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="addCardModalTitle">Nueva Palabra (al mazo activo)</h3>
            <label for="new-question">Palabra en Inglés:</label>
            <input type="text" id="new-question" class="input-field w-full" placeholder="Ej: Hello">
            <label for="new-answer">Traducción al Español:</label>
            <input type="text" id="new-answer" class="input-field w-full" placeholder="Ej: Hola">
            <div id="add-card-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="save-card-btn" class="btn btn-primary btn-sm">Guardar</button>
                <button id="cancel-add-card-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="delete-card-modal" class="modal hidden" role="dialog" aria-labelledby="deleteCardModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="deleteCardModalTitle">Eliminar Palabra (del mazo activo)</h3>
            <div class="flex justify-end mb-1">
                 <button id="select-all-delete-btn" class="btn btn-secondary btn-sm !py-1 !px-2 !text-xs hidden">Seleccionar Todas</button>
            </div>
            <div id="delete-card-list-container" class="my-2 max-h-48 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md">
                <p id="no-cards-to-delete-msg" class="text-[var(--duo-gray-dark)] text-sm hidden">No hay palabras para eliminar en el mazo activo.</p>
            </div>
            <div id="delete-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="confirm-delete-card-btn" class="btn btn-danger btn-sm">Eliminar</button>
                <button id="cancel-delete-card-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="review-learned-modal" class="modal hidden" role="dialog" aria-labelledby="reviewLearnedModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="reviewLearnedModalTitle">Palabras Aprendidas (Global)</h3>
            <div id="review-learned-list-container" class="my-2 max-h-52 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md">
                 <p id="no-learned-cards-msg" class="text-[var(--duo-gray-dark)] text-sm hidden">Aún no has marcado ninguna palabra como aprendida.</p>
            </div>
            <div id="review-modal-feedback" class="feedback text-center"></div>
            <div class="flex justify-end mt-3">
                <button id="close-review-learned-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="shop-modal" class="modal hidden" role="dialog" aria-labelledby="shopModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="shopModalTitle">Tienda del Árbol</h3>
            <div id="shop-feedback" class="feedback text-center"></div>
            <div class="space-y-2 my-3">
                <div class="p-2.5 border border-[var(--duo-gray-light)] rounded-lg bg-[var(--duo-gray-lightest)]">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="font-semibold text-sm text-[var(--duo-text-dark)]">Fertilizante</h4>
                            <p class="text-xs text-[var(--duo-gray-dark)]">Costo: <span id="fertilizer-shop-cost-display">10</span> Puntos ✨</p>
                        </div>
                        <button id="buy-fertilizer-shop-btn" class="btn btn-primary btn-sm">Comprar</button>
                    </div>
                </div>
                 <div class="p-2.5 border border-[var(--duo-gray-light)] rounded-lg bg-[var(--duo-gray-lightest)]">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="font-semibold text-sm text-[var(--duo-text-dark)]">1 Manzana 🍎</h4>
                            <p class="text-xs text-[var(--duo-gray-dark)]">Costo: <span id="apple-shop-cost-display">1000</span> Puntos</p>
                        </div>
                        <button id="buy-apple-shop-btn" class="btn btn-primary btn-sm">Comprar</button>
                    </div>
                </div>
                <h4 class="text-md font-semibold text-[var(--duo-text-dark)] pt-3 mt-3 border-t border-[var(--duo-gray-light)]">Mazos de Palabras (Tienda)</h4>
                <div id="shop-decks-container" class="space-y-2">
                    <p id="loading-decks-msg" class="text-sm text-center text-[var(--duo-gray-dark)]">Cargando mazos disponibles...</p>
                </div>
            </div>
            <div class="flex justify-end mt-3">
                <button id="close-shop-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar Tienda</button>
            </div>
        </div>
    </div>

    <div id="decks-modal" class="modal hidden" role="dialog" aria-labelledby="decksModalTitle" aria-modal="true">
        <div class="modal-content max-w-2xl"> <h3 id="decksModalTitle" class="text-lg font-bold">Mis Mazos</h3>
            
            <div class="my-4 flex flex-wrap gap-2">
                <button id="open-add-new-deck-modal-btn" class="btn btn-primary btn-sm">Crear Nuevo Mazo</button>
                <button id="select-main-deck-btn" class="btn btn-secondary btn-sm">Estudiar Mazo Principal (Todas)</button>
            </div>

            <p class="text-sm text-gray-600 mb-1">Mazo activo para estudiar: 
                <strong id="active-deck-name-modal-display" class="text-[var(--duo-blue)]">Ninguno</strong>
            </p>

            <div id="decks-list-container" class="my-3 max-h-72 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md bg-white">
                <p id="no-user-decks-msg" class="text-[var(--duo-gray-dark)] text-sm p-2">No tienes mazos creados. ¡Crea uno para empezar!</p>
            </div>

            <div id="deck-management-feedback" class="feedback text-center mt-2"></div>

            <div class="flex justify-end space-x-2 mt-6">
                <button id="close-decks-modal-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="add-edit-deck-name-modal" class="modal hidden" role="dialog" aria-labelledby="addEditDeckNameModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="addEditDeckNameModalTitle">Crear Nuevo Mazo</h3>
            <label for="deck-name-input">Nombre del Mazo:</label>
            <input type="text" id="deck-name-input" class="input-field w-full" placeholder="Ej: Verbos Comunes">
            <input type="hidden" id="editing-deck-id-input"> 
            <div id="add-edit-deck-name-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="save-deck-name-btn" class="btn btn-primary btn-sm">Guardar</button>
                <button id="cancel-add-edit-deck-name-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>


    <audio id="correct-sound" src="sounds/correct-sound.mp3" preload="auto"></audio>
    <audio id="incorrect-sound" src="sounds/incorrect-sound.mp3" preload="auto"></audio>

    <script>
        // --- Game State Variables ---
        let userDecks = []; // Array of deck objects: [{ id: 'uuid', name: 'Mi Mazo', cards: [{q:'q1',a:'a1'}, ...] }, ...]
        let activeDeckId = null; // ID of the deck currently selected for study, or '__main_all_decks__'
        let currentStudyCards = []; // Cards currently being studied (from activeDeck or mainDeck)
        // --- (Original flashcards variable is now effectively replaced by currentStudyCards) ---
        let learnedFlashcards = []; // Global list of learned cards: [{ question, answer, originalDeckId (optional) }]
        let currentCardIndex = 0;
        let score = 0;
        let fertilizerCount = 0;
        let treeLevel = 0;
        let applesCount = 0;
        let applesPerDay = 0;
        let lastAppleGenerationTime = Date.now();
        let appleCountdownInterval = null;
        let shopDecksData = {}; // For decks from the shop
        let pointsThisHour = 0;
        let lastPointResetTime = Date.now();

        // --- Game Constants ---
        const POINTS_PER_CORRECT_ANSWER = 10;
        const POINTS_FOR_LEARNED_WORD = 20; // Points for moving a card to learned list
        const DEFAULT_FLASHCARDS_DATA = [ // Renamed to avoid conflict
            { question: "Hello", answer: "Hola" }, { question: "Goodbye", answer: "Adiós" },
            { question: "Thank you", answer: "Gracias" }, { question: "Please", answer: "Por favor" },
            { question: "Yes", answer: "Sí" }, { question: "No", answer: "No" },
            { question: "Friend", answer: "Amigo" }, { question: "Love", answer: "Amor" }
        ];
        const MAIN_DECK_ID = '__main_all_decks__'; // Special ID for the main deck
        const CHECK_APPLES_INTERVAL = 60 * 1000; // 1 minute
        const FERTILIZER_SHOP_COST = 50;
        const APPLE_SHOP_COST = 500;
        const TREE_LEVEL_DATA = [
            { name: 'Semilla',         gifName: 'gif_1.gif', fertilizerToNext: 5,   applesPerDay: 0 },
            { name: 'Brote',           gifName: 'gif_2.gif', fertilizerToNext: 10,  applesPerDay: 0 },
            { name: 'Árbol Pequeño',   gifName: 'gif_3.gif', fertilizerToNext: 20,  applesPerDay: 1 },
            { name: 'Árbol Mediano',   gifName: 'gif_4.gif', fertilizerToNext: 40,  applesPerDay: 2 },
            { name: 'Árbol Mìstico',    gifName: 'gif_5.gif', fertilizerToNext: 80,  applesPerDay: 4 },
            { name: 'Árbol Divino',   gifName: 'gif_6.gif', fertilizerToNext: 160, applesPerDay: 8 }
        ];
        const MAX_TREE_LEVEL_INDEX = TREE_LEVEL_DATA.length - 1;
        const SHOP_DECK_DEFINITIONS = [
            { id: "basic_verbs_pack", fileName: "decks/deck_basic_verbs.json" },
            { id: "birds_pack", fileName: "decks/birds.json" },
            { id: "body_parts_pack", fileName: "decks/body.json" },
            { id: "basic_verbs_past_pack", fileName: "decks/deck_basic_verbs_past.json" },
            { id: "fruits_vegetables_pack", fileName: "decks/fruit.json" },
            { id: "land_animals_pack", fileName: "decks/land_animals.json" },
            { id: "marine_animals_pack", fileName: "decks/marine_animals.json" }
        ];
        const ENCRYPTION_KEY_STRING = "miClaveSuperSecreta1234567890!"; // Must be 32 bytes for AES-256 if used directly
        let cryptoKey;
        const MIN_CARDS_FOR_POINTS = 5; // Min cards in active specific deck to earn points
        const MIN_CARDS_FOR_MULTIPLE_CHOICE = 3; // Min cards in active specific deck for 3 choices
        const MAX_POINTS_PER_HOUR = 500;
        const ONE_HOUR_IN_MS = 60 * 60 * 1000;


        // --- DOM Elements ---
        const questionTextEl = document.getElementById('question-text');
        const answerInputEl = document.getElementById('answer-input'); // Kept for potential future use, but options are primary
        const multipleChoiceOptionsEl = document.getElementById('multiple-choice-options');
        const checkAnswerBtn = document.getElementById('check-answer-btn'); // Likely hidden if using options only
        const learnedBtn = document.getElementById('learned-btn');
        const nextCardBtn = document.getElementById('next-card-btn');
        const feedbackTextEl = document.getElementById('feedback-text');
        const scoreEl = document.getElementById('score'); 
        const fertilizerCountEl = document.getElementById('fertilizer-count'); 
        const applesCountEl = document.getElementById('apples-count'); 
        const treeDisplayEl = document.getElementById('tree-display');
        const treeLevelTextEl = document.getElementById('tree-level-text');
        const useFertilizerBtn = document.getElementById('use-fertilizer-btn');
        const applesPerDayEl = document.getElementById('apples-per-day'); 
        const appleCountdownEl = document.getElementById('apple-countdown'); 
        
        // Word Management Modals (Study Panel)
        const showAddCardModalBtn = document.getElementById('show-add-card-modal-btn'); 
        const addCardModal = document.getElementById('add-card-modal');
        const newQuestionInput = document.getElementById('new-question');
        const newAnswerInput = document.getElementById('new-answer');
        const saveCardBtn = document.getElementById('save-card-btn');
        const cancelAddCardBtn = document.getElementById('cancel-add-card-btn');
        const addCardFeedbackEl = document.getElementById('add-card-feedback');
        
        const showDeleteCardModalBtn = document.getElementById('show-delete-card-modal-btn'); 
        const deleteCardModal = document.getElementById('delete-card-modal');
        const deleteCardListContainerEl = document.getElementById('delete-card-list-container');
        const noCardsToDeleteMsgEl = document.getElementById('no-cards-to-delete-msg');
        const confirmDeleteCardBtn = document.getElementById('confirm-delete-card-btn');
        const cancelDeleteCardBtn = document.getElementById('cancel-delete-card-btn');
        const deleteFeedbackEl = document.getElementById('delete-feedback');
        const selectAllDeleteBtn = document.getElementById('select-all-delete-btn');

        const showReviewLearnedModalBtn = document.getElementById('show-review-learned-modal-btn'); 
        const reviewLearnedModal = document.getElementById('review-learned-modal');
        const reviewLearnedListContainerEl = document.getElementById('review-learned-list-container');
        const noLearnedCardsMsgEl = document.getElementById('no-learned-cards-msg');
        const closeReviewLearnedBtn = document.getElementById('close-review-learned-btn');
        const reviewModalFeedbackEl = document.getElementById('review-modal-feedback');

        // Shop Modal
        const openShopBtn = document.getElementById('open-shop-btn'); 
        const shopModal = document.getElementById('shop-modal');
        const closeShopBtn = document.getElementById('close-shop-btn');
        const buyFertilizerShopBtn = document.getElementById('buy-fertilizer-shop-btn');
        const buyAppleShopBtn = document.getElementById('buy-apple-shop-btn');
        const shopFeedbackEl = document.getElementById('shop-feedback');
        const fertilizerShopCostDisplayEl = document.getElementById('fertilizer-shop-cost-display');
        const appleShopCostDisplayEl = document.getElementById('apple-shop-cost-display');
        const shopDecksContainerEl = document.getElementById('shop-decks-container');
        const loadingDecksMsgEl = document.getElementById('loading-decks-msg');

        // Import/Export
        const exportProgressBtn = document.getElementById('export-progress-btn'); 
        const importProgressBtn = document.getElementById('import-progress-btn'); 
        const importProgressInput = document.getElementById('import-progress-input'); 
        const importExportFeedbackEl = document.getElementById('import-export-feedback'); 
        const downloadWordsBtn = document.getElementById('download-words-btn'); 

        // Deck Management Modal Elements
        const openDecksModalBtn = document.getElementById('open-decks-modal-btn');
        const decksModal = document.getElementById('decks-modal');
        const closeDecksModalBtn = document.getElementById('close-decks-modal-btn');
        const openAddNewDeckModalBtn = document.getElementById('open-add-new-deck-modal-btn');
        const selectMainDeckBtn = document.getElementById('select-main-deck-btn');
        const decksListContainerEl = document.getElementById('decks-list-container');
        const noUserDecksMsgEl = document.getElementById('no-user-decks-msg');
        const deckManagementFeedbackEl = document.getElementById('deck-management-feedback');
        const activeDeckNameModalDisplayEl = document.getElementById('active-deck-name-modal-display');
        
        // Add/Edit Deck Name Modal Elements
        const addEditDeckNameModal = document.getElementById('add-edit-deck-name-modal');
        const addEditDeckNameModalTitleEl = document.getElementById('addEditDeckNameModalTitle');
        const deckNameInputEl = document.getElementById('deck-name-input');
        const editingDeckIdInputEl = document.getElementById('editing-deck-id-input');
        const saveDeckNameBtn = document.getElementById('save-deck-name-btn');
        const cancelAddEditDeckNameBtn = document.getElementById('cancel-add-edit-deck-name-btn');
        const addEditDeckNameFeedbackEl = document.getElementById('add-edit-deck-name-feedback');

        // Display for active deck in study panel
        const activeDeckDisplayStudyPanelEl = document.getElementById('active-deck-display-study-panel');
        
        // Sounds
        const correctSound = document.getElementById('correct-sound');
        const incorrectSound = document.getElementById('incorrect-sound');

        // --- Utility Functions ---
        function generateUUID() { return crypto.randomUUID(); }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        function openModal(modalElement) { modalElement.classList.remove('hidden'); }
        function closeModal(modalElement) { modalElement.classList.add('hidden'); }

        function clearFeedback(element) {
            const baseClass = element.className.split(' ').filter(cls => cls === 'feedback' || cls === 'text-center' || cls.startsWith('mt-') || cls.startsWith('mb-')).join(' ');
            element.textContent = '';
            element.className = baseClass;
        }

        function showTemporaryFeedback(element, message, type = 'info', duration = 3000) {
            clearFeedback(element);
            element.textContent = message;
            element.classList.add(type);

            if (duration > 0) {
                setTimeout(() => {
                    if (element.textContent === message) { // Only clear if message hasn't changed
                        clearFeedback(element);
                        // Restore default informational message in main feedback area if applicable
                        if (element === feedbackTextEl) updateDefaultFeedbackMessage();
                    }
                }, duration);
            }
        }
        
        // --- Crypto Functions (Unchanged) ---
        async function initCryptoKey() {
            try {
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw", new TextEncoder().encode(ENCRYPTION_KEY_STRING.slice(0, 32)),
                    { name: "PBKDF2" }, false, ["deriveKey"]
                );
                const salt = new TextEncoder().encode("someFixedSaltValueForDecksApp"); // Unique salt
                cryptoKey = await window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: salt, iterations: 100000, hash: "SHA-256" },
                    keyMaterial, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
                );
            } catch (error) {
                console.error("Error al inicializar CryptoKey:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error de criptografía al iniciar.", "incorrect", 5000);
                [exportProgressBtn, importProgressBtn].forEach(btn => {
                    btn.disabled = true; btn.classList.add('btn-disabled');
                });
            }
        }

        async function encryptData(plaintext) {
            if (!cryptoKey) {
                showTemporaryFeedback(importExportFeedbackEl, "Error: Clave de encriptación no lista.", "incorrect", 3000); return null;
            }
            try {
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encodedText = new TextEncoder().encode(plaintext);
                const ciphertext = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, cryptoKey, encodedText);
                const ivBase64 = btoa(String.fromCharCode.apply(null, iv));
                const ciphertextBase64 = btoa(String.fromCharCode.apply(null, new Uint8Array(ciphertext)));
                return { iv: ivBase64, ciphertext: ciphertextBase64 };
            } catch (error) {
                console.error("Error encriptando:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error al encriptar datos.", "incorrect", 3000); return null;
            }
        }

        async function decryptData(ciphertextBase64, ivBase64) {
            if (!cryptoKey) {
                showTemporaryFeedback(importExportFeedbackEl, "Error: Clave de decriptación no lista.", "incorrect", 3000); return null;
            }
            try {
                const iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));
                const ciphertext = Uint8Array.from(atob(ciphertextBase64), c => c.charCodeAt(0)).buffer;
                const decryptedBuffer = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, cryptoKey, ciphertext);
                return new TextDecoder().decode(decryptedBuffer);
            } catch (error) {
                console.error("Error desencriptando:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error al desencriptar. ¿Archivo o clave incorrectos?", "incorrect", 4000); return null;
            }
        }
        
        // --- Data Persistence ---
        function saveGameData() {
            const gameData = {
                userDecks, activeDeckId, learnedFlashcards, // Deck related
                score, fertilizerCount, treeLevel, applesCount, // Game stats
                lastAppleGenerationTime, pointsThisHour, lastPointResetTime // Timers and limits
                // currentCardIndex is implicitly managed by active deck, no need to save globally if it resets on deck change
            };
            localStorage.setItem('flashcardGameDataWithDecks', JSON.stringify(gameData));
        }

        function loadGameData() {
            const savedData = localStorage.getItem('flashcardGameDataWithDecks');
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    userDecks = parsedData.userDecks || [];
                    activeDeckId = parsedData.activeDeckId || null;
                    learnedFlashcards = parsedData.learnedFlashcards || [];
                    score = parsedData.score || 0;
                    fertilizerCount = parsedData.fertilizerCount || 0;
                    treeLevel = parsedData.treeLevel || 0;
                    applesCount = parsedData.applesCount || 0;
                    lastAppleGenerationTime = parsedData.lastAppleGenerationTime || Date.now();
                    pointsThisHour = parsedData.pointsThisHour || 0;
                    lastPointResetTime = parsedData.lastPointResetTime || Date.now();

                    // Ensure card objects are valid (simple check)
                    userDecks.forEach(deck => {
                        if (!Array.isArray(deck.cards)) deck.cards = [];
                        deck.cards = deck.cards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string');
                    });
                    learnedFlashcards = learnedFlashcards.filter(c => typeof c.question === 'string' && typeof c.answer === 'string');


                    if (userDecks.length === 0) { // If no decks, create a default one
                        const defaultDeck = { 
                            id: generateUUID(), 
                            name: "Primer Mazo", 
                            cards: DEFAULT_FLASHCARDS_DATA.map(c => ({...c})) // Create new objects
                        };
                        userDecks.push(defaultDeck);
                        activeDeckId = defaultDeck.id;
                    } else if (!activeDeckId || !userDecks.find(d => d.id === activeDeckId) && activeDeckId !== MAIN_DECK_ID) {
                        // If activeDeckId is invalid but there are decks, set to first deck or main deck
                        activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                    }
                } catch (e) {
                    console.error("Error parseando datos guardados (con mazos), reseteando a default:", e);
                    resetToDeckDefaults();
                }
            } else {
                resetToDeckDefaults();
            }
            checkHourlyPointLimit();
            updateCurrentStudyCards(); // Initialize currentStudyCards based on loaded activeDeckId
        }

        function resetToDeckDefaults() {
            const defaultDeck = { 
                id: generateUUID(), 
                name: "Primer Mazo", 
                cards: DEFAULT_FLASHCARDS_DATA.map(c => ({...c})) 
            };
            userDecks = [defaultDeck];
            activeDeckId = defaultDeck.id;
            learnedFlashcards = [];
            currentStudyCards = defaultDeck.cards.slice(); // Initialize study cards
            currentCardIndex = 0;
            score = 0;
            fertilizerCount = 0;
            treeLevel = 0;
            applesCount = 0;
            lastAppleGenerationTime = Date.now();
            pointsThisHour = 0;
            lastPointResetTime = Date.now();
        }
        
        // --- Deck Management Logic ---
        function updateCurrentStudyCards() {
            currentStudyCards = []; // Reset
            if (activeDeckId === MAIN_DECK_ID) {
                userDecks.forEach(deck => {
                    deck.cards.forEach(card => {
                        // Add originalDeckId to know where it came from if learned from main deck
                        currentStudyCards.push({ ...card, originalDeckId: deck.id });
                    });
                });
                if (currentStudyCards.length > 1) shuffleArray(currentStudyCards);
            } else {
                const deck = userDecks.find(d => d.id === activeDeckId);
                if (deck) {
                    currentStudyCards = deck.cards.slice(); // Use a copy for study to allow shuffling
                    if (currentStudyCards.length > 1) shuffleArray(currentStudyCards);
                }
            }
            currentCardIndex = 0; // Reset index when study cards change
            updateActiveDeckDisplay();
            updateStudyPanelWordManagementButtons();
        }

        function getActiveDeckName() {
            if (activeDeckId === MAIN_DECK_ID) return "Mazo Principal (Todas)";
            const deck = userDecks.find(d => d.id === activeDeckId);
            return deck ? deck.name : "Ninguno Seleccionado";
        }

        function updateActiveDeckDisplay() {
            const name = getActiveDeckName();
            activeDeckDisplayStudyPanelEl.textContent = name;
            activeDeckNameModalDisplayEl.textContent = name;
        }
        
        function populateDecksListInModal() {
            decksListContainerEl.innerHTML = ''; // Clear previous list
            if (userDecks.length === 0) {
                noUserDecksMsgEl.classList.remove('hidden');
                return;
            }
            noUserDecksMsgEl.classList.add('hidden');

            userDecks.forEach(deck => {
                const item = document.createElement('div');
                item.className = 'deck-list-item p-3 border rounded-lg mb-2 flex justify-between items-center hover:bg-gray-50 transition-colors';
                if (deck.id === activeDeckId) {
                    item.classList.add('active-deck-item', 'border-green-500', 'bg-green-50');
                }

                item.innerHTML = `
                    <div class="flex-grow">
                        <span class="deck-name font-semibold text-gray-700">${deck.name}</span>
                        <span class="text-xs text-gray-500 ml-2">(${deck.cards.length} palabras)</span>
                    </div>
                    <div class="deck-actions space-x-1">
                        <button class="btn btn-secondary btn-sm select-deck-btn !py-1 !px-2 !text-xs" data-deck-id="${deck.id}">Estudiar</button>
                        <button class="btn btn-tertiary btn-sm edit-deck-name-btn !py-1 !px-2 !text-xs" data-deck-id="${deck.id}" data-deck-name="${deck.name}">Editar Nombre</button>
                        <button class="btn btn-danger btn-sm delete-deck-btn !py-1 !px-2 !text-xs" data-deck-id="${deck.id}">Eliminar</button>
                    </div>
                `;
                decksListContainerEl.appendChild(item);
            });

            // Add event listeners for new buttons
            decksListContainerEl.querySelectorAll('.select-deck-btn').forEach(btn => 
                btn.addEventListener('click', (e) => handleSelectDeckForStudy(e.target.dataset.deckId))
            );
            decksListContainerEl.querySelectorAll('.edit-deck-name-btn').forEach(btn => 
                btn.addEventListener('click', (e) => handleOpenEditDeckNameModal(e.target.dataset.deckId, e.target.dataset.deckName))
            );
            decksListContainerEl.querySelectorAll('.delete-deck-btn').forEach(btn => 
                btn.addEventListener('click', (e) => handleDeleteDeck(e.target.dataset.deckId))
            );
        }

        function handleOpenAddNewDeckModal() {
            editingDeckIdInputEl.value = ''; // Clear editing ID
            deckNameInputEl.value = '';
            addEditDeckNameModalTitleEl.textContent = 'Crear Nuevo Mazo';
            clearFeedback(addEditDeckNameFeedbackEl);
            openModal(addEditDeckNameModal);
            deckNameInputEl.focus();
        }
        
        function handleOpenEditDeckNameModal(deckId, currentName) {
            editingDeckIdInputEl.value = deckId;
            deckNameInputEl.value = currentName;
            addEditDeckNameModalTitleEl.textContent = 'Editar Nombre del Mazo';
            clearFeedback(addEditDeckNameFeedbackEl);
            openModal(addEditDeckNameModal);
            deckNameInputEl.focus();
        }

        function handleSaveDeckName() {
            const deckName = deckNameInputEl.value.trim();
            const editingDeckId = editingDeckIdInputEl.value;

            if (!deckName) {
                showTemporaryFeedback(addEditDeckNameFeedbackEl, "El nombre del mazo no puede estar vacío.", "incorrect");
                return;
            }

            if (editingDeckId) { // Editing existing deck
                const deck = userDecks.find(d => d.id === editingDeckId);
                if (deck) {
                    deck.name = deckName;
                    showTemporaryFeedback(deckManagementFeedbackEl, `Nombre del mazo actualizado a "${deckName}".`, "correct", 2000);
                }
            } else { // Adding new deck
                const newDeck = { id: generateUUID(), name: deckName, cards: [] };
                userDecks.push(newDeck);
                showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${deckName}" creado.`, "correct", 2000);
            }
            saveGameData();
            populateDecksListInModal();
            updateActiveDeckDisplay(); // In case the active deck's name changed
            closeModal(addEditDeckNameModal);
        }

        function handleDeleteDeck(deckIdToDelete) {
            const deck = userDecks.find(d => d.id === deckIdToDelete);
            if (!deck) return;

            // Simple confirmation for now. Could be a custom modal later.
            if (!confirm(`¿Estás seguro de que quieres eliminar el mazo "${deck.name}" y todas sus ${deck.cards.length} palabras? Esta acción no se puede deshacer.`)) {
                return;
            }

            userDecks = userDecks.filter(d => d.id !== deckIdToDelete);
            
            // If the deleted deck was active, switch to main deck or first available
            if (activeDeckId === deckIdToDelete) {
                activeDeckId = userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID;
                updateCurrentStudyCards();
                displayCard(); // Refresh study panel
            }
            
            saveGameData();
            populateDecksListInModal(); // Refresh list in modal
            updateActiveDeckDisplay(); // Refresh display in study panel and modal
            showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${deck.name}" eliminado.`, "correct", 2500);
        }

        function handleSelectDeckForStudy(deckId) {
            activeDeckId = deckId;
            updateCurrentStudyCards();
            displayCard(); // Refresh study panel with new deck
            saveGameData();
            populateDecksListInModal(); // Re-render to show active state
            updateActiveDeckDisplay();
            showTemporaryFeedback(deckManagementFeedbackEl, `Mazo "${getActiveDeckName()}" seleccionado para estudiar.`, "info", 2000);
            closeModal(decksModal); // Optionally close modal after selection
        }

        function handleSelectMainDeckForStudy() {
            activeDeckId = MAIN_DECK_ID;
            updateCurrentStudyCards();
            displayCard();
            saveGameData();
            populateDecksListInModal(); // Re-render to show active state
            updateActiveDeckDisplay();
            showTemporaryFeedback(deckManagementFeedbackEl, `Mazo Principal seleccionado para estudiar.`, "info", 2000);
            closeModal(decksModal); // Optionally close modal after selection
        }
        
        // --- Import/Export Progress (Updated to include deck data) ---
        async function exportProgress() {
            clearFeedback(importExportFeedbackEl);
            const gameData = { // Ensure all relevant state is included
                userDecks, activeDeckId, learnedFlashcards,
                score, fertilizerCount, treeLevel, applesCount,
                lastAppleGenerationTime,
                pointsThisHour, lastPointResetTime
            };
            const jsonData = JSON.stringify(gameData);
            const encryptedPayload = await encryptData(jsonData);
            if (!encryptedPayload) {
                showTemporaryFeedback(importExportFeedbackEl, "Fallo la encriptación. No se pudo exportar.", "incorrect", 3000);
                return;
            }
            const dataToExport = JSON.stringify(encryptedPayload);
            const blob = new Blob([dataToExport], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "flashcards_progress_encrypted_v2.json"; // New version due to data structure change
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showTemporaryFeedback(importExportFeedbackEl, "Progreso exportado y encriptado.", "correct", 3000);
        }

        async function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) {
                showTemporaryFeedback(importExportFeedbackEl, "No se seleccionó archivo.", "info", 3000);
                return;
            }
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const fileContent = e.target.result;
                    const encryptedPayload = JSON.parse(fileContent);
                    if (!encryptedPayload.iv || !encryptedPayload.ciphertext) {
                        throw new Error("Formato de archivo encriptado inválido.");
                    }
                    const decryptedJson = await decryptData(encryptedPayload.ciphertext, encryptedPayload.iv);
                    if (!decryptedJson) { return; } // decryptData shows its own feedback
                    
                    const importedData = JSON.parse(decryptedJson);
                    // Basic validation for new structure
                    if (typeof importedData.score !== 'number' || !Array.isArray(importedData.userDecks)) {
                         // Try to load old format if new one fails (simple check)
                        if (Array.isArray(importedData.flashcards)) { // Likely old format
                            userDecks = [{ id: generateUUID(), name: "Mazo Importado", cards: importedData.flashcards || [] }];
                            activeDeckId = userDecks[0].id;
                            learnedFlashcards = importedData.learnedFlashcards || [];
                        } else {
                            throw new Error("Datos importados inválidos o corruptos (mazos).");
                        }
                    } else { // New format
                        userDecks = importedData.userDecks || [];
                        activeDeckId = importedData.activeDeckId || (userDecks.length > 0 ? userDecks[0].id : MAIN_DECK_ID);
                        learnedFlashcards = importedData.learnedFlashcards || [];
                    }
                    
                    // Common properties
                    score = importedData.score || 0;
                    fertilizerCount = importedData.fertilizerCount || 0;
                    treeLevel = importedData.treeLevel || 0;
                    applesCount = importedData.applesCount || 0;
                    lastAppleGenerationTime = importedData.lastAppleGenerationTime || Date.now();
                    pointsThisHour = importedData.pointsThisHour || 0;
                    lastPointResetTime = importedData.lastPointResetTime || Date.now();

                    saveGameData(); // Save in new format
                    initGameVisuals(); // This will call updateCurrentStudyCards and displayCard
                    showTemporaryFeedback(importExportFeedbackEl, "Progreso importado exitosamente.", "correct", 4000);
                } catch (error) {
                    console.error("Error importando progreso:", error);
                    showTemporaryFeedback(importExportFeedbackEl, `Error al importar: ${error.message}`, "incorrect", 5000);
                } finally {
                    importProgressInput.value = ""; // Reset file input
                }
            };
            reader.onerror = () => {
                showTemporaryFeedback(importExportFeedbackEl, "Error al leer el archivo.", "incorrect", 3000);
            };
            reader.readAsText(file);
        }
        
        // --- Study Panel Logic (Flashcards) ---
        function displayCard() {
            clearFeedback(feedbackTextEl); // Clear previous feedback
            if (currentStudyCards.length === 0) {
                handleNoCardsInActiveDeckState();
                return;
            }
            if (currentCardIndex >= currentStudyCards.length || currentCardIndex < 0) {
                currentCardIndex = 0; // Should be handled by updateCurrentStudyCards if deck shuffles
            }
            questionTextEl.textContent = currentStudyCards[currentCardIndex].question;
            answerInputEl.value = ""; // Clear old input if it was visible
            answerInputEl.classList.add('hidden'); // Hide direct input field
            checkAnswerBtn.classList.add('hidden'); // Hide direct check button
            
            generateAndDisplayOptions(); // Generate multiple choice options

            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.add('hidden');
            updateDefaultFeedbackMessage(); // Set initial informational message
        }

        function updateDefaultFeedbackMessage() {
            if (currentStudyCards.length === 0) { // This case is handled by handleNoCardsInActiveDeckState
                return;
            }
            const activeDeckIsSpecific = activeDeckId && activeDeckId !== MAIN_DECK_ID;
            const currentDeckCardCount = activeDeckIsSpecific ? (userDecks.find(d=>d.id === activeDeckId)?.cards.length || 0) : currentStudyCards.length;

            if (activeDeckIsSpecific && currentDeckCardCount < MIN_CARDS_FOR_POINTS) {
                showTemporaryFeedback(feedbackTextEl, `El mazo activo "${getActiveDeckName()}" tiene ${currentDeckCardCount} palabras. Necesitas al menos ${MIN_CARDS_FOR_POINTS} para ganar puntos.`, "info", 0);
            } else if (activeDeckIsSpecific && currentDeckCardCount < MIN_CARDS_FOR_MULTIPLE_CHOICE) {
                 showTemporaryFeedback(feedbackTextEl, `El mazo activo "${getActiveDeckName()}" tiene ${currentDeckCardCount} palabras. Añade más para tener ${MIN_CARDS_FOR_MULTIPLE_CHOICE} opciones de respuesta.`, "info", 0);
            } else {
                clearFeedback(feedbackTextEl); // Clear if conditions for info messages are not met
            }
        }


        function handleNoCardsInActiveDeckState() {
            questionTextEl.textContent = `¡No hay palabras en "${getActiveDeckName()}"!`;
            if (activeDeckId !== MAIN_DECK_ID) {
                questionTextEl.textContent += " Añade algunas o selecciona otro mazo.";
            } else {
                 questionTextEl.textContent = "¡No hay palabras en ningún mazo! Crea mazos y añade palabras.";
            }
            multipleChoiceOptionsEl.innerHTML = '';
            answerInputEl.classList.add('hidden');
            checkAnswerBtn.classList.add('hidden');
            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.add('hidden');
            showTemporaryFeedback(feedbackTextEl, `Usa 'Añadir Palabra' (si un mazo específico está activo) o gestiona tus mazos.`, "info", 0);
        }

        function generateAndDisplayOptions() {
            multipleChoiceOptionsEl.innerHTML = '';
            if (currentStudyCards.length === 0 || currentCardIndex >= currentStudyCards.length) return;

            const correctAnswer = currentStudyCards[currentCardIndex].answer;
            let options = [correctAnswer];
            
            // Pool of distractors: all answers from all user decks, excluding the correct one
            let distractorPool = [];
            userDecks.forEach(deck => {
                deck.cards.forEach(card => {
                    if (card.answer.toLowerCase() !== correctAnswer.toLowerCase()) {
                        distractorPool.push(card.answer);
                    }
                });
            });
            // Also consider learned cards as potential distractors if needed, but might be too many
            // learnedFlashcards.forEach(card => {
            //     if (card.answer.toLowerCase() !== correctAnswer.toLowerCase()) {
            //         distractorPool.push(card.answer);
            //     }
            // });

            distractorPool = [...new Set(distractorPool)]; // Unique distractors
            shuffleArray(distractorPool);

            for (let i = 0; i < Math.min(MIN_CARDS_FOR_MULTIPLE_CHOICE - 1, distractorPool.length); i++) {
                options.push(distractorPool[i]);
            }

            // If not enough options (e.g., very few unique answers overall), fill with placeholders or repeat logic carefully
            // This part can be tricky. For now, if options < 3, it will show fewer.
            // A better approach for few cards: use direct input or fewer options.
            // The current logic: if currentStudyCards.length < MIN_CARDS_FOR_MULTIPLE_CHOICE, it might show fewer options.
            // The feedback message already warns about this.

            shuffleArray(options);
            options.forEach(optionText => {
                const button = document.createElement('button');
                button.classList.add('btn', 'option-btn');
                button.textContent = optionText;
                button.dataset.answer = optionText; // Store answer for checking
                button.addEventListener('click', handleOptionClick);
                multipleChoiceOptionsEl.appendChild(button);
            });
        }

        function handleOptionClick(event) {
            const clickedButton = event.target;
            const selectedAnswer = clickedButton.dataset.answer;
            const cardBeingStudied = currentStudyCards[currentCardIndex];
            const correctAnswer = cardBeingStudied.answer;

            const optionButtons = multipleChoiceOptionsEl.querySelectorAll('.option-btn');
            optionButtons.forEach(btn => btn.disabled = true); // Disable all options
            nextCardBtn.classList.remove('hidden');

            if (selectedAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                clickedButton.classList.add('selected-correct');
                checkHourlyPointLimit(); // Check before awarding points

                const activeDeckIsSpecific = activeDeckId && activeDeckId !== MAIN_DECK_ID;
                const currentDeckForPointsCheck = activeDeckIsSpecific ? userDecks.find(d=>d.id === activeDeckId) : null;
                const canEarnPoints = activeDeckIsSpecific ? (currentDeckForPointsCheck && currentDeckForPointsCheck.cards.length >= MIN_CARDS_FOR_POINTS) : true; // Points always possible for Main Deck if it has cards

                if (!canEarnPoints && activeDeckIsSpecific) {
                    showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 Pero el mazo "${getActiveDeckName()}" necesita al menos ${MIN_CARDS_FOR_POINTS} palabras para ganar puntos. (Tiene ${currentDeckForPointsCheck.cards.length})`, "info", 4000);
                } else if (pointsThisHour >= MAX_POINTS_PER_HOUR) {
                    showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 Has alcanzado el límite de ${MAX_POINTS_PER_HOUR} puntos esta hora. Intenta más tarde.`, "info", 4000);
                } else {
                    const pointsToAdd = POINTS_PER_CORRECT_ANSWER;
                    let actualPointsAdded = pointsToAdd;
                    if (pointsThisHour + pointsToAdd > MAX_POINTS_PER_HOUR) {
                        actualPointsAdded = MAX_POINTS_PER_HOUR - pointsThisHour;
                        showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 +${actualPointsAdded} puntos. (Límite horario alcanzado)`, "correct", 3000);
                    } else {
                        showTemporaryFeedback(feedbackTextEl, "¡Correcto! 🎉", "correct", 2000);
                    }
                    score += actualPointsAdded;
                    pointsThisHour += actualPointsAdded;
                    updateScoreDisplay();
                }
                learnedBtn.classList.remove('hidden'); // Show "¡Lo sé!" button
                if (correctSound) { correctSound.currentTime = 0; correctSound.play().catch(console.error); }
            } else {
                clickedButton.classList.add('selected-incorrect');
                // Highlight the actual correct answer
                optionButtons.forEach(btn => {
                    if (btn.dataset.answer.toLowerCase() === correctAnswer.toLowerCase()) {
                        btn.classList.add('actual-correct');
                    }
                });
                const pointsToDeduct = Math.floor(POINTS_PER_CORRECT_ANSWER / 2); // Deduct fewer points
                score -= pointsToDeduct;
                if (score < 0) score = 0;
                updateScoreDisplay();
                showTemporaryFeedback(feedbackTextEl, `Incorrecto. Respuesta correcta: ${correctAnswer}. Has perdido ${pointsToDeduct} puntos. 📉`, "incorrect", 3500);
                learnedBtn.classList.add('hidden'); // Hide "¡Lo sé!"
                if (incorrectSound) { incorrectSound.currentTime = 0; incorrectSound.play().catch(console.error); }
            }
            nextCardBtn.focus();
            saveGameData();
        }

        function markAsLearned() {
            if (currentStudyCards.length === 0 || currentCardIndex >= currentStudyCards.length) return;

            const cardToLearn = { ...currentStudyCards[currentCardIndex] }; // Copy the card
            let feedbackMessage = "";

            // Check if already learned (based on question)
            if (learnedFlashcards.findIndex(card => card.question.toLowerCase() === cardToLearn.question.toLowerCase()) === -1) {
                
                // Add to global learned list
                learnedFlashcards.push({ question: cardToLearn.question, answer: cardToLearn.answer });

                // Remove from original deck
                let originalDeckIdToRemoveFrom = null;
                if (activeDeckId === MAIN_DECK_ID) {
                    originalDeckIdToRemoveFrom = cardToLearn.originalDeckId; // originalDeckId was added when MAIN_DECK was formed
                } else {
                    originalDeckIdToRemoveFrom = activeDeckId;
                }

                if (originalDeckIdToRemoveFrom) {
                    const deck = userDecks.find(d => d.id === originalDeckIdToRemoveFrom);
                    if (deck) {
                        deck.cards = deck.cards.filter(c => c.question.toLowerCase() !== cardToLearn.question.toLowerCase());
                    }
                }
                
                checkHourlyPointLimit();
                const activeDeckIsSpecific = activeDeckId && activeDeckId !== MAIN_DECK_ID;
                const currentDeckForPointsCheck = activeDeckIsSpecific ? userDecks.find(d=>d.id === activeDeckId) : null;
                // Points for learning are given if the card was in a specific deck with enough cards, or if from Main Deck.
                const canEarnPointsForLearning = activeDeckIsSpecific ? (currentDeckForPointsCheck && currentDeckForPointsCheck.cards.length + 1 >= MIN_CARDS_FOR_POINTS) : true; // +1 because it's about to be removed

                if (!canEarnPointsForLearning && activeDeckIsSpecific) {
                     feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. El mazo necesita ${MIN_CARDS_FOR_POINTS} palabras para ganar puntos por aprender.`;
                } else if (pointsThisHour >= MAX_POINTS_PER_HOUR) {
                    feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. Límite de ${MAX_POINTS_PER_HOUR} puntos/hora alcanzado.`;
                } else {
                    const pointsToAdd = POINTS_FOR_LEARNED_WORD;
                    let actualPointsAdded = pointsToAdd;
                    if (pointsThisHour + pointsToAdd > MAX_POINTS_PER_HOUR) {
                        actualPointsAdded = MAX_POINTS_PER_HOUR - pointsThisHour;
                        feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. +${actualPointsAdded} pts! (Límite horario alcanzado)`;
                    } else {
                         feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. +${actualPointsAdded} pts!`;
                    }
                    score += actualPointsAdded;
                    pointsThisHour += actualPointsAdded;
                    updateScoreDisplay();
                }
                showTemporaryFeedback(feedbackTextEl, feedbackMessage, "info", 3500);
            } else {
                showTemporaryFeedback(feedbackTextEl, `"${cardToLearn.question}" ya estaba marcada como aprendida.`, "info", 2500);
            }
            
            // Update currentStudyCards by removing the learned card
            currentStudyCards.splice(currentCardIndex, 1);
            
            saveGameData();
            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.remove('hidden');
            nextCardBtn.focus();

            if (currentStudyCards.length === 0) {
                handleNoCardsInActiveDeckState();
            } else {
                // If currentCardIndex was last, loop to 0. Otherwise, it effectively moves to next.
                if (currentCardIndex >= currentStudyCards.length) { 
                    currentCardIndex = 0;
                    // Optionally shuffle if deck was not shuffled on load and now is empty
                    // updateCurrentStudyCards(); // This would reshuffle if needed
                }
                // No need to call moveToNextCard(false) as the card is removed, effectively advancing.
                // Just display the card at the current (potentially new) currentCardIndex
                displayCard(); 
            }
            updateStudyPanelWordManagementButtons(); // Reflect card count change
        }


        function moveToNextCard() { // shuffleDeckIfNeeded is implicitly true by updateCurrentStudyCards
            if (currentStudyCards.length === 0) {
                handleNoCardsInActiveDeckState();
                return;
            }
            currentCardIndex++;
            if (currentCardIndex >= currentStudyCards.length) {
                currentCardIndex = 0;
                // Re-populate and shuffle currentStudyCards for the next round through the deck
                updateCurrentStudyCards(); 
                if (currentStudyCards.length > 0 && (!feedbackTextEl.textContent || feedbackTextEl.textContent.includes("¡Correcto!") || feedbackTextEl.textContent.includes("Respuesta correcta:"))) {
                    showTemporaryFeedback(feedbackTextEl, "¡Mazo barajado para la siguiente ronda!", "info", 1500);
                }
            }
            displayCard();
            // saveGameData(); // Not strictly needed here as displayCard doesn't change persistent data
        }
        
        function checkHourlyPointLimit() {
            const now = Date.now();
            if (now - lastPointResetTime >= ONE_HOUR_IN_MS) {
                pointsThisHour = 0;
                lastPointResetTime = now;
                saveGameData(); // Save reset time
            }
        }

        // --- UI Updates for Stats ---
        function updateScoreDisplay() { scoreEl.textContent = score; } // Renamed from updateScore
        function updateFertilizerCountDisplay() { // Renamed
            fertilizerCountEl.textContent = fertilizerCount;
            const currentLevelData = TREE_LEVEL_DATA[treeLevel];
            useFertilizerBtn.disabled = treeLevel >= MAX_TREE_LEVEL_INDEX || 
                                       (treeLevel < MAX_TREE_LEVEL_INDEX && fertilizerCount < currentLevelData.fertilizerToNext);
            useFertilizerBtn.classList.toggle('btn-disabled', useFertilizerBtn.disabled);
        }
        function updateApplesCountDisplay() { applesCountEl.textContent = `${applesCount} �`; } // Renamed
        function updateApplesPerDayDisplay() { applesPerDayEl.textContent = `${applesPerDay} / día`; } // Renamed

        function updateTreeVisual() {
            const currentLevelData = TREE_LEVEL_DATA[treeLevel];
            const gifPath = `gifs/${currentLevelData.gifName}`; // Ensure gifs folder exists
            treeDisplayEl.innerHTML = `<img src="${gifPath}" alt="Árbol de progreso: Nivel ${currentLevelData.name}" class="tree-gif mx-auto">`;
            treeLevelTextEl.textContent = `Nivel: ${currentLevelData.name}`;
            applesPerDay = currentLevelData.applesPerDay;
            updateApplesPerDayDisplay();
            if (treeLevel >= MAX_TREE_LEVEL_INDEX) {
                useFertilizerBtn.textContent = "¡Árbol Maximizado!";
                useFertilizerBtn.disabled = true;
            } else {
                useFertilizerBtn.textContent = `Crecer (${currentLevelData.fertilizerToNext} Fert.)`;
                useFertilizerBtn.disabled = fertilizerCount < currentLevelData.fertilizerToNext;
            }
            useFertilizerBtn.classList.toggle('btn-disabled', useFertilizerBtn.disabled);
        }

        function growTree() {
            if (treeLevel >= MAX_TREE_LEVEL_INDEX) {
                showTemporaryFeedback(feedbackTextEl, "Tu árbol ya está en el nivel máximo.", "info", 2500);
                return;
            }
            const requiredFertilizer = TREE_LEVEL_DATA[treeLevel].fertilizerToNext;
            if (fertilizerCount >= requiredFertilizer) {
                fertilizerCount -= requiredFertilizer;
                treeLevel++;
                updateTreeVisual();
                updateFertilizerCountDisplay();
                showTemporaryFeedback(feedbackTextEl, `¡Tu árbol creció a ${TREE_LEVEL_DATA[treeLevel].name}!`, "correct", 2500);
                treeDisplayEl.style.transform = 'scale(1.15)';
                setTimeout(() => { treeDisplayEl.style.transform = 'scale(1)'; }, 300);
                saveGameData();
            } else {
                 showTemporaryFeedback(feedbackTextEl, `Necesitas ${requiredFertilizer - fertilizerCount} más fertilizante.`, "info", 3000);
            }
        }
        
        // --- Apple Generation (Unchanged in logic, uses updated display functions) ---
        function checkAndGenerateApples() {
            if (applesPerDay <= 0) {
                updateAppleCountdown(); return;
            }
            const now = Date.now();
            const timeElapsedMs = now - lastAppleGenerationTime;
            const generationIntervalMs = ((24 * 60 * 60) / applesPerDay) * 1000;

            if (timeElapsedMs >= generationIntervalMs) {
                const applesToGenerate = Math.floor(timeElapsedMs / generationIntervalMs);
                applesCount += applesToGenerate;
                lastAppleGenerationTime += applesToGenerate * generationIntervalMs; // Increment by time for generated apples
                updateApplesCountDisplay();
                showTemporaryFeedback(feedbackTextEl, `¡Cosechaste ${applesToGenerate} manzana(s) 🍎!`, "correct", 2000);
                saveGameData();
            }
            updateAppleCountdown();
        }

        function updateAppleCountdown() {
            if (appleCountdownInterval) clearInterval(appleCountdownInterval);
            if (applesPerDay <= 0) {
                appleCountdownEl.textContent = "--:--:--"; return;
            }

            function calculateAndDisplayCountdown() {
                const now = Date.now();
                const generationIntervalMs = ((24 * 60 * 60) / applesPerDay) * 1000;
                const timeSinceLastApple = now - lastAppleGenerationTime;

                if (timeSinceLastApple >= generationIntervalMs && applesPerDay > 0) { // Apples are due
                    checkAndGenerateApples(); // This will update lastAppleGenerationTime
                    // Recalculate timeToNextAppleMs based on the new lastAppleGenerationTime
                    const newTimeSinceLastApple = now - lastAppleGenerationTime;
                    let timeToNextAppleMs = generationIntervalMs - (newTimeSinceLastApple % generationIntervalMs);
                    if (timeToNextAppleMs <= 0) timeToNextAppleMs = generationIntervalMs; // Ensure positive for next cycle
                    
                    const h = String(Math.floor((timeToNextAppleMs / (1000 * 60 * 60)) % 24)).padStart(2, '0');
                    const m = String(Math.floor((timeToNextAppleMs / (1000 * 60)) % 60)).padStart(2, '0');
                    const s = String(Math.floor((timeToNextAppleMs / 1000) % 60)).padStart(2, '0');
                    appleCountdownEl.textContent = `${h}:${m}:${s}`;
                    return; // Exit after recalculation
                }
                
                let timeToNextAppleMs = generationIntervalMs - (timeSinceLastApple % generationIntervalMs);

                if (timeToNextAppleMs <= 1000 && timeToNextAppleMs > 0) { // About to generate
                     appleCountdownEl.textContent = "¡Ahora!"; return;
                }
                if (timeToNextAppleMs <= 0) timeToNextAppleMs = generationIntervalMs; // Should not happen if above check is fine

                const h = String(Math.floor((timeToNextAppleMs / (1000 * 60 * 60)) % 24)).padStart(2, '0');
                const m = String(Math.floor((timeToNextAppleMs / (1000 * 60)) % 60)).padStart(2, '0');
                const s = String(Math.floor((timeToNextAppleMs / 1000) % 60)).padStart(2, '0');
                appleCountdownEl.textContent = `${h}:${m}:${s}`;
            }
            calculateAndDisplayCountdown(); // Initial call
            appleCountdownInterval = setInterval(calculateAndDisplayCountdown, 1000);
        }

        // --- Word Management in Study Panel (operates on active specific deck) ---
        function updateStudyPanelWordManagementButtons() {
            const isSpecificDeckActive = activeDeckId && activeDeckId !== MAIN_DECK_ID;
            showAddCardModalBtn.disabled = !isSpecificDeckActive;
            showDeleteCardModalBtn.disabled = !isSpecificDeckActive;
            
            showAddCardModalBtn.classList.toggle('btn-disabled', !isSpecificDeckActive);
            showDeleteCardModalBtn.classList.toggle('btn-disabled', !isSpecificDeckActive);

            if (!isSpecificDeckActive) {
                addCardModal.querySelector('h3').textContent = "Añadir Palabra (Selecciona un mazo específico)";
                deleteCardModal.querySelector('h3').textContent = "Eliminar Palabra (Selecciona un mazo específico)";
            } else {
                addCardModal.querySelector('h3').textContent = `Nueva Palabra (a "${getActiveDeckName()}")`;
                deleteCardModal.querySelector('h3').textContent = `Eliminar Palabra (de "${getActiveDeckName()}")`;
            }
        }
        
        showAddCardModalBtn.addEventListener('click', () => {
            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) {
                showTemporaryFeedback(feedbackTextEl, "Selecciona un mazo específico para añadir palabras.", "info", 3000);
                return;
            }
            newQuestionInput.value = ''; newAnswerInput.value = '';
            clearFeedback(addCardFeedbackEl);
            addCardModal.querySelector('h3').textContent = `Nueva Palabra (a "${getActiveDeckName()}")`;
            openModal(addCardModal);
            newQuestionInput.focus();
        });

        cancelAddCardBtn.addEventListener('click', () => closeModal(addCardModal));

        saveCardBtn.addEventListener('click', () => { // Adds card to active specific deck
            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) {
                showTemporaryFeedback(addCardFeedbackEl, "Error: No hay un mazo específico activo.", "incorrect");
                return;
            }
            const activeDeck = userDecks.find(d => d.id === activeDeckId);
            if (!activeDeck) {
                showTemporaryFeedback(addCardFeedbackEl, "Error: Mazo activo no encontrado.", "incorrect");
                return;
            }

            const newQ = newQuestionInput.value.trim();
            const newA = newAnswerInput.value.trim();
            if (newQ && newA) {
                // Check if card exists in *any* deck or learned list to maintain global uniqueness if desired
                // For now, check only in current deck for simplicity, allowing same card in different decks.
                // A global check would be:
                // const cardExistsGlobally = userDecks.some(deck => deck.cards.some(c => c.question.toLowerCase() === newQ.toLowerCase())) ||
                //                           learnedFlashcards.some(c => c.question.toLowerCase() === newQ.toLowerCase());
                // if (cardExistsGlobally) { ... }

                if (activeDeck.cards.some(c => c.question.toLowerCase() === newQ.toLowerCase())) {
                    showTemporaryFeedback(addCardFeedbackEl, `La palabra "${newQ}" ya existe en el mazo "${activeDeck.name}".`, "incorrect", 2500);
                    return;
                }
                activeDeck.cards.push({ question: newQ, answer: newA });
                updateCurrentStudyCards(); // Refresh the study pool if it was this deck
                saveGameData();
                showTemporaryFeedback(addCardFeedbackEl, "¡Palabra añadida con éxito!", "correct", 1500);
                newQuestionInput.value = ''; newAnswerInput.value = '';
                newQuestionInput.focus();
                
                // If the study panel was showing "no cards", refresh it
                if (questionTextEl.textContent.startsWith("¡No hay palabras en")) {
                    displayCard();
                }
                updateDefaultFeedbackMessage(); // Update info messages if card count changed eligibility
                populateDecksListInModal(); // Update card count in decks modal
            } else {
                showTemporaryFeedback(addCardFeedbackEl, "Ambos campos son obligatorios.", "incorrect", 2000);
            }
        });

        showDeleteCardModalBtn.addEventListener('click', () => {
            if (!activeDeckId || activeDeckId === MAIN_DECK_ID) {
                showTemporaryFeedback(feedbackTextEl, "Selecciona un mazo específico para eliminar palabras.", "info", 3000);
                return;
            }
            deleteCardModal.querySelector('h3').textContent = `Eliminar Palabra (de "${getActiveDeckName()}")`;
            populateDeleteCardList(); 
            openModal(deleteCardModal); 
        });
        cancelDeleteCardBtn.addEventListener('click', () => closeModal(deleteCardModal));
        
        function populateDeleteCardList() { // Shows cards from active specific deck
            deleteCardListContainerEl.innerHTML = '';
            clearFeedback(deleteFeedbackEl);
            selectAllDeleteBtn.classList.add('hidden'); // Hide by default

            const activeDeck = userDecks.find(d => d.id === activeDeckId);
            if (!activeDeck || activeDeck.cards.length === 0) {
                noCardsToDeleteMsgEl.textContent = `No hay palabras para eliminar en el mazo "${getActiveDeckName()}".`;
                noCardsToDeleteMsgEl.classList.remove('hidden');
                confirmDeleteCardBtn.disabled = true;
                confirmDeleteCardBtn.classList.add('btn-disabled');
                return;
            }

            noCardsToDeleteMsgEl.classList.add('hidden');
            confirmDeleteCardBtn.disabled = false;
            confirmDeleteCardBtn.classList.remove('btn-disabled');
            if (activeDeck.cards.length > 1) selectAllDeleteBtn.classList.remove('hidden');
            selectAllDeleteBtn.textContent = 'Seleccionar Todas';

            activeDeck.cards.sort((a, b) => a.question.localeCompare(b.question)).forEach((card, index) => {
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center p-1.5 hover:bg-gray-50 rounded';
                listItem.innerHTML = `
                    <input type="checkbox" id="delete-card-${index}" value="${card.question}" class="mr-2 rounded border-gray-300 text-[var(--duo-blue)] focus:ring-[var(--duo-blue)] h-4 w-4">
                    <label for="delete-card-${index}" class="flex-grow text-sm text-[var(--duo-text-dark)] cursor-pointer">
                        ${card.question} - ${card.answer}
                    </label>`;
                deleteCardListContainerEl.appendChild(listItem);
            });
        }

        confirmDeleteCardBtn.addEventListener('click', () => {
            const activeDeck = userDecks.find(d => d.id === activeDeckId);
            if (!activeDeck) {
                showTemporaryFeedback(deleteFeedbackEl, "Error: Mazo activo no encontrado.", "incorrect");
                return;
            }

            const checkboxes = deleteCardListContainerEl.querySelectorAll('input[type="checkbox"]:checked');
            if (checkboxes.length === 0) {
                showTemporaryFeedback(deleteFeedbackEl, "Selecciona al menos una palabra para eliminar.", "incorrect", 2500);
                return;
            }
            const questionsToDelete = Array.from(checkboxes).map(cb => cb.value.toLowerCase());
            
            activeDeck.cards = activeDeck.cards.filter(card => !questionsToDelete.includes(card.question.toLowerCase()));
            
            updateCurrentStudyCards(); // Refresh study pool
            saveGameData();
            showTemporaryFeedback(deleteFeedbackEl, `${questionsToDelete.length} palabra(s) eliminada(s) de "${activeDeck.name}".`, "correct", 2000);
            
            if (currentStudyCards.length > 0) {
                // If current card was deleted, reset index. displayCard will handle it.
                if (questionsToDelete.includes(questionTextEl.textContent.toLowerCase())) {
                    currentCardIndex = 0; 
                }
                displayCard();
            } else {
                handleNoCardsInActiveDeckState();
            }
            populateDeleteCardList(); // Refresh modal list
            updateDefaultFeedbackMessage();
            populateDecksListInModal(); // Update card count in decks modal
        });

        selectAllDeleteBtn.addEventListener('click', () => {
            const checkboxes = deleteCardListContainerEl.querySelectorAll('input[type="checkbox"]');
            if (checkboxes.length === 0) return;
            const shouldSelectAll = selectAllDeleteBtn.textContent === 'Seleccionar Todas';
            checkboxes.forEach(checkbox => { checkbox.checked = shouldSelectAll; });
            selectAllDeleteBtn.textContent = shouldSelectAll ? 'Deseleccionar Todas' : 'Seleccionar Todas';
        });

        // Review Learned Modal (operates on global learnedFlashcards)
        showReviewLearnedModalBtn.addEventListener('click', () => {
            populateReviewLearnedList();
            openModal(reviewLearnedModal);
        });
        closeReviewLearnedBtn.addEventListener('click', () => closeModal(reviewLearnedModal));

        function populateReviewLearnedList() {
            reviewLearnedListContainerEl.innerHTML = '';
            clearFeedback(reviewModalFeedbackEl);
            if (learnedFlashcards.length === 0) {
                noLearnedCardsMsgEl.classList.remove('hidden');
                return;
            }
            noLearnedCardsMsgEl.classList.add('hidden');
            learnedFlashcards.sort((a, b) => a.question.localeCompare(b.question)).forEach((card) => {
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center justify-between p-1.5 hover:bg-gray-50 rounded';
                listItem.innerHTML = `
                    <span class="text-sm text-[var(--duo-text-dark)]">${card.question} - ${card.answer}</span>
                    <button data-question="${card.question}" class="btn btn-danger btn-sm remove-learned-btn !py-1 !px-2 !text-xs">Olvidar</button>`;
                reviewLearnedListContainerEl.appendChild(listItem);
            });
            reviewLearnedListContainerEl.querySelectorAll('.remove-learned-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const questionToForget = e.target.dataset.question;
                    const cardIndexInLearned = learnedFlashcards.findIndex(c => c.question.toLowerCase() === questionToForget.toLowerCase());
                    
                    if (cardIndexInLearned > -1) {
                        const forgottenCard = learnedFlashcards.splice(cardIndexInLearned, 1)[0];
                        
                        // Decide where to put the forgotten card:
                        // Option 1: Add to the currently active specific deck if one exists
                        // Option 2: Add to its originalDeckId if stored (more complex)
                        // Option 3: Create/add to a default "Forgotten" or "Inbox" deck
                        // For now, Option 1:
                        let movedToDeckName = null;
                        if (activeDeckId && activeDeckId !== MAIN_DECK_ID) {
                            const targetDeck = userDecks.find(d => d.id === activeDeckId);
                            if (targetDeck && !targetDeck.cards.some(c => c.question.toLowerCase() === forgottenCard.question.toLowerCase())) {
                                targetDeck.cards.push({ question: forgottenCard.question, answer: forgottenCard.answer });
                                movedToDeckName = targetDeck.name;
                            }
                        } else if (userDecks.length > 0) { // No specific deck active, or main deck active, add to first deck
                             const targetDeck = userDecks[0];
                             if (!targetDeck.cards.some(c => c.question.toLowerCase() === forgottenCard.question.toLowerCase())) {
                                targetDeck.cards.push({ question: forgottenCard.question, answer: forgottenCard.answer });
                                movedToDeckName = targetDeck.name;
                            }
                        }
                        // If no decks exist, card is just removed from learned. User needs to create a deck.
                        
                        updateCurrentStudyCards(); // In case active deck was affected
                        saveGameData();
                        populateReviewLearnedList(); // Refresh this modal
                        if (movedToDeckName) {
                            showTemporaryFeedback(reviewModalFeedbackEl, `"${questionToForget}" movida de nuevo al mazo "${movedToDeckName}".`, "info", 2500);
                            populateDecksListInModal(); // Update card counts
                        } else {
                             showTemporaryFeedback(reviewModalFeedbackEl, `"${questionToForget}" olvidada.`, "info", 2000);
                        }
                        if (currentStudyCards.length > 0 && questionTextEl.textContent.startsWith("¡No hay palabras")) {
                            displayCard(); // Refresh study panel if it was empty
                        }
                         updateDefaultFeedbackMessage();
                    }
                });
            });
        }

        // --- Shop Logic (largely unchanged, but deck purchase adds to userDecks) ---
        openShopBtn.addEventListener('click', () => {
            clearFeedback(shopFeedbackEl);
            updateShopCosts();
            loadShopDecks(); // This now interacts with userDecks
            openModal(shopModal);
        });
        closeShopBtn.addEventListener('click', () => closeModal(shopModal));
        buyFertilizerShopBtn.addEventListener('click', () => {
            if (score >= FERTILIZER_SHOP_COST) {
                score -= FERTILIZER_SHOP_COST;
                fertilizerCount++;
                updateScoreDisplay();
                updateFertilizerCountDisplay();
                saveGameData();
                showTemporaryFeedback(shopFeedbackEl, "¡Fertilizante comprado!", "correct", 2000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, "Puntos insuficientes.", "incorrect", 2000);
            }
        });
        buyAppleShopBtn.addEventListener('click', () => {
            if (score >= APPLE_SHOP_COST) {
                score -= APPLE_SHOP_COST;
                applesCount++;
                updateScoreDisplay();
                updateApplesCountDisplay();
                saveGameData();
                showTemporaryFeedback(shopFeedbackEl, "¡Manzana comprada! 🍎", "correct", 2000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, "Puntos insuficientes.", "incorrect", 2000);
            }
        });
        function updateShopCosts() {
            fertilizerShopCostDisplayEl.textContent = FERTILIZER_SHOP_COST;
            appleShopCostDisplayEl.textContent = APPLE_SHOP_COST;
        }
        async function loadShopDecks() {
            shopDecksContainerEl.innerHTML = '';
            loadingDecksMsgEl.classList.remove('hidden');
            let decksDisplayed = 0;

            for (const deckDef of SHOP_DECK_DEFINITIONS) {
                try {
                    const response = await fetch(deckDef.fileName + `?v=${Date.now()}`); // Cache bust
                    if (!response.ok) throw new Error(`HTTP error ${response.status}`);
                    const deckData = await response.json();
                    shopDecksData[deckDef.id] = deckData; // Store fetched data

                    const deckItemEl = document.createElement('div');
                    deckItemEl.className = 'p-2.5 border rounded-lg bg-gray-50';
                    deckItemEl.innerHTML = `
                        <div class="flex justify-between items-center">
                            <div>
                                <h4 class="font-semibold text-sm">${deckData.name}</h4>
                                <p class="text-xs text-gray-500">Costo: <span class="deck-cost">${deckData.cost}</span> 🍎 | Palabras: ${deckData.cards.length}</p>
                            </div>
                            <button class="btn btn-primary btn-sm buy-deck-btn !py-1 !px-2 !text-xs" data-deck-id="${deckDef.id}">Comprar</button>
                        </div>`;
                    shopDecksContainerEl.appendChild(deckItemEl);
                    decksDisplayed++;
                } catch (error) {
                    console.error(`Error cargando mazo de tienda ${deckDef.fileName}:`, error);
                }
            }
            loadingDecksMsgEl.classList.add('hidden');
            if (decksDisplayed === 0 && SHOP_DECK_DEFINITIONS.length > 0) { /* ... error message ... */ }
            
            shopDecksContainerEl.querySelectorAll('.buy-deck-btn').forEach(button => {
                button.addEventListener('click', (e) => handleBuyShopDeck(e.target.dataset.deckId));
            });
        }

        function handleBuyShopDeck(deckId) {
            const deckDataFromShop = shopDecksData[deckId];
            if (!deckDataFromShop) {
                showTemporaryFeedback(shopFeedbackEl, "Error: Mazo de tienda no encontrado.", "incorrect"); return;
            }
            if (applesCount >= deckDataFromShop.cost) {
                // Check if a deck with the same name already exists
                if (userDecks.some(d => d.name.toLowerCase() === deckDataFromShop.name.toLowerCase())) {
                     showTemporaryFeedback(shopFeedbackEl, `Ya tienes un mazo llamado "${deckDataFromShop.name}". Renombra el existente o este no se añadirá.`, "info", 4000);
                     return; // Or merge, or rename automatically - for now, prevent duplicate names from shop
                }

                applesCount -= deckDataFromShop.cost;
                const newDeckFromShop = {
                    id: generateUUID(),
                    name: deckDataFromShop.name,
                    cards: deckDataFromShop.cards.map(c => ({...c})) // Ensure new card objects
                };
                userDecks.push(newDeckFromShop);
                
                updateApplesCountDisplay();
                saveGameData();
                populateDecksListInModal(); // Update decks modal if it's open
                showTemporaryFeedback(shopFeedbackEl, `¡Mazo "${deckDataFromShop.name}" comprado y añadido a tus mazos!`, "correct", 3000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, `Manzanas insuficientes.`, "incorrect");
            }
        }

        // --- Global Event Listeners & Init ---
        // Deck Modal listeners
        openDecksModalBtn.addEventListener('click', () => {
            populateDecksListInModal();
            updateActiveDeckDisplay(); // Ensure modal display is current
            clearFeedback(deckManagementFeedbackEl);
            openModal(decksModal);
        });
        closeDecksModalBtn.addEventListener('click', () => closeModal(decksModal));
        openAddNewDeckModalBtn.addEventListener('click', handleOpenAddNewDeckModal);
        selectMainDeckBtn.addEventListener('click', handleSelectMainDeckForStudy);

        // Add/Edit Deck Name Modal listeners
        saveDeckNameBtn.addEventListener('click', handleSaveDeckName);
        cancelAddEditDeckNameBtn.addEventListener('click', () => closeModal(addEditDeckNameModal));

        // Study Panel Action Listeners
        learnedBtn.addEventListener('click', markAsLearned);
        nextCardBtn.addEventListener('click', () => moveToNextCard());
        
        // Sidebar Action Listeners
        useFertilizerBtn.addEventListener('click', growTree);
        exportProgressBtn.addEventListener('click', exportProgress);
        importProgressBtn.addEventListener('click', () => importProgressInput.click());
        importProgressInput.addEventListener('change', handleImportFile);
        downloadWordsBtn.addEventListener('click', () => {
            // TODO: Adapt downloadWordsBtn to download from active deck or all decks
            // For now, it will download from the 'currentStudyCards' which reflects active/main deck
            if (currentStudyCards.length === 0) {
                showTemporaryFeedback(importExportFeedbackEl, "No hay palabras en el mazo activo para descargar.", "info"); return;
            }
            let textContent = `=== Palabras del Mazo: ${getActiveDeckName()} ===\r\n`;
            textContent += currentStudyCards.map(c => `${c.question}: ${c.answer}`).join('\r\n');
            
            if (learnedFlashcards.length > 0) {
                textContent += "\r\n\r\n=== Palabras Aprendidas (Global) ===\r\n";
                textContent += learnedFlashcards.map(c => `${c.question}: ${c.answer}`).join('\r\n');
            }

            const blob = new Blob([textContent], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `flashcards_${getActiveDeckName().replace(/[^a-z0-9]/gi, '_').toLowerCase()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
            showTemporaryFeedback(importExportFeedbackEl, "Archivo de palabras descargado.", "correct");
        });
        
        function initGameVisuals() {
            updateCurrentStudyCards(); // Sets up currentStudyCards based on activeDeckId
            displayCard(); // Displays the first card or no-card state
            updateAllStatsDisplays(); // Updates score, fertilizer, apples, tree visuals
            checkAndGenerateApples(); // Start apple countdown
            updateStudyPanelWordManagementButtons(); // Enable/disable add/delete based on active deck
        }

        function updateAllStatsDisplays() {
            updateScoreDisplay();
            updateFertilizerCountDisplay();
            updateApplesCountDisplay();
            updateTreeVisual(); // This also calls updateApplesPerDayDisplay
        }
        
        async function initGame() {
            await initCryptoKey(); // Setup encryption key first
            loadGameData();       // Load all game data including decks
            initGameVisuals();    // Setup UI based on loaded data
            
            if (!window.appleCheckIntervalId) { // Ensure interval is only set once
                 window.appleCheckIntervalId = setInterval(checkAndGenerateApples, CHECK_APPLES_INTERVAL);
            }
        }

        window.onload = initGame;

    </script>
</body>
</html>
