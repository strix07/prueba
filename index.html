<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">

    <!-- SEO: Título optimizado -->
    <title>Flashcards de Inglés Fácil: Aprende Vocabulario Interactivo</title>

    <!-- SEO: Meta Descripción -->
    <meta name="description" content="Mejora tu vocabulario en inglés de forma divertida y efectiva con nuestras flashcards interactivas. Aprende nuevas palabras, gestiona tu progreso y haz crecer tu árbol de conocimiento. ¡Empieza a estudiar inglés fácil hoy!">

    <!-- SEO: Meta Palabras Clave (opcional, menos impacto en Google) -->
    <meta name="keywords" content="flashcards inglés, aprender inglés, vocabulario inglés, inglés fácil, tarjetas de memoria, estudiar inglés, memorizar palabras, app inglés, aplicación para aprender inglés, mejorar inglés">

    <!-- SEO: Canonical URL - ¡REEMPLAZA ESTO CON TU URL REAL! -->
    <link rel="canonical" href="https://flashcards-inglesfacil.netlify.app/">

    <!-- SEO: Robots meta tag (generalmente es el default, pero explícito es bueno) -->
    <meta name="robots" content="index, follow">

    <script src="https://cdn.tailwindcss.com"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6819141919218513"
     crossorigin="anonymous"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@400;600;700;800&display=swap" rel="stylesheet">
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">

    <!-- SEO: Datos Estructurados JSON-LD para WebApplication -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "WebApplication",
      "name": "Flashcards de Inglés Fácil",
      "description": "Aplicación web interactiva con flashcards para aprender y memorizar vocabulario en inglés de forma fácil y divertida, con seguimiento de progreso y elementos de gamificación como un árbol de palabras.",
      "applicationCategory": "EducationalApplication, GameApplication",
      "operatingSystem": "Web",
      "browserRequirements": "Requires HTML5 support, JavaScript enabled.",
      "url": "https://www.tu-dominio.com/ruta-a-esta-app/", /* ¡REEMPLAZA ESTO! */
      "offers": {
        "@type": "Offer",
        "price": "0",
        "priceCurrency": "USD"
      },
      "author": {
        "@type": "Person", /* O "Person" si eres un desarrollador individual */
        "name": "Nemus" /* ¡REEMPLAZA ESTO! */
      },
      "keywords": "flashcards, inglés, aprender inglés, vocabulario, estudiar, memorizar, aplicación educativa, juego educativo"
    }
    </script>

    <style>
        :root {
            --duo-green: #4CAF50;
            --duo-green-dark: #388E3C;
            --duo-green-light: #66BB6A;
            --duo-blue: #1cb0f6;
            --duo-blue-dark: #138bc4;
            --duo-red: #ff4b4b;
            --duo-red-dark: #fa2d2d;
            --duo-orange: #ff9600;
            --duo-orange-dark: #e88800;
            --duo-yellow: #ffc800;
            --duo-gray-lightest: #f7f7f7;
            --duo-gray-light: #e5e5e5;
            --duo-gray-medium: #afafaf;
            --duo-gray-dark: #777777;
            --duo-text-dark: #4b4b4b;
            --duo-text-light: #ffffff;
            --duo-correct-bg: #d7ffb8;
            --duo-correct-text: #58a700;
            --duo-incorrect-bg: #ffdfe0;
            --duo-incorrect-text: #ea2b2b;
        }

        html, body {
            margin: 0;
            font-family: 'Nunito', sans-serif;
            background-color: var(--duo-gray-lightest);
            color: var(--duo-text-dark);
        }
        .app-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            height: auto; /* Cambiará en móvil */
            padding: 0.75rem; /* Cambiará en móvil */
            box-sizing: border-box;
            position: relative;
            z-index: 1;
        }
        .app-header {
            margin-bottom: 0.75rem; 
            text-align: center;
            width: 100%;
            max-width: 1400px; 
        }
        .app-header h1 {
            font-size: 1.8rem;
            font-weight: 800;
            color: var(--duo-green);
            margin-bottom: 0.5rem;
        }

        .main-content-area {
            display: flex;
            width: 100%;
            max-width: 1400px; 
            flex-grow: 1;
            gap: 1rem; 
            overflow: visible; /* Cambiará en móvil */
        }

        .column-title {
            font-size: 1.4rem;
            font-weight: 800;
            color: var(--duo-text-dark);
            text-align: center;
            margin-bottom: 0.75rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--duo-gray-light);
        }

        .sidebar {
            background-color: var(--duo-text-light);
            padding: 1.1rem;
            border-radius: 1rem;
            border: 1px solid var(--duo-gray-light);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            gap: 1.25rem;
        }
        .sidebar-section .section-title {
            font-size: 1.0rem;
            font-weight: 700;
            margin-bottom: 0.6rem;
            text-align: center;
            color: var(--duo-text-dark);
        }
        .sidebar-section .button-group .btn {
            font-size: 0.8rem;
            padding: 0.6rem 1rem;
            width: auto;
        }
        .sidebar .stats-grid {
            grid-template-columns: repeat(auto-fit, minmax(75px, 1fr));
            gap: 0.4rem;
            margin-bottom: 0;
        }
        .sidebar .stat-item h3 { font-size: 0.65rem; }
        .sidebar .stat-item p { font-size: 1rem; }

        .content-wrapper-main {
            display: flex;
            flex-direction: column;
            flex-grow: 1;
            gap: 1rem; /* Este gap separará study-panel y tree-panel en desktop. En móvil, display:contents lo anula. */
            overflow: visible; /* Cambiará en móvil si es necesario */
        }

        .study-panel, .tree-panel {
            background-color: var(--duo-text-light);
            padding: 1.1rem;
            border-radius: 1rem;
            border: 1px solid var(--duo-gray-light);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            overflow-y: visible; /* Cambiará en móvil */
        }

        #flashcard-section { margin-bottom: 0.75rem; }
        .flashcard {
            background-color: var(--duo-text-light);
            border: 2px solid var(--duo-gray-light);
            padding: 1.1rem;
            border-radius: 0.75rem;
            margin-bottom: 0.75rem;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.03);
        }
        #question-text {
            font-size: 1.15rem;
            font-weight: 700;
            color: var(--duo-text-dark);
        }
        .input-field {
            padding: 0.6rem 0.9rem;
            border: 2px solid var(--duo-gray-light);
            border-radius: 0.75rem;
            width: 100%;
            max-width: 280px;
            margin: 0.375rem auto;
            box-sizing: border-box;
            font-size: 0.9rem;
            color: var(--duo-text-dark);
            transition: border-color 0.2s ease;
        }
        .input-field:focus {
            border-color: var(--duo-blue);
            outline: none;
            box-shadow: 0 0 0 3px rgba(28, 176, 246, 0.2);
        }
        .feedback {
            margin-top: 0.375rem;
            font-weight: 700;
            min-height: 20px;
            font-size: 0.85rem;
            margin-bottom: 0.6rem;
            padding: 0.4rem;
            border-radius: 0.5rem;
            text-align: center;
        }
        .feedback.correct {
            background-color: var(--duo-correct-bg);
            color: var(--duo-correct-text);
            border: 1px solid var(--duo-correct-text);
        }
        .feedback.incorrect {
            background-color: var(--duo-incorrect-bg);
            color: var(--duo-incorrect-text);
            border: 1px solid var(--duo-incorrect-text);
        }
         .feedback.info {
            background-color: #e0f2fe;
            color: #0c5460;
            border: 1px solid #bee5eb;
        }

        .btn {
            padding: 0.65rem 1.1rem;
            border-radius: 0.75rem;
            font-weight: 700;
            text-transform: uppercase;
            transition: background-color 0.2s ease, transform 0.15s ease, box-shadow 0.15s ease;
            cursor: pointer;
            border: none;
            border-bottom: 3px solid rgba(0,0,0,0.2);
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            min-width: 90px;
            font-size: 0.85rem;
            color: var(--duo-text-light);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        .btn:active {
            transform: translateY(0px);
            border-bottom-width: 1px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        .btn-primary { background-color: var(--duo-green); border-bottom-color: var(--duo-green-dark); }
        .btn-primary:hover { background-color: var(--duo-green-light); }
        .btn-secondary { background-color: var(--duo-blue); border-bottom-color: var(--duo-blue-dark); }
        .btn-secondary:hover { background-color: #4acaff; }
        .btn-tertiary { background-color: var(--duo-orange); border-bottom-color: var(--duo-orange-dark); }
        .btn-tertiary:hover { background-color: #ffae40; }
        .btn-danger { background-color: var(--duo-red); border-bottom-color: var(--duo-red-dark); }
        .btn-danger:hover { background-color: #ff6a6a; }
        .btn-learned { background-color: var(--duo-yellow); border-bottom-color: #e6b400; color: var(--duo-text-dark); }
        .btn-learned:hover { background-color: #ffd433; }
        .btn-disabled {
            background-color: var(--duo-gray-light);
            border-bottom-color: var(--duo-gray-medium);
            color: var(--duo-gray-dark);
            cursor: not-allowed;
            transform: none;
            box-shadow: 0 2px 3px rgba(0,0,0,0.05);
        }
        .btn-disabled:hover { background-color: var(--duo-gray-light); }

        .option-btn {
            background-color: var(--duo-text-light);
            color: var(--duo-text-dark);
            border: 2px solid var(--duo-gray-light);
            padding: 0.75rem;
            text-align: left;
            text-transform: none;
            font-size: 0.95rem;
            font-weight: 600;
            width: 100%;
            margin-bottom: 0.5rem;
        }
        .option-btn:hover:not(:disabled) {
            border-color: var(--duo-blue);
            background-color: #f0f8ff;
            transform: translateY(-1px);
        }
        .option-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
            background-color: var(--duo-gray-lightest);
        }
        .option-btn.selected-correct {
            background-color: var(--duo-correct-bg) !important;
            color: var(--duo-correct-text) !important;
            border-color: var(--duo-correct-text) !important;
            font-weight: 700;
        }
        .option-btn.selected-incorrect {
            background-color: var(--duo-incorrect-bg) !important;
            color: var(--duo-incorrect-text) !important;
            border-color: var(--duo-incorrect-text) !important;
            font-weight: 700;
        }
        .option-btn.actual-correct {
            background-color: var(--duo-correct-bg) !important;
            color: var(--duo-correct-text) !important;
            border: 2px dashed var(--duo-correct-text) !important;
        }

        .stats-grid {
            display: grid;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        .stat-item {
            background-color: var(--duo-gray-lightest);
            padding: 0.6rem;
            border-radius: 0.5rem;
            text-align: center;
            border: 1px solid var(--duo-gray-light);
        }
        .stat-item h3 {
            margin-top: 0;
            color: var(--duo-gray-dark);
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            margin-bottom: 0.1rem;
        }
        .stat-item p { font-size: 1.1rem; font-weight: 700; color: var(--duo-text-dark); }
        
        .tree-panel .stats-grid {
             grid-template-columns: repeat(auto-fit, minmax(90px, 1fr));
             margin-top: 1rem;
        }
        .tree-section-container { display: flex; flex-direction: column; flex-grow: 1; }
        .tree-display {
            margin: 0.5rem 0;
            min-height: 130px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: transform 0.3s ease-in-out;
            flex-grow: 1;
        }
        .tree-display:hover { transform: scale(1.05); }
        .tree-gif { max-width: 100%; max-height: 180px; object-fit: contain; }
        #tree-level-text {
            font-size: 0.9rem;
            margin-top: 0.25rem;
            font-weight: 600;
            color: var(--duo-gray-dark);
        }

        .section-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 0.6rem;
            text-align: center;
            color: var(--duo-text-dark);
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.4rem;
        }
        .button-group .btn {
            font-size: 0.75rem;
            padding: 0.5rem 0.9rem;
        }

        .modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: flex; justify-content: center; align-items: center; z-index: 1000;
            backdrop-filter: blur(3px);
        }
        .modal-content {
            background-color: white;
            padding: 1.5rem;
            border-radius: 1rem;
            width: 90%; max-width: 450px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            border-top: 5px solid var(--duo-green);
        }
        .modal-content h3 {
            font-size: 1.3rem; font-weight: 700; margin-bottom: 1rem; color: var(--duo-text-dark);
            text-align: center;
        }
        .modal-content label {
            font-size: 0.9rem; color: var(--duo-gray-dark); margin-bottom: 0.25rem; display: block; font-weight: 600;
        }
        .modal-content .input-field { font-size: 0.9rem; margin-bottom: 1rem; }
        .modal-content .feedback { font-size: 0.8rem; min-height: 20px; }
        .modal-content .btn-sm {
            font-size: 0.85rem;
            padding: 0.6rem 1rem;
            text-transform: uppercase;
        }
        .modal-content .btn.bg-slate-300 {
            background-color: var(--duo-gray-light);
            color: var(--duo-gray-dark);
            border-bottom-color: var(--duo-gray-medium);
        }
        .modal-content .btn.bg-slate-300:hover {
            background-color: #d1d1d1;
        }
        #shop-decks-container {
            max-height: 150px;
            overflow-y: auto;
        }
        #import-progress-input { display: none; }

       
        @media (max-width: 1024px) { /* Móvil y Tablet */
            
            html, body {
                height: 100%; 
                overflow: hidden; 
            }

            .app-header h1 {
                display: none; /* Esto ocultará el título */
            }
            
        .app-wrapper {
            height: 100dvh; /* O 100vh si dvh causa problemas inesperados */
            padding: 0.5rem; /* Padding general para los bordes del app-wrapper */
            /* Eliminamos el padding-bottom específico con env() aquí si main-content-area lo maneja */
            box-sizing: border-box;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

            .main-content-area {
            flex-direction: column;
            flex-grow: 1;
            overflow-y: auto;
            scroll-snap-type: y mandatory;
            gap: 0;
            scrollbar-width: none;  /* Firefox */
            -ms-overflow-style: none;  /* IE 10+ */
            padding-bottom: env(safe-area-inset-bottom, 0px); /* Ajusta el 0px si necesitas un padding mínimo adicional */
            box-sizing: border-box; /* Importante para que el padding no aumente el tamaño del scroll */
        }
        .main-content-area::-webkit-scrollbar { /* WebKit */
            display: none;
        }

            .content-wrapper-main {
                /* width: 100%; ya lo tiene */
                /* flex-direction: column; ya lo tiene (pero display:contents lo hace irrelevante para sus hijos directos) */
                order: 1; /* Ya lo tiene */
                display: contents; 
            }

                        .study-panel, .tree-panel, .sidebar {
                scroll-snap-align: start;
                height: 100%;
                min-height: 100%;
                margin-bottom: 0 !important;
                overflow-y: auto;
                flex-shrink: 0;
                /* Para Firefox */
                scrollbar-width: none;
                /* Para IE (opcional, más antiguo) */
                -ms-overflow-style: none;
            }
            /* Para Webkit (Chrome, Safari, Edge) - FUERA de la regla combinada */
            .study-panel::-webkit-scrollbar,
            .tree-panel::-webkit-scrollbar,
            .sidebar::-webkit-scrollbar {
                display: none;
            }

            .sidebar {
                order: 2; /* Ya lo tiene */
                /* width: 100%; margin-bottom: 1rem; (originales) -> Sobrescritos por la regla de panel */
            }


            .scroll-arrow {
                display: none !important; 
            }
            /* END: TikTok Scroll Snap Changes */

            /* Estilos originales de la media query que no entran en conflicto o ya están cubiertos: */
            .app-header h1 { font-size: 1.5rem; }

            /* .study-panel, .tree-panel (originales width y margin-bottom) -> Sobrescritos por la regla de panel */
            
            /* .content-wrapper-main > section:last-child { margin-bottom: 0; } /* Ya no es necesario */
        }

        @media (min-width: 1025px) { /* Escritorio */
            html, body {
                overflow-x: hidden; /* Mantener para evitar scroll horizontal accidental */
                height: auto; /* Volver a auto para que el contenido determine la altura */
                overflow-y: auto; /* Permitir scroll normal en desktop */
            }
             .app-wrapper { /* Restaurar comportamiento de escritorio */
                min-height: 100vh;
                height: auto;
                padding: 0.75rem;
                overflow: visible; /* Permitir que el contenido se desborde si es necesario */
            }
            .main-content-area {
                flex-direction: row; 
                align-items: flex-start;
                gap: 1.5rem;
                overflow: visible; /* Restaurar */
                scroll-snap-type: none; /* Desactivar snap en escritorio */
            }
            .sidebar {
                width: 380px;
                flex-shrink: 0;
                margin-bottom: 0; /* Ya lo tenía */
                position: sticky; 
                top: 1rem; 
                align-self: flex-start;
                max-height: calc(100vh - 2rem); 
                overflow-y: auto; 
                height: auto; /* Restaurar altura automática */
                min-height: auto; /* Restaurar */
                scroll-snap-align: unset; /* Quitar snap */
            }
            .content-wrapper-main {
                flex-grow: 1;
                flex-direction: row; 
                gap: 1.5rem;
                display: flex; /* Restaurar a flex si display:contents lo afectó */
            }
            .study-panel {
                flex-basis: 45%; 
                flex-grow: 1;
                margin-bottom: 0; /* Ya lo tenía */
                height: auto; /* Restaurar altura automática */
                min-height: auto; /* Restaurar */
                overflow-y: visible; /* Restaurar, el scroll interno es manejado por sidebar si es sticky */
                scroll-snap-align: unset; /* Quitar snap */
                flex-shrink: 1; /* Restaurar comportamiento flex normal */
            }
            .tree-panel {
                flex-basis: 55%; 
                flex-grow: 1;
                margin-bottom: 0; /* Ya lo tenía */
                height: auto; /* Restaurar altura automática */
                min-height: auto; /* Restaurar */
                overflow-y: visible; /* Restaurar */
                scroll-snap-align: unset; /* Quitar snap */
                flex-shrink: 1; /* Restaurar comportamiento flex normal */
            }
            .scroll-arrow { display: none !important; } 
        }

        /* Styles for scroll arrows (solo relevantes para móvil si .main-content-area tiene scroll) */
        /* Se mantienen por si se revierte, pero ahora ocultas en móvil y desktop */
        .scroll-arrow {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            background-color: rgba(0, 0, 0, 0.5);
            color: white;
            border: none;
            padding: 0.5rem;
            cursor: pointer;
            z-index: 100;
            font-size: 1.5rem;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            justify-content: center;
            align-items: center;
            opacity: 0.8;
            transition: opacity 0.2s ease;
        }
        .scroll-arrow:hover {
            opacity: 1;
        }
        .scroll-arrow.left { left: 0.5rem; }
        .scroll-arrow.right { right: 0.5rem; }
    </style>
</head>
<body>
    <main class="app-wrapper">
        <header class="app-header">
            <h1>Aprende Inglés Fácil con Flashcards Interactivas</h1>
        </header>

        <div class="main-content-area">
            <aside class="sidebar">
                <h2 class="column-title">Panel de Control</h2>

                <section class="sidebar-section" aria-label="Recursos y Tienda">
                    <h3 class="section-title text-[var(--duo-green)]">Recursos y Tienda</h3>
                    <div class="stats-grid sidebar-stats">
                        <div class="stat-item">
                            <h3>Puntos</h3>
                            <p id="score">0</p>
                        </div>
                        <div class="stat-item">
                            <h3>Fertilizante</h3>
                            <p id="fertilizer-count">0</p>
                        </div>
                        <div class="stat-item">
                            <h3>Manzanas</h3>
                            <p id="apples-count">0 🍎</p>
                        </div>
                    </div>
                    <div class="button-group mt-2">
                        <button id="open-shop-btn" class="btn btn-tertiary w-full">Tienda</button>
                    </div>
                </section>


                <section class="sidebar-section" aria-label="Gestión de progreso general">
                    <h3 class="section-title text-[var(--duo-blue)]">Progreso General</h3>
                    <div class="button-group">
                         <button id="export-progress-btn" class="btn btn-tertiary">Exportar</button>
                         <button id="import-progress-btn" class="btn btn-tertiary">Importar</button>
                         <button id="download-words-btn" class="btn btn-tertiary">Descargar Palabras</button>
                         <input type="file" id="import-progress-input" accept=".json, .enc">
                    </div>
                    <div id="import-export-feedback" class="feedback text-center mt-1.5"></div>
                </section>
            </aside>

            <div class="content-wrapper-main">
                <section class="study-panel">
                    <h2 class="column-title">Panel de Estudio</h2>
                    <section id="flashcard-section" aria-labelledby="flashcard-title">
                        <div class="flashcard">
                            <p id="question-text"></p>
                        </div>
                        <input type="text" id="answer-input" class="input-field mx-auto block hidden" placeholder="Escribe la traducción...">
                        <div id="multiple-choice-options" class="mt-3 space-y-2 w-full max-w-sm mx-auto"></div>
                        <div id="feedback-text" class="feedback text-center"></div>
                        <div class="flex justify-center space-x-2 mt-1.5 button-group">
                            <button id="check-answer-btn" class="btn btn-primary hidden">Revisar</button>
                            <button id="learned-btn" class="btn btn-learned hidden">¡Lo sé!</button>
                            <button id="next-card-btn" class="btn btn-secondary hidden">Siguiente</button>
                        </div>
                    </section>
                                    <section class="sidebar-section" aria-label="Gestión de palabras">
                    <h3 class="section-title text-[var(--duo-blue)]">Gestionar Palabras</h3>
                    <div class="button-group">
                         <button id="show-add-card-modal-btn" class="btn btn-primary ">Añadir</button>
                         <button id="show-delete-card-modal-btn" class="btn btn-danger">Eliminar</button>
                         <button id="show-review-learned-modal-btn" class="btn btn-secondary">Ver Aprendidas</button>
                    </div>
                </section>
                </section>

                <section class="tree-panel">
                     <h2 class="column-title">Tu Árbol de Palabras</h2>
                     <section id="tree-section" class="text-center flex flex-col flex-grow tree-section-container" aria-label="Progreso del Árbol de Palabras">
                        <div id="tree-display" class="tree-display"></div>
                        <p id="tree-level-text">Nivel: Semilla</p>
                        <div class="mt-2 button-group">
                            <button id="use-fertilizer-btn" class="btn btn-secondary w-full sm:w-auto">Usar Fertilizante</button>
                        </div>
                        <div class="stats-grid tree-panel-stats mt-3" aria-label="Estadísticas de producción del árbol">
                            <div class="stat-item">
                                <h3>Producción</h3>
                                <p id="apples-per-day" class="text-xs sm:text-sm">0 / día</p>
                            </div>
                            <div class="stat-item">
                                <h3>Próximas 🍎</h3>
                                <p id="apple-countdown" class="text-xs sm:text-sm">--:--:--</p>
                            </div>
                        </div>
                    </section>
                </section>
            </div>
        </div>

        <button id="scroll-left-btn" class="scroll-arrow left hidden" aria-label="Desplazar a la izquierda">«</button>
        <button id="scroll-right-btn" class="scroll-arrow right hidden" aria-label="Desplazar a la derecha">»</button>
    </main>

    <!-- Modales (sin cambios en su HTML interno) -->
    <div id="add-card-modal" class="modal hidden" role="dialog" aria-labelledby="addCardModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="addCardModalTitle">Nueva Palabra</h3>
            <label for="new-question">Palabra en Inglés:</label>
            <input type="text" id="new-question" class="input-field w-full" placeholder="Ej: Hello">
            <label for="new-answer">Traducción al Español:</label>
            <input type="text" id="new-answer" class="input-field w-full" placeholder="Ej: Hola">
            <div id="add-card-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="save-card-btn" class="btn btn-primary btn-sm">Guardar</button>
                <button id="cancel-add-card-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="delete-card-modal" class="modal hidden" role="dialog" aria-labelledby="deleteCardModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="deleteCardModalTitle">Eliminar Palabra</h3>
            <div class="flex justify-end mb-1">
                 <button id="select-all-delete-btn" class="btn btn-secondary btn-sm !py-1 !px-2 !text-xs hidden">Seleccionar Todas</button>
            </div>
            <div id="delete-card-list-container" class="my-2 max-h-48 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md">
                <p id="no-cards-to-delete-msg" class="text-[var(--duo-gray-dark)] text-sm hidden">No hay palabras para eliminar.</p>
            </div>
            <div id="delete-feedback" class="feedback text-center"></div>
            <div class="flex justify-end space-x-2 mt-3">
                <button id="confirm-delete-card-btn" class="btn btn-danger btn-sm">Eliminar</button>
                <button id="cancel-delete-card-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cancelar</button>
            </div>
        </div>
    </div>

    <div id="review-learned-modal" class="modal hidden" role="dialog" aria-labelledby="reviewLearnedModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="reviewLearnedModalTitle">Palabras Aprendidas</h3>
            <div id="review-learned-list-container" class="my-2 max-h-52 overflow-y-auto p-2 border border-[var(--duo-gray-light)] rounded-md">
                 <p id="no-learned-cards-msg" class="text-[var(--duo-gray-dark)] text-sm hidden">Aún no has marcado ninguna palabra como aprendida.</p>
            </div>
            <div id="review-modal-feedback" class="feedback text-center"></div>
            <div class="flex justify-end mt-3">
                <button id="close-review-learned-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar</button>
            </div>
        </div>
    </div>

    <div id="shop-modal" class="modal hidden" role="dialog" aria-labelledby="shopModalTitle" aria-modal="true">
        <div class="modal-content">
            <h3 id="shopModalTitle">Tienda del Árbol</h3>
            <div id="shop-feedback" class="feedback text-center"></div>
            <div class="space-y-2 my-3">
                <div class="p-2.5 border border-[var(--duo-gray-light)] rounded-lg bg-[var(--duo-gray-lightest)]">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="font-semibold text-sm text-[var(--duo-text-dark)]">Fertilizante</h4>
                            <p class="text-xs text-[var(--duo-gray-dark)]">Costo: <span id="fertilizer-shop-cost-display">10</span> Puntos ✨</p>
                        </div>
                        <button id="buy-fertilizer-shop-btn" class="btn btn-primary btn-sm">Comprar</button>
                    </div>
                </div>
                 <div class="p-2.5 border border-[var(--duo-gray-light)] rounded-lg bg-[var(--duo-gray-lightest)]">
                    <div class="flex justify-between items-center">
                        <div>
                            <h4 class="font-semibold text-sm text-[var(--duo-text-dark)]">1 Manzana 🍎</h4>
                            <p class="text-xs text-[var(--duo-gray-dark)]">Costo: <span id="apple-shop-cost-display">1000</span> Puntos</p>
                        </div>
                        <button id="buy-apple-shop-btn" class="btn btn-primary btn-sm">Comprar</button>
                    </div>
                </div>
                <h4 class="text-md font-semibold text-[var(--duo-text-dark)] pt-3 mt-3 border-t border-[var(--duo-gray-light)]">Mazos de Palabras</h4>
                <div id="shop-decks-container" class="space-y-2">
                    <p id="loading-decks-msg" class="text-sm text-center text-[var(--duo-gray-dark)]">Cargando mazos disponibles...</p>
                </div>
            </div>
            <div class="flex justify-end mt-3">
                <button id="close-shop-btn" class="btn bg-slate-300 hover:bg-slate-400 text-slate-800 btn-sm">Cerrar Tienda</button>
            </div>
        </div>
    </div>

    <audio id="correct-sound" src="sounds/correct-sound.mp3" preload="auto"></audio>
    <audio id="incorrect-sound" src="sounds/incorrect-sound.mp3" preload="auto"></audio>

    <script>
        // --- Variables del Juego ---
        let flashcards = [];
        let learnedFlashcards = [];
        let currentCardIndex = 0;
        let score = 0;
        let fertilizerCount = 0;
        let treeLevel = 0;
        let applesCount = 0;
        let applesPerDay = 0;
        let lastAppleGenerationTime = Date.now();
        let appleCountdownInterval = null;
        let shopDecksData = {};
        let pointsThisHour = 0;
        let lastPointResetTime = Date.now();


        // --- Constantes del Juego ---
        const POINTS_PER_CORRECT_ANSWER = 10;
        const POINTS_FOR_LEARNED_WORD = 20;
        const DEFAULT_FLASHCARDS = [
            { question: "Hello", answer: "Hola" }, { question: "Goodbye", answer: "Adiós" },
            { question: "Thank you", answer: "Gracias" }, { question: "Please", answer: "Por favor" },
            { question: "Yes", answer: "Sí" }, { question: "No", answer: "No" },
            { question: "Friend", answer: "Amigo" }, { question: "Love", answer: "Amor" }
        ];
        const CHECK_APPLES_INTERVAL = 60 * 1000;
        const FERTILIZER_SHOP_COST = 50;
        const APPLE_SHOP_COST = 500;
        const TREE_LEVEL_DATA = [
            { name: 'Semilla',         gifName: 'gif_1.gif', fertilizerToNext: 5,   applesPerDay: 0 },
            { name: 'Brote',           gifName: 'gif_2.gif', fertilizerToNext: 10,  applesPerDay: 0 },
            { name: 'Árbol Pequeño',   gifName: 'gif_3.gif', fertilizerToNext: 20,  applesPerDay: 1 },
            { name: 'Árbol Mediano',   gifName: 'gif_4.gif', fertilizerToNext: 40,  applesPerDay: 2 },
            { name: 'Árbol Mìstico',    gifName: 'gif_5.gif', fertilizerToNext: 80,  applesPerDay: 4 },
            { name: 'Árbol Divino',   gifName: 'gif_6.gif', fertilizerToNext: 160, applesPerDay: 8 }
        ];
        const MAX_TREE_LEVEL_INDEX = TREE_LEVEL_DATA.length - 1;

       const SHOP_DECK_DEFINITIONS = [
            { id: "basic_verbs_pack", fileName: "decks/deck_basic_verbs.json" },
            { id: "birds_pack", fileName: "decks/birds.json" },
            { id: "body_parts_pack", fileName: "decks/body.json" },
            { id: "basic_verbs_past_pack", fileName: "decks/deck_basic_verbs_past.json" },
            { id: "fruits_vegetables_pack", fileName: "decks/fruit.json" },
            { id: "land_animals_pack", fileName: "decks/land_animals.json" },
            { id: "marine_animals_pack", fileName: "decks/marine_animals.json" }
        ];

        const ENCRYPTION_KEY_STRING = "miClaveSuperSecreta1234567890!";
        let cryptoKey;
        const MIN_CARDS_FOR_POINTS = 5;
        const MAX_POINTS_PER_HOUR = 500;
        const ONE_HOUR_IN_MS = 60 * 60 * 1000;

        // --- Elementos del DOM ---
        const questionTextEl = document.getElementById('question-text');
        const answerInputEl = document.getElementById('answer-input');
        const multipleChoiceOptionsEl = document.getElementById('multiple-choice-options');
        const checkAnswerBtn = document.getElementById('check-answer-btn');
        const learnedBtn = document.getElementById('learned-btn');
        const nextCardBtn = document.getElementById('next-card-btn');
        const feedbackTextEl = document.getElementById('feedback-text');
        const scoreEl = document.getElementById('score'); 
        const fertilizerCountEl = document.getElementById('fertilizer-count'); 
        const applesCountEl = document.getElementById('apples-count'); 
        const treeDisplayEl = document.getElementById('tree-display');
        const treeLevelTextEl = document.getElementById('tree-level-text');
        const useFertilizerBtn = document.getElementById('use-fertilizer-btn');
        const applesPerDayEl = document.getElementById('apples-per-day'); 
        const appleCountdownEl = document.getElementById('apple-countdown'); 
        const showAddCardModalBtn = document.getElementById('show-add-card-modal-btn'); 
        const addCardModal = document.getElementById('add-card-modal');
        const newQuestionInput = document.getElementById('new-question');
        const newAnswerInput = document.getElementById('new-answer');
        const saveCardBtn = document.getElementById('save-card-btn');
        const cancelAddCardBtn = document.getElementById('cancel-add-card-btn');
        const addCardFeedbackEl = document.getElementById('add-card-feedback');
        const showDeleteCardModalBtn = document.getElementById('show-delete-card-modal-btn'); 
        const deleteCardModal = document.getElementById('delete-card-modal');
        const deleteCardListContainerEl = document.getElementById('delete-card-list-container');
        const noCardsToDeleteMsgEl = document.getElementById('no-cards-to-delete-msg');
        const confirmDeleteCardBtn = document.getElementById('confirm-delete-card-btn');
        const cancelDeleteCardBtn = document.getElementById('cancel-delete-card-btn');
        const deleteFeedbackEl = document.getElementById('delete-feedback');
        const selectAllDeleteBtn = document.getElementById('select-all-delete-btn');
        const reviewLearnedModal = document.getElementById('review-learned-modal');
        const reviewLearnedListContainerEl = document.getElementById('review-learned-list-container');
        const noLearnedCardsMsgEl = document.getElementById('no-learned-cards-msg');
        const closeReviewLearnedBtn = document.getElementById('close-review-learned-btn');
        const reviewModalFeedbackEl = document.getElementById('review-modal-feedback');
        const openShopBtn = document.getElementById('open-shop-btn'); 
        const shopModal = document.getElementById('shop-modal');
        const closeShopBtn = document.getElementById('close-shop-btn');
        const buyFertilizerShopBtn = document.getElementById('buy-fertilizer-shop-btn');
        const buyAppleShopBtn = document.getElementById('buy-apple-shop-btn');
        const shopFeedbackEl = document.getElementById('shop-feedback');
        const fertilizerShopCostDisplayEl = document.getElementById('fertilizer-shop-cost-display');
        const appleShopCostDisplayEl = document.getElementById('apple-shop-cost-display');
        const shopDecksContainerEl = document.getElementById('shop-decks-container');
        const loadingDecksMsgEl = document.getElementById('loading-decks-msg');
        const exportProgressBtn = document.getElementById('export-progress-btn'); 
        const importProgressBtn = document.getElementById('import-progress-btn'); 
        const importProgressInput = document.getElementById('import-progress-input'); 
        const importExportFeedbackEl = document.getElementById('import-export-feedback'); 
        const showReviewLearnedModalBtn = document.getElementById('show-review-learned-modal-btn'); 
        const downloadWordsBtn = document.getElementById('download-words-btn'); 
        const scrollLeftBtn = document.getElementById('scroll-left-btn');
        const scrollRightBtn = document.getElementById('scroll-right-btn');
        const mainContentAreaEl = document.querySelector('.main-content-area');
        const correctSound = document.getElementById('correct-sound');
        const incorrectSound = document.getElementById('incorrect-sound');

        // --- Funciones Crypto ---
        async function initCryptoKey() {
            try {
                const keyMaterial = await window.crypto.subtle.importKey(
                    "raw", new TextEncoder().encode(ENCRYPTION_KEY_STRING.slice(0, 32)),
                    { name: "PBKDF2" }, false, ["deriveKey"]
                );
                const salt = new TextEncoder().encode("someFixedSaltValue");
                cryptoKey = await window.crypto.subtle.deriveKey(
                    { name: "PBKDF2", salt: salt, iterations: 100000, hash: "SHA-256" },
                    keyMaterial, { name: "AES-GCM", length: 256 }, true, ["encrypt", "decrypt"]
                );
            } catch (error) {
                console.error("Error al inicializar CryptoKey:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error de criptografía al iniciar.", "incorrect", 5000);
                [exportProgressBtn, importProgressBtn].forEach(btn => {
                    btn.disabled = true; btn.classList.add('btn-disabled');
                });
            }
        }

        async function encryptData(plaintext) {
            if (!cryptoKey) {
                showTemporaryFeedback(importExportFeedbackEl, "Error: Clave de encriptación no lista.", "incorrect", 3000); return null;
            }
            try {
                const iv = window.crypto.getRandomValues(new Uint8Array(12));
                const encodedText = new TextEncoder().encode(plaintext);
                const ciphertext = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv: iv }, cryptoKey, encodedText);
                const ivBase64 = btoa(String.fromCharCode.apply(null, iv));
                const ciphertextBase64 = btoa(String.fromCharCode.apply(null, new Uint8Array(ciphertext)));
                return { iv: ivBase64, ciphertext: ciphertextBase64 };
            } catch (error) {
                console.error("Error encriptando:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error al encriptar datos.", "incorrect", 3000); return null;
            }
        }

        async function decryptData(ciphertextBase64, ivBase64) {
            if (!cryptoKey) {
                showTemporaryFeedback(importExportFeedbackEl, "Error: Clave de decriptación no lista.", "incorrect", 3000); return null;
            }
            try {
                const iv = Uint8Array.from(atob(ivBase64), c => c.charCodeAt(0));
                const ciphertext = Uint8Array.from(atob(ciphertextBase64), c => c.charCodeAt(0)).buffer;
                const decryptedBuffer = await window.crypto.subtle.decrypt({ name: "AES-GCM", iv: iv }, cryptoKey, ciphertext);
                return new TextDecoder().decode(decryptedBuffer);
            } catch (error) {
                console.error("Error desencriptando:", error);
                showTemporaryFeedback(importExportFeedbackEl, "Error al desencriptar. ¿Archivo o clave incorrectos?", "incorrect", 4000); return null;
            }
        }

        // --- Funciones de Import/Export ---
        async function exportProgress() {
            clearFeedback(importExportFeedbackEl);
            const gameData = {
                flashcards, learnedFlashcards, currentCardIndex, score,
                fertilizerCount, treeLevel, applesCount, applesPerDay,
                lastAppleGenerationTime,
                pointsThisHour, lastPointResetTime
            };
            const jsonData = JSON.stringify(gameData);
            const encryptedPayload = await encryptData(jsonData);
            if (!encryptedPayload) {
                showTemporaryFeedback(importExportFeedbackEl, "Fallo la encriptación. No se pudo exportar.", "incorrect", 3000);
                return;
            }
            const dataToExport = JSON.stringify(encryptedPayload);
            const blob = new Blob([dataToExport], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "flashcards_progress_encrypted.json";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showTemporaryFeedback(importExportFeedbackEl, "Progreso exportado y encriptado.", "correct", 3000);
        }

        function triggerImport() {
            clearFeedback(importExportFeedbackEl);
            importProgressInput.click();
        }

        async function handleImportFile(event) {
            const file = event.target.files[0];
            if (!file) {
                showTemporaryFeedback(importExportFeedbackEl, "No se seleccionó archivo.", "info", 3000);
                return;
            }
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const fileContent = e.target.result;
                    const encryptedPayload = JSON.parse(fileContent);
                    if (!encryptedPayload.iv || !encryptedPayload.ciphertext) {
                        throw new Error("Formato de archivo encriptado inválido.");
                    }
                    const decryptedJson = await decryptData(encryptedPayload.ciphertext, encryptedPayload.iv);
                    if (!decryptedJson) { return; }
                    const importedData = JSON.parse(decryptedJson);
                    if (typeof importedData.score !== 'number' || !Array.isArray(importedData.flashcards)) {
                        throw new Error("Datos importados inválidos o corruptos.");
                    }
                    flashcards = importedData.flashcards || DEFAULT_FLASHCARDS.slice();
                    learnedFlashcards = importedData.learnedFlashcards || [];
                    currentCardIndex = importedData.currentCardIndex || 0;
                    score = importedData.score || 0;
                    fertilizerCount = importedData.fertilizerCount || 0;
                    treeLevel = importedData.treeLevel || 0;
                    applesCount = importedData.applesCount || 0;
                    lastAppleGenerationTime = importedData.lastAppleGenerationTime || Date.now();
                    pointsThisHour = importedData.pointsThisHour || 0;
                    lastPointResetTime = importedData.lastPointResetTime || Date.now();

                    saveGameData();
                    initGameVisuals();
                    showTemporaryFeedback(importExportFeedbackEl, "Progreso importado exitosamente.", "correct", 4000);
                } catch (error) {
                    console.error("Error importando progreso:", error);
                    showTemporaryFeedback(importExportFeedbackEl, `Error al importar: ${error.message}`, "incorrect", 5000);
                } finally {
                    importProgressInput.value = "";
                }
            };
            reader.onerror = () => {
                showTemporaryFeedback(importExportFeedbackEl, "Error al leer el archivo.", "incorrect", 3000);
            };
            reader.readAsText(file);
        }

        function formatWordsArrayToTxt(wordsArray) {
            if (!wordsArray || wordsArray.length === 0) {
                return "Ninguna por el momento.";
            }
            let textParts = [];
            for (let i = 0; i < wordsArray.length; i++) {
                const card = wordsArray[i];
                let currentPart = `${card.question}: ${card.answer}`;
                if (wordsArray.length === 1) {
                    currentPart += ".";
                } else {
                    if (i === 0) {
                        currentPart += ".";
                    } else if (i < wordsArray.length - 1) {
                        currentPart += ",";
                    }
                }
                textParts.push(currentPart);
            }
            return textParts.join(' ');
        }

        function downloadFlashcardsJson() {
            clearFeedback(importExportFeedbackEl);
            if (flashcards.length === 0 && learnedFlashcards.length === 0) {
                showTemporaryFeedback(importExportFeedbackEl, "No hay palabras para descargar.", "info", 3000);
                return;
            }
            let textContent = "=== Palabras por Aprender ===\r\n";
            textContent += formatWordsArrayToTxt(flashcards) + "\r\n\r\n";
            textContent += "=== Palabras Aprendidas ===\r\n";
            textContent += formatWordsArrayToTxt(learnedFlashcards);
            const blob = new Blob([textContent], { type: "text/plain;charset=utf-8" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "flashcards_palabras.txt";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showTemporaryFeedback(importExportFeedbackEl, "Archivo de palabras (TXT) descargado.", "correct", 3000);
        }


        // --- Lógica del Juego ---
        function generateAndDisplayOptions() {
            multipleChoiceOptionsEl.innerHTML = '';
            const correctAnswer = flashcards[currentCardIndex].answer;
            let options = [correctAnswer];
            let distractorPool = flashcards
                .filter((card, index) => index !== currentCardIndex)
                .map(card => card.answer)
                .filter(answer => answer.toLowerCase() !== correctAnswer.toLowerCase());
            distractorPool = [...new Set(distractorPool)];
            shuffleArray(distractorPool);
            for (let i = 0; i < Math.min(2, distractorPool.length); i++) {
                options.push(distractorPool[i]);
            }
            if (options.length < 3 && flashcards.length >= 3) {
                let allAnswers = [...new Set(flashcards.map(card => card.answer))];
                shuffleArray(allAnswers);
                for (const ans of allAnswers) {
                    if (options.length < 3 && !options.includes(ans)) {
                        options.push(ans);
                    }
                }
            }
            shuffleArray(options);
            options.forEach(optionText => {
                const button = document.createElement('button');
                button.classList.add('btn', 'option-btn');
                button.textContent = optionText;
                button.dataset.answer = optionText;
                button.addEventListener('click', handleOptionClick);
                multipleChoiceOptionsEl.appendChild(button);
            });
        }

        function handleOptionClick(event) {
            const clickedButton = event.target;
            const selectedAnswer = clickedButton.dataset.answer;
            const correctAnswer = flashcards[currentCardIndex].answer;
            const optionButtons = multipleChoiceOptionsEl.querySelectorAll('.option-btn');
            optionButtons.forEach(btn => btn.disabled = true);
            nextCardBtn.classList.remove('hidden');
            if (selectedAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
                clickedButton.classList.add('selected-correct');
                checkHourlyPointLimit();
                if (flashcards.length < MIN_CARDS_FOR_POINTS) {
                    showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 Pero necesitas al menos ${MIN_CARDS_FOR_POINTS} palabras para ganar puntos. Añade más. (Tienes ${flashcards.length})`, "info", 4000);
                } else if (pointsThisHour >= MAX_POINTS_PER_HOUR) {
                    showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 Has alcanzado el límite de ${MAX_POINTS_PER_HOUR} puntos esta hora. Intenta más tarde.`, "info", 4000);
                } else {
                    const pointsToAdd = POINTS_PER_CORRECT_ANSWER;
                    let actualPointsAdded = pointsToAdd;
                    if (pointsThisHour + pointsToAdd > MAX_POINTS_PER_HOUR) {
                        actualPointsAdded = MAX_POINTS_PER_HOUR - pointsThisHour;
                        showTemporaryFeedback(feedbackTextEl, `¡Correcto! 🎉 +${actualPointsAdded} puntos. (Límite horario alcanzado)`, "correct", 3000);
                    } else {
                        showTemporaryFeedback(feedbackTextEl, "¡Correcto! 🎉", "correct", 2000);
                    }
                    score += actualPointsAdded;
                    pointsThisHour += actualPointsAdded;
                    updateScore();
                }
                learnedBtn.classList.remove('hidden');
                if (correctSound) {
                    correctSound.currentTime = 0;
                    correctSound.play().catch(error => console.error("Error al reproducir sonido correcto:", error));
                }
            } else {
                clickedButton.classList.add('selected-incorrect');
                optionButtons.forEach(btn => {
                    if (btn.dataset.answer.toLowerCase() === correctAnswer.toLowerCase()) {
                        btn.classList.add('actual-correct');
                    }
                });
                const pointsToDeduct = 20;
                score -= pointsToDeduct;
                if (score < 0) { score = 0; }
                updateScore();
                showTemporaryFeedback(feedbackTextEl, `Incorrecto. Respuesta correcta: ${correctAnswer}. Has perdido ${pointsToDeduct} puntos. 📉`, "incorrect", 3500);
                learnedBtn.classList.add('hidden');
                if (incorrectSound) {
                    incorrectSound.currentTime = 0;
                    incorrectSound.play().catch(error => console.error("Error al reproducir sonido incorrecto:", error));
                }
            }
            nextCardBtn.focus();
            saveGameData();
        }

        function displayCard() {
            if (flashcards.length === 0) {
                handleNoCardsState();
                return;
            }
            if (currentCardIndex >= flashcards.length || currentCardIndex < 0) {
                currentCardIndex = 0;
            }
            questionTextEl.textContent = flashcards[currentCardIndex].question;
            answerInputEl.value = "";
            answerInputEl.classList.add('hidden');
            checkAnswerBtn.classList.add('hidden');
            generateAndDisplayOptions();
            clearFeedback(feedbackTextEl);
            if (flashcards.length < MIN_CARDS_FOR_POINTS) {
                 showTemporaryFeedback(feedbackTextEl, `Necesitas al menos ${MIN_CARDS_FOR_POINTS} palabras en el mazo para ganar puntos. Actualmente tienes ${flashcards.length}.`, "info", 0);
            } else if (flashcards.length > 0 && flashcards.length < 3) {
                showTemporaryFeedback(feedbackTextEl, `Añade más palabras para tener 3 opciones de respuesta (tienes ${flashcards.length}).`, "info", 0);
            }
            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.add('hidden');
        }

        function handleNoCardsState() {
            questionTextEl.textContent = "¡No hay palabras! Añade algunas o compra un mazo para empezar.";
            answerInputEl.value = "";
            answerInputEl.disabled = true;
            answerInputEl.classList.add('hidden');
            multipleChoiceOptionsEl.innerHTML = '';
            checkAnswerBtn.classList.add('hidden');
            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.add('hidden');
            showTemporaryFeedback(feedbackTextEl, `Usa 'Añadir Palabra' o visita la Tienda. Necesitas ${MIN_CARDS_FOR_POINTS} palabras para ganar puntos.`, "info", 0);
        }

        function checkHourlyPointLimit() {
            const now = Date.now();
            if (now - lastPointResetTime >= ONE_HOUR_IN_MS) {
                pointsThisHour = 0;
                lastPointResetTime = now;
                saveGameData();
            }
        }


        function markAsLearned() {
            if (flashcards.length === 0) return;
            const cardToLearn = flashcards[currentCardIndex];
            let feedbackMessage = "";

            if (learnedFlashcards.findIndex(card => card.question.toLowerCase() === cardToLearn.question.toLowerCase()) === -1) {
                learnedFlashcards.push(cardToLearn);
                checkHourlyPointLimit();
                if (flashcards.length < MIN_CARDS_FOR_POINTS) {
                    feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. Necesitas ${MIN_CARDS_FOR_POINTS} palabras en el mazo principal para ganar puntos por aprender.`;
                } else if (pointsThisHour >= MAX_POINTS_PER_HOUR) {
                    feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. Límite de ${MAX_POINTS_PER_HOUR} puntos/hora alcanzado.`;
                } else {
                    const pointsToAdd = POINTS_FOR_LEARNED_WORD;
                    let actualPointsAdded = pointsToAdd;
                    if (pointsThisHour + pointsToAdd > MAX_POINTS_PER_HOUR) {
                        actualPointsAdded = MAX_POINTS_PER_HOUR - pointsThisHour;
                        feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. +${actualPointsAdded} pts! (Límite horario alcanzado)`;
                    } else {
                         feedbackMessage = `"${cardToLearn.question}" marcada como aprendida. +${actualPointsAdded} pts!`;
                    }
                    score += actualPointsAdded;
                    pointsThisHour += actualPointsAdded;
                    updateScore();
                }
                showTemporaryFeedback(feedbackTextEl, feedbackMessage, "info", 3500);
            } else {
                showTemporaryFeedback(feedbackTextEl, `"${cardToLearn.question}" ya estaba marcada como aprendida.`, "info", 2500);
            }

            const previousFlashcardCount = flashcards.length;
            flashcards.splice(currentCardIndex, 1);
            saveGameData();
            learnedBtn.classList.add('hidden');
            nextCardBtn.classList.remove('hidden');
            nextCardBtn.focus();

            if (flashcards.length === 0) {
                handleNoCardsState();
            } else {
                if (flashcards.length < MIN_CARDS_FOR_POINTS && previousFlashcardCount >= MIN_CARDS_FOR_POINTS) {
                }
                if (currentCardIndex >= flashcards.length) {
                    currentCardIndex = 0;
                    shuffleFlashcards();
                }
                moveToNextCard(false);
            }
        }

        function moveToNextCard(shuffleDeckIfNeeded = true) {
            if (flashcards.length === 0) {
                handleNoCardsState();
                return;
            }
            currentCardIndex++;
            if (currentCardIndex >= flashcards.length) {
                currentCardIndex = 0;
                if (shuffleDeckIfNeeded && flashcards.length > 1) {
                    shuffleFlashcards();
                    if (!feedbackTextEl.textContent || feedbackTextEl.textContent.includes("¡Correcto!") || feedbackTextEl.textContent.includes("Respuesta correcta:")) {
                         showTemporaryFeedback(feedbackTextEl, "¡Mazo barajado para la siguiente ronda!", "info", 1500);
                    }
                }
            }
            displayCard();
            saveGameData();
        }

        function shuffleFlashcards() {
            for (let i = flashcards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
            }
        }
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function updateScore() { scoreEl.textContent = score; }
        function updateFertilizerCount() {
            fertilizerCountEl.textContent = fertilizerCount;
            const currentLevelData = TREE_LEVEL_DATA[treeLevel];
            useFertilizerBtn.disabled = treeLevel >= MAX_TREE_LEVEL_INDEX ||
                                       (treeLevel < MAX_TREE_LEVEL_INDEX && fertilizerCount < currentLevelData.fertilizerToNext);
            useFertilizerBtn.classList.toggle('btn-disabled', useFertilizerBtn.disabled);
        }
        function updateApplesCount() { applesCountEl.textContent = `${applesCount} 🍎`; }
        function updateApplesPerDay() { applesPerDayEl.textContent = `${applesPerDay} / día`; }

        function updateTreeVisual() {
            const currentLevelData = TREE_LEVEL_DATA[treeLevel];
            const gifPath = `gifs/${currentLevelData.gifName}`;
            treeDisplayEl.innerHTML = `<img src="${gifPath}" alt="Árbol de progreso del vocabulario: Nivel ${currentLevelData.name}" class="tree-gif mx-auto">`;
            treeLevelTextEl.textContent = `Nivel: ${currentLevelData.name}`;
            applesPerDay = currentLevelData.applesPerDay;
            updateApplesPerDay();
            if (treeLevel >= MAX_TREE_LEVEL_INDEX) {
                useFertilizerBtn.textContent = "¡Árbol Maximizado!";
                useFertilizerBtn.disabled = true;
            } else {
                useFertilizerBtn.textContent = `Crecer (${currentLevelData.fertilizerToNext} Fert.)`;
                useFertilizerBtn.disabled = fertilizerCount < currentLevelData.fertilizerToNext;
            }
            useFertilizerBtn.classList.toggle('btn-disabled', useFertilizerBtn.disabled);
        }

        function growTree() {
            if (treeLevel >= MAX_TREE_LEVEL_INDEX) {
                showTemporaryFeedback(feedbackTextEl, "Tu árbol ya está en el nivel máximo.", "info", 2500);
                return;
            }
            const requiredFertilizer = TREE_LEVEL_DATA[treeLevel].fertilizerToNext;
            if (fertilizerCount >= requiredFertilizer) {
                fertilizerCount -= requiredFertilizer;
                treeLevel++;
                updateTreeVisual();
                updateFertilizerCount();
                showTemporaryFeedback(feedbackTextEl, `¡Tu árbol creció a ${TREE_LEVEL_DATA[treeLevel].name}!`, "correct", 2500);
                treeDisplayEl.style.transform = 'scale(1.15)';
                setTimeout(() => { treeDisplayEl.style.transform = 'scale(1)'; }, 300);
                saveGameData();
            } else {
                 showTemporaryFeedback(feedbackTextEl, `Necesitas ${requiredFertilizer - fertilizerCount} más fertilizante.`, "info", 3000);
            }
        }

        function checkAndGenerateApples() {
            if (applesPerDay <= 0) {
                updateAppleCountdown();
                return;
            }
            const now = Date.now();
            const timeElapsedMs = now - lastAppleGenerationTime;
            const generationIntervalMs = ((24 * 60 * 60) / applesPerDay) * 1000;

            if (timeElapsedMs >= generationIntervalMs) {
                const applesToGenerate = Math.floor(timeElapsedMs / generationIntervalMs);
                applesCount += applesToGenerate;
                lastAppleGenerationTime += applesToGenerate * generationIntervalMs;
                updateApplesCount();
                showTemporaryFeedback(feedbackTextEl, `¡Cosechaste ${applesToGenerate} manzana(s) 🍎!`, "correct", 2000);
                saveGameData();
            }
            updateAppleCountdown();
        }

        function updateAppleCountdown() {
            if (appleCountdownInterval) clearInterval(appleCountdownInterval);
            if (applesPerDay <= 0) {
                appleCountdownEl.textContent = "--:--:--";
                return;
            }

            function calculateAndDisplayCountdown() {
                const now = Date.now();
                const generationIntervalMs = ((24 * 60 * 60) / applesPerDay) * 1000;
                const timeSinceLastApple = now - lastAppleGenerationTime;

                if (timeSinceLastApple >= generationIntervalMs && applesPerDay > 0) {
                    checkAndGenerateApples();
                    const newTimeSinceLastApple = now - lastAppleGenerationTime;
                    let timeToNextAppleMs = generationIntervalMs - (newTimeSinceLastApple % generationIntervalMs);
                    if (timeToNextAppleMs <= 0) timeToNextAppleMs = generationIntervalMs;

                    const h = String(Math.floor((timeToNextAppleMs / (1000 * 60 * 60)) % 24)).padStart(2, '0');
                    const m = String(Math.floor((timeToNextAppleMs / (1000 * 60)) % 60)).padStart(2, '0');
                    const s = String(Math.floor((timeToNextAppleMs / 1000) % 60)).padStart(2, '0');
                    appleCountdownEl.textContent = `${h}:${m}:${s}`;
                    return;
                }

                let timeToNextAppleMs = generationIntervalMs - (timeSinceLastApple % generationIntervalMs);

                if (timeToNextAppleMs <= 1000 && timeToNextAppleMs > 0) {
                     appleCountdownEl.textContent = "¡Ahora!";
                     return;
                }
                if (timeToNextAppleMs <= 0) timeToNextAppleMs = generationIntervalMs;


                const h = String(Math.floor((timeToNextAppleMs / (1000 * 60 * 60)) % 24)).padStart(2, '0');
                const m = String(Math.floor((timeToNextAppleMs / (1000 * 60)) % 60)).padStart(2, '0');
                const s = String(Math.floor((timeToNextAppleMs / 1000) % 60)).padStart(2, '0');
                appleCountdownEl.textContent = `${h}:${m}:${s}`;
            }
            calculateAndDisplayCountdown();
            appleCountdownInterval = setInterval(calculateAndDisplayCountdown, 1000);
        }


        function saveGameData() {
            const gameData = {
                flashcards, learnedFlashcards, currentCardIndex, score,
                fertilizerCount, treeLevel, applesCount,
                lastAppleGenerationTime,
                pointsThisHour, lastPointResetTime
            };
            localStorage.setItem('flashcardGameData', JSON.stringify(gameData));
        }

        function loadGameData() {
            const savedData = localStorage.getItem('flashcardGameData');
            if (savedData) {
                try {
                    const parsedData = JSON.parse(savedData);
                    flashcards = parsedData.flashcards || DEFAULT_FLASHCARDS.slice();
                    learnedFlashcards = parsedData.learnedFlashcards || [];
                    currentCardIndex = parsedData.currentCardIndex || 0;
                    score = parsedData.score || 0;
                    fertilizerCount = parsedData.fertilizerCount || 0;
                    treeLevel = parsedData.treeLevel || 0;
                    applesCount = parsedData.applesCount || 0;
                    lastAppleGenerationTime = parsedData.lastAppleGenerationTime || Date.now();
                    pointsThisHour = parsedData.pointsThisHour || 0;
                    lastPointResetTime = parsedData.lastPointResetTime || Date.now();


                    if (flashcards.length === 0 && DEFAULT_FLASHCARDS.length > 0 && learnedFlashcards.length === 0) {
                        flashcards = DEFAULT_FLASHCARDS.slice();
                        shuffleFlashcards();
                    }
                } catch (e) {
                    console.error("Error parseando datos guardados, reseteando a default:", e);
                    resetToDefaults();
                }
            } else {
                resetToDefaults();
            }
             checkHourlyPointLimit();
        }

        function resetToDefaults() {
            flashcards = DEFAULT_FLASHCARDS.slice();
            shuffleFlashcards();
            learnedFlashcards = [];
            currentCardIndex = 0;
            score = 0;
            fertilizerCount = 0;
            treeLevel = 0;
            applesCount = 0;
            lastAppleGenerationTime = Date.now();
            pointsThisHour = 0;
            lastPointResetTime = Date.now();
        }

        function updateAllStats() {
            updateScore();
            updateFertilizerCount();
            updateApplesCount();
            updateTreeVisual();
        }

        // --- Funciones de Modales y UI ---
        function openModal(modalElement) { modalElement.classList.remove('hidden'); }
        function closeModal(modalElement) { modalElement.classList.add('hidden'); }

        function clearFeedback(element, delay = 0) {
            const baseClass = element.className.split(' ').filter(cls => cls === 'feedback' || cls === 'text-center' || cls.startsWith('mt-') || cls.startsWith('h-')).join(' ');
            element.textContent = '';
            element.className = baseClass;
            if (delay > 0) {
                setTimeout(() => {
                    element.textContent = '';
                    element.className = baseClass;
                }, delay);
            }
        }

        function showTemporaryFeedback(element, message, type = 'info', duration = 3000) {
            clearFeedback(element);
            element.textContent = message;
            element.classList.add(type);

            if (duration > 0) {
                setTimeout(() => {
                    if (element.textContent === message) {
                        clearFeedback(element);
                        if (element === feedbackTextEl) {
                            if (flashcards.length === 0) {
                                 showTemporaryFeedback(feedbackTextEl, `¡No hay palabras! Añade algunas o compra un mazo para empezar. Necesitas ${MIN_CARDS_FOR_POINTS} palabras para ganar puntos.`, "info", 0);
                            } else if (flashcards.length < MIN_CARDS_FOR_POINTS) {
                                showTemporaryFeedback(feedbackTextEl, `Necesitas al menos ${MIN_CARDS_FOR_POINTS} palabras en el mazo para ganar puntos. Actualmente tienes ${flashcards.length}.`, "info", 0);
                            } else if (flashcards.length > 0 && flashcards.length < 3) {
                                showTemporaryFeedback(feedbackTextEl, `Añade más palabras para tener 3 opciones de respuesta (tienes ${flashcards.length}).`, "info", 0);
                            }
                        }
                    }
                }, duration);
            }
        }


        showAddCardModalBtn.addEventListener('click', () => {
            newQuestionInput.value = ''; newAnswerInput.value = '';
            clearFeedback(addCardFeedbackEl);
            openModal(addCardModal);
            newQuestionInput.focus();
        });
        cancelAddCardBtn.addEventListener('click', () => closeModal(addCardModal));
        saveCardBtn.addEventListener('click', () => {
            const newQ = newQuestionInput.value.trim();
            const newA = newAnswerInput.value.trim();
            if (newQ && newA) {
                if (flashcards.some(c => c.question.toLowerCase() === newQ.toLowerCase()) ||
                    learnedFlashcards.some(c => c.question.toLowerCase() === newQ.toLowerCase())) {
                    showTemporaryFeedback(addCardFeedbackEl, "Esa palabra ya existe en tus mazos.", "incorrect", 2500);
                    return;
                }
                const previousFlashcardCount = flashcards.length;
                flashcards.push({ question: newQ, answer: newA });
                shuffleFlashcards();
                saveGameData();
                showTemporaryFeedback(addCardFeedbackEl, "¡Palabra añadida con éxito!", "correct", 1500);
                newQuestionInput.value = ''; newAnswerInput.value = '';
                newQuestionInput.focus();

                const currentlyNoCards = questionTextEl.textContent.startsWith("¡No hay palabras!");

                if (flashcards.length >= MIN_CARDS_FOR_POINTS && previousFlashcardCount < MIN_CARDS_FOR_POINTS) {
                    clearFeedback(feedbackTextEl);
                    showTemporaryFeedback(feedbackTextEl, `¡Genial! Ahora tienes ${flashcards.length} palabras. Ya puedes ganar puntos de nuevo.`, "correct", 4000);
                } else if (flashcards.length < MIN_CARDS_FOR_POINTS) {
                    showTemporaryFeedback(feedbackTextEl, `Necesitas al menos ${MIN_CARDS_FOR_POINTS} palabras en el mazo para ganar puntos. Actualmente tienes ${flashcards.length}.`, "info", 0);
                } else if (flashcards.length > 0 && flashcards.length < 3) {
                     showTemporaryFeedback(feedbackTextEl, `Añade más palabras para tener 3 opciones de respuesta (tienes ${flashcards.length}).`, "info", 0);
                }


                if (currentlyNoCards && flashcards.length > 0) {
                    currentCardIndex = 0;
                    displayCard();
                } else if (flashcards.length === 1 && previousFlashcardCount === 0) {
                    displayCard();
                } else if (flashcards.length > 0 && multipleChoiceOptionsEl.innerHTML === '') {
                    displayCard();
                }


            } else {
                showTemporaryFeedback(addCardFeedbackEl, "Ambos campos son obligatorios.", "incorrect", 2000);
            }
        });

        function populateDeleteCardList() {
            deleteCardListContainerEl.innerHTML = '';
            clearFeedback(deleteFeedbackEl);

            const cardsToDeleteFrom = [...flashcards, ...learnedFlashcards];
            const uniqueCardsMap = new Map();
            cardsToDeleteFrom.forEach(card => {
                const key = card.question.toLowerCase();
                if (!uniqueCardsMap.has(key)) {
                    uniqueCardsMap.set(key, {
                        question: card.question,
                        answer: card.answer,
                        isLearned: learnedFlashcards.some(lc => lc.question.toLowerCase() === key)
                    });
                } else {
                    if (learnedFlashcards.some(lc => lc.question.toLowerCase() === key)) {
                        uniqueCardsMap.get(key).isLearned = true;
                    }
                }
            });
            const displayableCards = Array.from(uniqueCardsMap.values());


            if (displayableCards.length === 0) {
                noCardsToDeleteMsgEl.classList.remove('hidden');
                confirmDeleteCardBtn.disabled = true;
                confirmDeleteCardBtn.classList.add('btn-disabled');
                selectAllDeleteBtn.classList.add('hidden');
                return;
            }

            noCardsToDeleteMsgEl.classList.add('hidden');
            confirmDeleteCardBtn.disabled = false;
            confirmDeleteCardBtn.classList.remove('btn-disabled');

            selectAllDeleteBtn.classList.remove('hidden');
            selectAllDeleteBtn.textContent = 'Seleccionar Todas';

            displayableCards.sort((a, b) => a.question.localeCompare(b.question)).forEach((card, index) => {
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center p-1.5 hover:bg-gray-50 rounded';
                listItem.innerHTML = `
                    <input type="checkbox" id="delete-card-${index}" value="${card.question}" class="mr-2 rounded border-gray-300 text-[var(--duo-blue)] focus:ring-[var(--duo-blue)] h-4 w-4">
                    <label for="delete-card-${index}" class="flex-grow text-sm text-[var(--duo-text-dark)] cursor-pointer">
                        ${card.question} - ${card.answer}
                        ${card.isLearned ? '<span class="text-xs text-[var(--duo-green)] ml-1 font-semibold">(Aprendida)</span>' : ''}
                    </label>`;
                deleteCardListContainerEl.appendChild(listItem);
            });
        }
        showDeleteCardModalBtn.addEventListener('click', () => { populateDeleteCardList(); openModal(deleteCardModal); });
        cancelDeleteCardBtn.addEventListener('click', () => closeModal(deleteCardModal));

        confirmDeleteCardBtn.addEventListener('click', () => {
            const checkboxes = deleteCardListContainerEl.querySelectorAll('input[type="checkbox"]:checked');
            if (checkboxes.length === 0) {
                showTemporaryFeedback(deleteFeedbackEl, "Selecciona al menos una palabra para eliminar.", "incorrect", 2500);
                return;
            }
            const questionsToDelete = Array.from(checkboxes).map(cb => cb.value.toLowerCase());
            let deletedCount = 0;
            const currentQuestionBeforeDelete = flashcards.length > 0 && currentCardIndex < flashcards.length ? flashcards[currentCardIndex].question : null;
            const previousFlashcardCount = flashcards.length;

            const initialFlashcardsLength = flashcards.length;
            flashcards = flashcards.filter(card => !questionsToDelete.includes(card.question.toLowerCase()));
            deletedCount += (initialFlashcardsLength - flashcards.length);

            const initialLearnedLength = learnedFlashcards.length;
            learnedFlashcards = learnedFlashcards.filter(card => !questionsToDelete.includes(card.question.toLowerCase()));

            if (questionsToDelete.length > 0) {
                saveGameData();
                showTemporaryFeedback(deleteFeedbackEl, `${questionsToDelete.length} palabra(s) eliminada(s) permanentemente.`, "correct", 2000);

                const deckWasEmpty = previousFlashcardCount === 0;

                if (flashcards.length < MIN_CARDS_FOR_POINTS && previousFlashcardCount >= MIN_CARDS_FOR_POINTS && flashcards.length > 0) {
                     showTemporaryFeedback(feedbackTextEl, `Atención: Ahora tienes ${flashcards.length} palabras. Necesitas al menos ${MIN_CARDS_FOR_POINTS} para ganar puntos.`, "info", 0);
                } else if (flashcards.length >= MIN_CARDS_FOR_POINTS && previousFlashcardCount < MIN_CARDS_FOR_POINTS) {
                    clearFeedback(feedbackTextEl);
                    showTemporaryFeedback(feedbackTextEl, `¡Ahora tienes ${flashcards.length} palabras y puedes ganar puntos!`, "correct", 3000);
                } else if (flashcards.length > 0 && flashcards.length < 3) {
                    showTemporaryFeedback(feedbackTextEl, `Añade más palabras para tener 3 opciones de respuesta (tienes ${flashcards.length}).`, "info", 0);
                }


                if (flashcards.length > 0) {
                    const currentQuestionStillExists = flashcards.some(card => card.question === currentQuestionBeforeDelete);
                    if (!currentQuestionStillExists || currentCardIndex >= flashcards.length) {
                        currentCardIndex = 0;
                        shuffleFlashcards();
                    }
                    displayCard();
                } else {
                    handleNoCardsState();
                }
            } else {
                showTemporaryFeedback(deleteFeedbackEl, "No se eliminaron palabras.", "info", 2500);
            }
            populateDeleteCardList();
             if (deleteCardListContainerEl.querySelectorAll('input[type="checkbox"]').length === 0) {
                 noCardsToDeleteMsgEl.classList.remove('hidden');
                 confirmDeleteCardBtn.disabled = true; confirmDeleteCardBtn.classList.add('btn-disabled');
                 selectAllDeleteBtn.classList.add('hidden');
            }
        });

        function populateReviewLearnedList() {
            reviewLearnedListContainerEl.innerHTML = '';
            clearFeedback(reviewModalFeedbackEl);
            if (learnedFlashcards.length === 0) {
                noLearnedCardsMsgEl.classList.remove('hidden');
                return;
            }
            noLearnedCardsMsgEl.classList.add('hidden');
            learnedFlashcards.sort((a, b) => a.question.localeCompare(b.question)).forEach((card) => {
                const listItem = document.createElement('div');
                listItem.className = 'flex items-center justify-between p-1.5 hover:bg-gray-50 rounded';
                listItem.innerHTML = `
                    <span class="text-sm text-[var(--duo-text-dark)]">${card.question} - ${card.answer}</span>
                    <button data-question="${card.question}" class="btn btn-danger btn-sm remove-learned-btn !py-1 !px-2 !text-xs">Olvidar</button>`;
                reviewLearnedListContainerEl.appendChild(listItem);
            });
            reviewLearnedListContainerEl.querySelectorAll('.remove-learned-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const questionToRemove = e.target.dataset.question;
                    const cardIndexInLearned = learnedFlashcards.findIndex(c => c.question.toLowerCase() === questionToRemove.toLowerCase());
                    if (cardIndexInLearned > -1) {
                        const removedCard = learnedFlashcards.splice(cardIndexInLearned, 1)[0];
                        const previousFlashcardCount = flashcards.length;
                        const deckWasEmpty = previousFlashcardCount === 0;


                        if (!flashcards.some(fc => fc.question.toLowerCase() === removedCard.question.toLowerCase())) {
                            flashcards.push(removedCard);
                            shuffleFlashcards();
                        }
                        saveGameData();
                        populateReviewLearnedList();
                        showTemporaryFeedback(reviewModalFeedbackEl, `"${questionToRemove}" movida de nuevo al mazo principal.`, "info", 2000);

                        if (flashcards.length >= MIN_CARDS_FOR_POINTS && previousFlashcardCount < MIN_CARDS_FOR_POINTS) {
                             clearFeedback(feedbackTextEl);
                             showTemporaryFeedback(feedbackTextEl, `¡Bien! "${removedCard.question}" ha vuelto al mazo. Ya puedes ganar puntos de nuevo. (Total: ${flashcards.length})`, "correct", 4000);
                        } else if (flashcards.length < MIN_CARDS_FOR_POINTS) {
                            showTemporaryFeedback(feedbackTextEl, `Necesitas al menos ${MIN_CARDS_FOR_POINTS} palabras en el mazo para ganar puntos. Actualmente tienes ${flashcards.length}.`, "info", 0);
                        } else if (flashcards.length > 0 && flashcards.length < 3) {
                            showTemporaryFeedback(feedbackTextEl, `Añade más palabras para tener 3 opciones de respuesta (tienes ${flashcards.length}).`, "info", 0);
                        }


                        if (deckWasEmpty && flashcards.length > 0) {
                             currentCardIndex = flashcards.findIndex(c => c.question === removedCard.question);
                             if (currentCardIndex === -1) currentCardIndex = 0;
                             displayCard();
                        } else if (multipleChoiceOptionsEl.innerHTML === '' && flashcards.length > 0) {
                            displayCard();
                        }
                    }
                });
            });
        }
        closeReviewLearnedBtn.addEventListener('click', () => closeModal(reviewLearnedModal));

        function updateShopCosts() {
            fertilizerShopCostDisplayEl.textContent = FERTILIZER_SHOP_COST;
            appleShopCostDisplayEl.textContent = APPLE_SHOP_COST;
        }

        async function loadShopDecks() {
            shopDecksContainerEl.innerHTML = '';
            loadingDecksMsgEl.classList.remove('hidden');
            let decksDisplayed = 0;

            for (const deckDef of SHOP_DECK_DEFINITIONS) {
                try {
                    const response = await fetch(deckDef.fileName + `?v=${Date.now()}`);
                    if (!response.ok) {
                        throw new Error(`No se pudo cargar el mazo: ${deckDef.fileName} (Status: ${response.status})`);
                    }
                    const deckData = await response.json();
                    shopDecksData[deckDef.id] = deckData;

                    const deckItemEl = document.createElement('div');
                    deckItemEl.className = 'p-2.5 border border-[var(--duo-gray-light)] rounded-lg bg-[var(--duo-gray-lightest)]';
                    deckItemEl.innerHTML = `
    <div class="flex justify-between items-center">
        <div>
            <h4 class="font-semibold text-sm text-[var(--duo-text-dark)]">${deckData.name}</h4>
            <p class="text-xs text-[var(--duo-gray-dark)]">Costo: <span class="deck-cost">${deckData.cost}</span> 🍎 </p>
            <p class="text-xs text-[var(--duo-gray-dark)]">Palabras: ${deckData.cards.length}</p>
        </div>
        <button class="btn btn-primary btn-sm buy-deck-btn" data-deck-id="${deckDef.id}">Comprar</button>
    </div>
`;
                    shopDecksContainerEl.appendChild(deckItemEl);
                    decksDisplayed++;
                } catch (error) {
                    console.error(`Error cargando el mazo ${deckDef.fileName}:`, error);
                    const errorEl = document.createElement('p');
                    errorEl.className = 'text-xs text-center text-[var(--duo-red)]';
                    errorEl.textContent = `Error al cargar mazo: ${deckDef.id.replace(/_/g, ' ')}`;
                    shopDecksContainerEl.appendChild(errorEl);
                }
            }

            loadingDecksMsgEl.classList.add('hidden');
            if (decksDisplayed === 0 && SHOP_DECK_DEFINITIONS.length > 0) {
                 const noDecksMsg = document.createElement('p');
                 noDecksMsg.className = 'text-sm text-center text-[var(--duo-gray-dark)]';
                 noDecksMsg.textContent = 'No se pudieron cargar los mazos.';
                 shopDecksContainerEl.appendChild(noDecksMsg);
            } else if (SHOP_DECK_DEFINITIONS.length === 0) {
                const noDecksMsg = document.createElement('p');
                 noDecksMsg.className = 'text-sm text-center text-[var(--duo-gray-dark)]';
                 noDecksMsg.textContent = 'No hay mazos disponibles en este momento.';
                 shopDecksContainerEl.appendChild(noDecksMsg);
            }

            shopDecksContainerEl.querySelectorAll('.buy-deck-btn').forEach(button => {
                button.addEventListener('click', (e) => {
                    const deckId = e.target.dataset.deckId;
                    handleBuyDeck(deckId);
                });
            });
        }

        function handleBuyDeck(deckId) {
            const deckData = shopDecksData[deckId];
            if (!deckData) {
                showTemporaryFeedback(shopFeedbackEl, "Error: Mazo no encontrado.", "incorrect", 2500);
                return;
            }

            if (applesCount >= deckData.cost) {
                applesCount -= deckData.cost;
                let newCardsAddedCount = 0;
                const previousFlashcardCount = flashcards.length;
                const deckWasEmpty = previousFlashcardCount === 0;


                deckData.cards.forEach(cardFromDeck => {
                    const cardExists = flashcards.some(fc => fc.question.toLowerCase() === cardFromDeck.question.toLowerCase()) ||
                                       learnedFlashcards.some(lc => lc.question.toLowerCase() === cardFromDeck.question.toLowerCase());
                    if (!cardExists) {
                        flashcards.push({ question: cardFromDeck.question, answer: cardFromDeck.answer });
                        newCardsAddedCount++;
                    }
                });

                if (newCardsAddedCount > 0) {
                    shuffleFlashcards();
                     if (deckWasEmpty && flashcards.length > 0) {
                        currentCardIndex = 0;
                        displayCard();
                    } else if (multipleChoiceOptionsEl.innerHTML === '' && flashcards.length > 0) {
                        displayCard();
                    }

                    if (flashcards.length >= MIN_CARDS_FOR_POINTS && previousFlashcardCount < MIN_CARDS_FOR_POINTS) {
                         clearFeedback(feedbackTextEl);
                         showTemporaryFeedback(feedbackTextEl, `¡Mazo comprado! Ahora tienes ${flashcards.length} palabras y puedes ganar puntos.`, "correct", 4000);
                    } else if (flashcards.length < MIN_CARDS_FOR_POINTS) {
                        showTemporaryFeedback(feedbackTextEl, `Mazo comprado. Aún necesitas ${MIN_CARDS_FOR_POINTS - flashcards.length} palabras más para ganar puntos (Tienes ${flashcards.length}).`, "info", 0);
                    } else if (flashcards.length > 0 && flashcards.length < 3) {
                         showTemporaryFeedback(feedbackTextEl, `Mazo comprado. Añade más palabras para tener 3 opciones de respuesta (tienes ${flashcards.length}).`, "info", 0);
                    }
                }
                updateApplesCount();
                saveGameData();
                showTemporaryFeedback(shopFeedbackEl, `¡Mazo "${deckData.name}" comprado! Se añadieron ${newCardsAddedCount} nuevas palabras.`, "correct", 3000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, `Manzanas insuficientes para comprar "${deckData.name}". Necesitas ${deckData.cost - applesCount} más.`, "incorrect", 3000);
            }
        }


        openShopBtn.addEventListener('click', () => {
            clearFeedback(shopFeedbackEl);
            updateShopCosts();
            loadShopDecks();
            openModal(shopModal);
        });
        closeShopBtn.addEventListener('click', () => closeModal(shopModal));
        buyFertilizerShopBtn.addEventListener('click', () => {
            if (score >= FERTILIZER_SHOP_COST) {
                score -= FERTILIZER_SHOP_COST;
                fertilizerCount++;
                updateScore();
                updateFertilizerCount();
                saveGameData();
                showTemporaryFeedback(shopFeedbackEl, "¡Fertilizante comprado! Úsalo para crecer tu árbol.", "correct", 2000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, "Puntos insuficientes para comprar fertilizante.", "incorrect", 2000);
            }
        });
        buyAppleShopBtn.addEventListener('click', () => {
            if (score >= APPLE_SHOP_COST) {
                score -= APPLE_SHOP_COST;
                applesCount++;
                updateScore();
                updateApplesCount();
                saveGameData();
                showTemporaryFeedback(shopFeedbackEl, "¡Manzana comprada! 🍎 Deliciosa.", "correct", 2000);
            } else {
                showTemporaryFeedback(shopFeedbackEl, "Puntos insuficientes para comprar una manzana.", "incorrect", 2000);
            }
        });


        // --- Event Listeners ---
        learnedBtn.addEventListener('click', markAsLearned);
        nextCardBtn.addEventListener('click', () => moveToNextCard());
        useFertilizerBtn.addEventListener('click', growTree);
        exportProgressBtn.addEventListener('click', exportProgress);
        importProgressBtn.addEventListener('click', triggerImport);
        importProgressInput.addEventListener('change', handleImportFile);
        showReviewLearnedModalBtn.addEventListener('click', () => {
            populateReviewLearnedList();
            openModal(reviewLearnedModal);
        });
        downloadWordsBtn.addEventListener('click', downloadFlashcardsJson);

        selectAllDeleteBtn.addEventListener('click', () => {
            const checkboxes = deleteCardListContainerEl.querySelectorAll('input[type="checkbox"]');
            if (checkboxes.length === 0) return;

            const shouldSelectAll = selectAllDeleteBtn.textContent === 'Seleccionar Todas';
            checkboxes.forEach(checkbox => { checkbox.checked = shouldSelectAll; });
            selectAllDeleteBtn.textContent = shouldSelectAll ? 'Deseleccionar Todas' : 'Seleccionar Todas';
        });

        // Scroll arrow logic is now mostly disabled by CSS in mobile view.
        // Keeping the JS for desktop or if layout changes.
        scrollRightBtn.addEventListener('click', () => {
            if (window.innerWidth <= 1024 && mainContentAreaEl.classList.contains('horizontal-scroll-mobile')) { // Condition for old behavior if needed
                mainContentAreaEl.scrollBy({ left: mainContentAreaEl.offsetWidth, behavior: 'smooth' });
            }
        });
        scrollLeftBtn.addEventListener('click', () => {
             if (window.innerWidth <= 1024 && mainContentAreaEl.classList.contains('horizontal-scroll-mobile')) { // Condition for old behavior if needed
                mainContentAreaEl.scrollBy({ left: -mainContentAreaEl.offsetWidth, behavior: 'smooth' });
            }
        });
        mainContentAreaEl.addEventListener('scroll', () => {
            // This logic might not be needed if scroll-arrows are always hidden in mobile.
            // Or, it could be adapted if horizontal scroll is re-introduced in some specific mobile context.
            if (window.innerWidth <= 1024 && mainContentAreaEl.classList.contains('horizontal-scroll-mobile')) {
                const hasHorizontalScroll = mainContentAreaEl.scrollWidth > mainContentAreaEl.clientWidth + 5;
                 if (hasHorizontalScroll) {
                    scrollLeftBtn.classList.toggle('hidden', mainContentAreaEl.scrollLeft < 10);
                    scrollRightBtn.classList.toggle('hidden', mainContentAreaEl.scrollLeft + mainContentAreaEl.offsetWidth >= mainContentAreaEl.scrollWidth - 10);
                } else {
                    scrollLeftBtn.classList.add('hidden');
                    scrollRightBtn.classList.add('hidden');
                }
            } else if (window.innerWidth > 1024) { // Ensure hidden on desktop
                 scrollLeftBtn.classList.add('hidden');
                 scrollRightBtn.classList.add('hidden');
            }
        });

        function initGameVisuals() {
            answerInputEl.classList.add('hidden');
            checkAnswerBtn.classList.add('hidden');

            if (flashcards.length > 0) {
                if (currentCardIndex >= flashcards.length || currentCardIndex < 0) currentCardIndex = 0;
                displayCard();
            } else {
                handleNoCardsState();
            }
            updateAllStats();
            checkAndGenerateApples();
            // checkScrollArrowsVisibility(); // This might be obsolete or need adjustment
        }


        async function initGame() {
            await initCryptoKey();
            loadGameData();
            initGameVisuals();
            if (!window.appleCheckIntervalId) {
                 window.appleCheckIntervalId = setInterval(checkAndGenerateApples, CHECK_APPLES_INTERVAL);
            }
        }

        // Obsolete with new CSS, but kept for reference or future changes
        /*
        function checkScrollArrowsVisibility() {
             if (window.innerWidth <= 1024) {
                const hasHorizontalScroll = mainContentAreaEl.scrollWidth > mainContentAreaEl.clientWidth + 5;
                // Logic to show/hide arrows based on scroll position for horizontal scroll
             } else {
                scrollLeftBtn.classList.add('hidden');
                scrollRightBtn.classList.add('hidden');
            }
        }
        */

        window.onload = initGame;
        // window.addEventListener('resize', checkScrollArrowsVisibility); // May no longer be needed for arrows
        window.addEventListener('resize', () => {
            // Potentially re-evaluate layout aspects on resize if needed,
            // but CSS media queries should handle most of it.
        });

    </script>
</body>
</html>